
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module frequency_meter_Nios_display(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
	inout 		    [35:0]		GPIO_0,

	//////////// GPIO_1, GPIO_1 connect to GPIO Default //////////
	inout 		    [35:0]		GPIO_1
);



//=======================================================
//  REG/WIRE declarations
//=======================================================

wire cout_i, cout_b, clk_base, clk_in;
reg freq_en = 0, count_en = 0;
reg [7:0] count_clk;
wire [31:0] freq_mem; //регистр-хранилище для данных об измеряемой частоте


//=======================================================
//  Structural coding
//=======================================================

Nios_display_system u0 (
	  .clk_clk       (CLOCK_50),       //   clk.clk
	  .reset_reset_n (KEY[0]), // reset.reset_n
	  .key_export    (KEY[3:1]),    //   key.export
	  .led_export    (LEDR),     //   led.export
	  .sdram_addr    (DRAM_ADDR),    // sdram.addr
	  .sdram_ba      (DRAM_BA),      //      .ba
	  .sdram_cas_n   (DRAM_CAS_N),   //      .cas_n
	  .sdram_cke     (DRAM_CKE),     //      .cke
	  .sdram_cs_n    (DRAM_CS_N),    //      .cs_n
	  .sdram_dq      (DRAM_DQ),      //      .dq
	  .sdram_dqm     ({DRAM_UDQM,DRAM_LDQM}),     //      .dqm
	  .sdram_ras_n   (DRAM_RAS_N),   //      .ras_n
	  .sdram_we_n    (DRAM_WE_N),     //      .we_n
	  .sdram_clk_clk (DRAM_CLK),
	  .lcd_data_export (GPIO_1[20:13]), //  lcd_data.export
	  .lcd_e_export    (GPIO_1[12]),    //     lcd_e.export
	  .lcd_rs_export   (GPIO_1[10]),   //    lcd_rs.export
	  .lcd_rw_export   (GPIO_1[11]),   //    lcd_rw.export
	  .sw_export       (SW),        //        sw.export
	  .freq_export		 (freq_mem),     	//     freq.export
	  .freq_en_export  (freq_en)  //   freq_en.export

 );
 
 PLL_base pll_base
 (
	
	.refclk(CLOCK_50),
	.rst(~KEY[0]),
	.outclk_0(clk_base),
	.outclk_1(clk_in)
	
 );
 
 freq_m_module freq_meter
(
	
	.clk_base(clk_base),
	.clk_in(clk_in),
	.freq_mem(freq_mem),
	.cout_i(cout_i),
	.cout_b(cout_b)
	
);

always @(posedge CLOCK_50)
begin
	
	if (cout_b == 1'b1)
	begin
		
		freq_en = 1'b1;
		count_en = 1'b1;
		
	end
	
	if (count_en == 1'b1) count_clk = count_clk + 1'b1;
	
	if (count_clk == 8'd100)
	begin
		
		freq_en = 1'b0;
		count_en = 1'b0;
		count_clk = 8'b0;
		
	end
	
end

endmodule
