
freq_meter_nios.elf:     file format elf32-littlenios2
freq_meter_nios.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00800254

Program Header:
    LOAD off    0x00001000 vaddr 0x00800000 paddr 0x00800000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00800020 paddr 0x00800020 align 2**12
         filesz 0x00008ee8 memsz 0x00008ee8 flags r-x
    LOAD off    0x00009f08 vaddr 0x00808f08 paddr 0x0080a21c align 2**12
         filesz 0x00001314 memsz 0x00001314 flags rw-
    LOAD off    0x0000b530 vaddr 0x0080b530 paddr 0x0080b530 align 2**12
         filesz 0x00000000 memsz 0x0003d2c8 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00800000  00800000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000234  00800020  00800020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00008b64  00800254  00800254  00001254  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000150  00808db8  00808db8  00009db8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001314  00808f08  0080a21c  00009f08  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0003d372  0080b530  0080b530  0000b530  2**2
                  ALLOC, SMALL_DATA
  6 .sdram        00000000  008487f8  008487f8  0000b21c  2**0
                  CONTENTS
  7 .onchip_memory2_0 00000000  01080000  01080000  0000b21c  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  0000b21c  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00000758  00000000  00000000  0000b240  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0000e08f  00000000  00000000  0000b998  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00003fa3  00000000  00000000  00019a27  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000579e  00000000  00000000  0001d9ca  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00002250  00000000  00000000  00023168  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    000035eb  00000000  00000000  000253b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00001877  00000000  00000000  000289a3  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000030  00000000  00000000  0002a21c  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 000002e8  00000000  00000000  0002a250  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000003  00000000  00000000  0002dabe  2**0
                  CONTENTS, READONLY
 19 .cpu          0000000c  00000000  00000000  0002dac1  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  0002dacd  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  0002dace  2**0
                  CONTENTS, READONLY
 22 .sysid_hash   00000004  00000000  00000000  0002dacf  2**0
                  CONTENTS, READONLY
 23 .sysid_base   00000004  00000000  00000000  0002dad3  2**0
                  CONTENTS, READONLY
 24 .sysid_time   00000004  00000000  00000000  0002dad7  2**0
                  CONTENTS, READONLY
 25 .stderr_dev   0000000b  00000000  00000000  0002dadb  2**0
                  CONTENTS, READONLY
 26 .stdin_dev    0000000b  00000000  00000000  0002dae6  2**0
                  CONTENTS, READONLY
 27 .stdout_dev   0000000b  00000000  00000000  0002daf1  2**0
                  CONTENTS, READONLY
 28 .sopc_system_name 00000013  00000000  00000000  0002dafc  2**0
                  CONTENTS, READONLY
 29 .quartus_project_dir 00000045  00000000  00000000  0002db0f  2**0
                  CONTENTS, READONLY
 30 .jdi          0000483f  00000000  00000000  0002db54  2**0
                  CONTENTS, READONLY
 31 .sopcinfo     00077244  00000000  00000000  00032393  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00800000 l    d  .entry	00000000 .entry
00800020 l    d  .exceptions	00000000 .exceptions
00800254 l    d  .text	00000000 .text
00808db8 l    d  .rodata	00000000 .rodata
00808f08 l    d  .rwdata	00000000 .rwdata
0080b530 l    d  .bss	00000000 .bss
008487f8 l    d  .sdram	00000000 .sdram
01080000 l    d  .onchip_memory2_0	00000000 .onchip_memory2_0
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../freq_meter_nios_bsp//obj/HAL/src/crt0.o
0080029c l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 obj/default/Source/portable/GCC/NiosII/port_asm.o
00800020 l       .exceptions	00000000 save_context
0080009c l       .exceptions	00000000 save_sp_to_pxCurrentTCB
008000ac l       .exceptions	00000000 hw_irq_test
00800150 l       .exceptions	00000000 soft_exceptions
008000c0 l       .exceptions	00000000 hw_irq_handler
008000d4 l       .exceptions	00000000 restore_context
0080016c l       .exceptions	00000000 call_scheduler
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 croutine.c
00000000 l    df *ABS*	00000000 event_groups.c
00800930 l     F .text	00000070 prvTestWaitCondition
00000000 l    df *ABS*	00000000 list.c
00000000 l    df *ABS*	00000000 port.c
00800c30 l     F .text	0000002c prvReadGp
00800d94 l     F .text	0000009c prvSetupTimerInterrupt
00000000 l    df *ABS*	00000000 heap_1.c
0080b5a0 l     O .bss	0003d090 ucHeap
0080b530 l     O .bss	00000004 xNextFreeByte
0080b534 l     O .bss	00000004 pucAlignedHeap.2618
00000000 l    df *ABS*	00000000 queue.c
008012fc l     F .text	00000084 prvInitialiseNewQueue
00801380 l     F .text	00000060 prvInitialiseMutex
00802164 l     F .text	0000018c prvCopyDataToQueue
00802518 l     F .text	00000058 prvIsQueueFull
0080238c l     F .text	000000f4 prvUnlockQueue
008022f0 l     F .text	0000009c prvCopyDataFromQueue
00802480 l     F .text	00000050 prvIsQueueEmpty
00802114 l     F .text	00000050 prvGetDisinheritPriorityAfterTimeout
00000000 l    df *ABS*	00000000 stream_buffer.c
008033e4 l     F .text	00000080 prvInitialiseNewStreamBuffer
00803370 l     F .text	00000074 prvBytesInBuffer
00802b18 l     F .text	000000d4 prvWriteMessageToBuffer
00803168 l     F .text	000000f4 prvWriteBytesToBuffer
00802ed0 l     F .text	000000bc prvReadMessageFromBuffer
0080325c l     F .text	00000114 prvReadBytesFromBuffer
00000000 l    df *ABS*	00000000 tasks.c
00848630 l     O .bss	00000064 pxReadyTasksLists
00848694 l     O .bss	00000014 xDelayedTaskList1
008486a8 l     O .bss	00000014 xDelayedTaskList2
0080b53c l     O .bss	00000004 pxDelayedTaskList
0080b540 l     O .bss	00000004 pxOverflowDelayedTaskList
008486bc l     O .bss	00000014 xPendingReadyList
008486d0 l     O .bss	00000014 xTasksWaitingTermination
0080b544 l     O .bss	00000004 uxDeletedTasksWaitingCleanUp
008486e4 l     O .bss	00000014 xSuspendedTaskList
0080b548 l     O .bss	00000004 uxCurrentNumberOfTasks
0080b54c l     O .bss	00000004 xTickCount
0080b550 l     O .bss	00000004 uxTopReadyPriority
0080b554 l     O .bss	00000004 xSchedulerRunning
0080b558 l     O .bss	00000004 xPendedTicks
0080b55c l     O .bss	00000004 xYieldPending
0080b560 l     O .bss	00000004 xNumOfOverflows
0080b564 l     O .bss	00000004 uxTaskNumber
0080b568 l     O .bss	00000004 xNextTaskUnblockTime
0080b56c l     O .bss	00000004 xIdleTaskHandle
0080b570 l     O .bss	00000004 uxSchedulerSuspended
0080354c l     F .text	000001e4 prvInitialiseNewTask
00803730 l     F .text	000000fc prvAddNewTaskToReadyList
008049bc l     F .text	000000b8 prvInitialiseTaskLists
00804bb8 l     F .text	00000044 prvDeleteTCB
00804bfc l     F .text	00000054 prvResetNextTaskUnblockTime
00805868 l     F .text	000000e8 prvAddCurrentTaskToDelayedList
00803da4 l     F .text	0000006c prvTaskIsTaskSuspended
008049a0 l     F .text	0000001c prvIdleTask
00804a74 l     F .text	00000080 prvCheckTasksWaitingTermination
00804af4 l     F .text	00000064 prvTaskCheckFreeStackSpace
00000000 l    df *ABS*	00000000 timers.c
00000000 l    df *ABS*	00000000 main.c
00805950 l     F .text	0000004c set_output
0080599c l     F .text	00000064 enable
00805a00 l     F .text	00000074 write
00805a74 l     F .text	00000094 read_busy
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 vsprintf.c
00000000 l    df *ABS*	00000000 fvwrite_small_dev.c
00000000 l    df *ABS*	00000000 fvwrite_small_str.c
00000000 l    df *ABS*	00000000 impure.c
00808f08 l     O .rwdata	000000e0 impure_data
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 vfprintf.c
008068c0 l     F .text	0000006c print_repeat
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_load.c
00807078 l     F .text	00000068 alt_load_section
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_putstr.c
00000000 l    df *ABS*	00000000 alt_write.c
00807214 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
0080735c l     F .text	00000038 alt_dev_reg
00808fe8 l     O .rwdata	00001060 jtag_uart_0
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
00807638 l     F .text	00000210 altera_avalon_jtag_uart_irq
00807848 l     F .text	000000a8 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_close.c
00807fc8 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
00808130 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
0080815c l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
00808284 l     F .text	000000c4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_open.c
008083c4 l     F .text	00000050 alt_get_errno
00808414 l     F .text	000000cc alt_file_locked
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 fputs.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
00807164 g     F .text	0000006c alt_main
008065d8 g     F .text	00000080 _puts_r
008486f8 g     O .bss	00000100 alt_irq
008000c4 g       .exceptions	00000000 restore_sp_from_pxCurrentTCB
008045f0 g     F .text	00000064 vTaskPlaceOnUnorderedEventList
00801124 g     F .text	0000002c xPortGetFreeHeapSize
00800688 g     F .text	0000003c xEventGroupGetBitsFromISR
0080a21c g       *ABS*	00000000 __flash_rwdata_start
00803a60 g     F .text	00000058 uxTaskPriorityGet
008066e4 g     F .text	0000001c vsprintf
00802bec g     F .text	00000158 xStreamBufferReceive
00805b9c g     F .text	00000094 hd44780_home
008002f4 g     F .text	00000184 xEventGroupSync
00806860 g     F .text	00000060 memmove
00804ff4 g     F .text	00000054 vTaskEnterCritical
00801774 g     F .text	000000f4 xQueueGenericSendFromISR
0080428c g     F .text	00000040 pcTaskGetName
0080b574 g     O .bss	00000004 n
0080b578 g     O .bss	00000004 Queue_lcd_rs
008027d8 g     F .text	00000088 xStreamBufferSpacesAvailable
008071d0 g     F .text	00000044 alt_putstr
00808840 g     F .text	00000024 altera_nios2_gen2_irq_init
008026d0 g     F .text	0000009c xStreamBufferReset
008067b8 g     F .text	000000a8 __sfvwrite_small_str
00800000 g     F .entry	0000001c __reset
0080143c g     F .text	00000090 xQueueGiveMutexRecursive
0080b538 g     O .bss	00000004 pxCurrentTCB
00800020 g       *ABS*	00000000 __flash_exceptions_start
0080b584 g     O .bss	00000004 errno
00802a28 g     F .text	000000f0 xStreamBufferSendFromISR
0080b590 g     O .bss	00000004 alt_argv
008121f0 g       *ABS*	00000000 _gp
00803b04 g     F .text	000001a4 vTaskPrioritySet
0080485c g     F .text	0000003c vTaskInternalSetTimeOutState
00800478 g     F .text	000001a8 xEventGroupWaitBits
00806110 g     F .text	0000016c hd44780_init
0080a070 g     O .rwdata	00000180 alt_fd_list
00805c30 g     F .text	000000d4 hd44780_display
00800d3c g     F .text	00000038 xPortStartScheduler
008057f0 g     F .text	00000078 ulTaskNotifyValueClear
0080404c g     F .text	00000048 vTaskEndScheduler
00808864 g     F .text	00000090 alt_find_dev
00806590 g     F .text	00000028 memcpy
008045a0 g     F .text	00000050 vTaskPlaceOnEventList
00804748 g     F .text	000000c8 vTaskRemoveFromUnorderedEventList
00808348 g     F .text	0000007c alt_io_redirect
00801f90 g     F .text	0000007c xQueuePeekFromISR
00806658 g     F .text	00000014 puts
008010dc g     F .text	00000024 vPortFree
00801aec g     F .text	00000210 xQueueSemaphoreTake
00807a48 g     F .text	0000021c altera_avalon_jtag_uart_read
00805fb8 g     F .text	0000009c hd44780_print
01080000 g       *ABS*	00000000 __alt_mem_onchip_memory2_0
00806fbc g     F .text	00000064 .hidden __udivsi3
00804b58 g     F .text	00000060 uxTaskGetStackHighWaterMark
00800a34 g     F .text	0000008c vListInsertEnd
00808abc g     F .text	00000090 alt_icache_flush
008002a0 g     F .text	00000054 xEventGroupCreate
008008b8 g     F .text	0000003c vEventGroupSetBitsCallback
00803edc g     F .text	000000e0 xTaskResumeFromISR
00800a08 g     F .text	0000002c vListInitialiseItem
0080a20c g     O .rwdata	00000004 alt_max_fd
00800e30 g     F .text	0000004c vPortSysTickHandler
00801944 g     F .text	000001a8 xQueueReceive
00803ab8 g     F .text	0000004c uxTaskPriorityGetFromISR
00800e7c g     F .text	000001a0 alt_irq_register
0080a1f0 g     O .rwdata	00000004 _global_impure_ptr
008006c4 g     F .text	00000180 xEventGroupSetBits
008487f8 g       *ABS*	00000000 __bss_end
00808738 g     F .text	00000108 alt_tick
00806364 g     F .text	00000060 sayInBitween
0080101c g     F .text	000000c0 pvPortMalloc
008020d8 g     F .text	0000003c vQueueDelete
00800d74 g     F .text	00000020 vPortEndScheduler
008009a0 g     F .text	00000068 vListInitialise
00802f8c g     F .text	00000058 xStreamBufferIsEmpty
0080869c g     F .text	0000009c alt_alarm_stop
0080b588 g     O .bss	00000004 alt_irq_active
0080017c g     F .exceptions	000000d8 alt_irq_handler
0080a048 g     O .rwdata	00000028 alt_dev_null
00804218 g     F .text	00000028 xTaskGetTickCount
008015c0 g     F .text	000001b4 xQueueGenericSend
008028a0 g     F .text	00000188 xStreamBufferSend
008030e4 g     F .text	00000084 xStreamBufferReceiveCompletedFromISR
00805b08 g     F .text	00000094 hd44780_clear
008080e8 g     F .text	00000048 alt_dcache_flush_all
00802d44 g     F .text	000000a8 xStreamBufferNextMessageLengthBytes
00804db8 g     F .text	000000fc xTaskPriorityDisinherit
0080a21c g       *ABS*	00000000 __ram_rwdata_end
0080a204 g     O .rwdata	00000008 alt_dev_list
00807264 g     F .text	000000f8 write
00804654 g     F .text	000000f4 xTaskRemoveFromEventList
00808f08 g       *ABS*	00000000 __ram_rodata_end
00800620 g     F .text	00000068 xEventGroupClearBits
00801cfc g     F .text	000001b0 xQueuePeek
00807020 g     F .text	00000058 .hidden __umodsi3
008487f8 g       *ABS*	00000000 end
00802dec g     F .text	000000e4 xStreamBufferReceiveFromISR
0080382c g     F .text	000000e8 vTaskDelete
0080757c g     F .text	000000bc altera_avalon_jtag_uart_init
008050ec g     F .text	00000038 pvTaskIncrementMutexHeldCount
01000000 g       *ABS*	00000000 __alt_stack_pointer
00807c64 g     F .text	00000224 altera_avalon_jtag_uart_write
00804898 g     F .text	000000e0 xTaskCheckForTimeOut
00804c78 g     F .text	00000140 xTaskPriorityInherit
00808bf4 g     F .text	00000190 __call_exitprocs
0080266c g     F .text	00000064 vStreamBufferDelete
00805124 g     F .text	000000b0 ulTaskNotifyTake
00800254 g     F .text	0000004c _start
00805df0 g     F .text	00000130 hd44780_cgram
0080b598 g     O .bss	00000004 _alt_tick_rate
00804094 g     F .text	0000002c vTaskSuspendAll
00802fe4 g     F .text	0000007c xStreamBufferIsFull
00804240 g     F .text	0000002c xTaskGetTickCountFromISR
0080b59c g     O .bss	00000004 _alt_nticks
008073cc g     F .text	0000004c alt_sys_init
00800b98 g     F .text	00000098 uxListRemove
008025c0 g     F .text	000000ac xStreamBufferGenericCreate
008078f0 g     F .text	00000068 altera_avalon_jtag_uart_close
00808f08 g       *ABS*	00000000 __ram_rwdata_start
00808db8 g       *ABS*	00000000 __ram_rodata_start
00805778 g     F .text	00000078 xTaskNotifyStateClear
00803e10 g     F .text	000000cc vTaskResume
008044c8 g     F .text	000000d8 vTaskSwitchContext
00807418 g     F .text	00000060 altera_avalon_jtag_uart_read_fd
00808a08 g     F .text	000000b4 alt_get_fd
008051d4 g     F .text	000000f4 xTaskNotifyWait
00808bc4 g     F .text	00000030 memcmp
008074d8 g     F .text	00000050 altera_avalon_jtag_uart_close_fd
008487f8 g       *ABS*	00000000 __alt_stack_base
00807528 g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
00803ca8 g     F .text	000000fc vTaskSuspend
008042cc g     F .text	0000004c xTaskCatchUpTicks
0080426c g     F .text	00000020 uxTaskGetNumberOfTasks
008088f4 g     F .text	00000114 alt_find_file
008081ac g     F .text	000000a4 alt_dev_llist_insert
0080692c g     F .text	00000524 ___svfprintf_internal_r
008014cc g     F .text	0000009c xQueueTakeMutexRecursive
00800844 g     F .text	00000074 vEventGroupDelete
008052c8 g     F .text	000001ac xTaskGenericNotify
0080b57c g     O .bss	00000004 Queue_lcd_data
00806700 g     F .text	000000b8 __sfvwrite_small_dev
0080b530 g       *ABS*	00000000 __bss_start
00805f20 g     F .text	00000098 hd44780_put
0080627c g     F .text	000000e8 sayHello
008065b8 g     F .text	00000020 memset
00806470 g     F .text	00000120 main
0080b594 g     O .bss	00000004 alt_envp
00807478 g     F .text	00000060 altera_avalon_jtag_uart_write_fd
00800ac0 g     F .text	000000d8 vListInsert
0080a210 g     O .rwdata	00000004 alt_errno
00803914 g     F .text	000000f0 vTaskDelayUntil
00801eac g     F .text	000000e4 xQueueReceiveFromISR
00804c50 g     F .text	00000028 xTaskGetCurrentTaskHandle
00806ec4 g     F .text	00000084 .hidden __divsi3
00801264 g     F .text	00000098 xQueueGenericCreate
00801568 g     F .text	00000058 xQueueCreateCountingSemaphore
00808db8 g       *ABS*	00000000 __flash_rodata_start
0080276c g     F .text	0000006c xStreamBufferSetTriggerLevel
00805474 g     F .text	000001e4 xTaskGenericNotifyFromISR
00807394 g     F .text	00000038 alt_irq_init
00808638 g     F .text	00000064 alt_release_fd
008040c0 g     F .text	00000158 xTaskResumeAll
0080204c g     F .text	00000054 uxQueueSpacesAvailable
00803fbc g     F .text	00000090 vTaskStartScheduler
00806e6c g     F .text	00000058 _write_r
00806688 g     F .text	0000005c _vsprintf_r
00802570 g     F .text	00000050 xQueueIsQueueFullFromISR
0080a1f4 g     O .rwdata	00000004 _impure_ptr
0080b58c g     O .bss	00000004 alt_argc
00804978 g     F .text	00000028 vTaskMissedYield
0080a1fc g     O .rwdata	00000008 alt_fs_list
00806e50 g     F .text	0000001c __vfprintf_internal_unused
0080200c g     F .text	00000040 uxQueueMessagesWaiting
00804318 g     F .text	000001b0 xTaskIncrementTick
00800020 g       *ABS*	00000000 __ram_exceptions_start
00806054 g     F .text	000000bc hd44780_printf
00801150 g     F .text	00000114 xQueueGenericReset
0080a21c g       *ABS*	00000000 _edata
008487f8 g       *ABS*	00000000 _end
00800254 g       *ABS*	00000000 __ram_exceptions_end
00807958 g     F .text	000000f0 altera_avalon_jtag_uart_ioctl
00803464 g     F .text	000000e8 xTaskCreate
00801100 g     F .text	00000024 vPortInitialiseBlocks
00808b4c g     F .text	00000020 exit
00806f48 g     F .text	00000074 .hidden __modsi3
00803a04 g     F .text	0000005c vTaskDelay
01000000 g       *ABS*	00000000 __alt_data_end
00800000 g       *ABS*	00000000 __alt_mem_sdram
00804eb4 g     F .text	00000140 vTaskPriorityDisinheritAfterTimeout
00808d84 g     F .text	00000034 _exit
00807e88 g     F .text	00000140 alt_alarm_start
008063c4 g     F .text	000000ac task_lcd_write
00805048 g     F .text	00000060 vTaskExitCritical
0080666c g     F .text	0000001c strlen
00800c5c g     F .text	000000e0 pxPortInitialiseStack
008084e0 g     F .text	00000158 open
00805d04 g     F .text	000000ec hd44780_position
00808250 g     F .text	00000034 alt_icache_flush_all
00804810 g     F .text	0000004c vTaskSetTimeOutState
00808b6c g     F .text	00000058 fputs
0080a1f8 g     O .rwdata	00000004 alt_priority_mask
0080b580 g     O .bss	00000004 Mutex_write_lcd
008020a0 g     F .text	00000038 uxQueueMessagesWaitingFromISR
008024d0 g     F .text	00000048 xQueueIsQueueEmptyFromISR
00802860 g     F .text	00000040 xStreamBufferBytesAvailable
0080a214 g     O .rwdata	00000008 alt_alarm_list
008050a8 g     F .text	00000044 uxTaskResetEventItemValue
008013e0 g     F .text	0000005c xQueueCreateMutex
00808018 g     F .text	000000d0 close
00805658 g     F .text	00000120 vTaskNotifyGiveFromISR
008070e0 g     F .text	00000084 alt_load
008008f4 g     F .text	0000003c vEventGroupClearBitsCallback
00803060 g     F .text	00000084 xStreamBufferSendCompletedFromISR
00801868 g     F .text	000000dc xQueueGiveFromISR



Disassembly of section .entry:

00800000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && (!defined(ALT_SIM_OPTIMIZE) || defined(NIOS2_ECC_PRESENT))
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
  800000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
  800004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
  800008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
  80000c:	00bffd16 	blt	zero,r2,800004 <__alt_mem_onchip_memory2_0+0xff780004>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
  800010:	00402034 	movhi	at,128
    ori r1, r1, %lo(_start)
  800014:	08409514 	ori	at,at,596
    jmp r1
  800018:	0800683a 	jmp	at
  80001c:	00000000 	call	0 <__reset-0x800000>

Disassembly of section .exceptions:

00800020 <save_context>:
# Entry point for exceptions.
.section .exceptions.entry, "xa"		

# Save the entire context of a task.
save_context:
	addi	ea, ea, -4			# Point to the next instruction.
  800020:	ef7fff04 	addi	ea,ea,-4
	addi	sp,	sp, -116		# Create space on the stack.
  800024:	deffe304 	addi	sp,sp,-116
	stw		ra, 0(sp)
  800028:	dfc00015 	stw	ra,0(sp)
								# Leave a gap for muldiv 0
	stw		at, 8(sp)		 
  80002c:	d8400215 	stw	at,8(sp)
	stw		r2, 12(sp)
  800030:	d8800315 	stw	r2,12(sp)
	stw		r3, 16(sp)
  800034:	d8c00415 	stw	r3,16(sp)
	stw		r4, 20(sp)
  800038:	d9000515 	stw	r4,20(sp)
	stw		r5, 24(sp) 
  80003c:	d9400615 	stw	r5,24(sp)
	stw		r6, 28(sp) 
  800040:	d9800715 	stw	r6,28(sp)
	stw		r7, 32(sp) 
  800044:	d9c00815 	stw	r7,32(sp)
	stw		r8, 36(sp) 
  800048:	da000915 	stw	r8,36(sp)
	stw		r9, 40(sp) 
  80004c:	da400a15 	stw	r9,40(sp)
	stw		r10, 44(sp)
  800050:	da800b15 	stw	r10,44(sp)
	stw		r11, 48(sp)
  800054:	dac00c15 	stw	r11,48(sp)
	stw		r12, 52(sp)
  800058:	db000d15 	stw	r12,52(sp)
	stw		r13, 56(sp)
  80005c:	db400e15 	stw	r13,56(sp)
	stw		r14, 60(sp)
  800060:	db800f15 	stw	r14,60(sp)
	stw		r15, 64(sp)
  800064:	dbc01015 	stw	r15,64(sp)
	rdctl	r5, estatus 		# Save the eStatus
  800068:	000b307a 	rdctl	r5,estatus
	stw		r5, 68(sp)
  80006c:	d9401115 	stw	r5,68(sp)
	stw		ea, 72(sp)			# Save the PC
  800070:	df401215 	stw	ea,72(sp)
	stw		r16, 76(sp)			# Save the remaining registers
  800074:	dc001315 	stw	r16,76(sp)
	stw		r17, 80(sp)
  800078:	dc401415 	stw	r17,80(sp)
	stw		r18, 84(sp)
  80007c:	dc801515 	stw	r18,84(sp)
	stw		r19, 88(sp)
  800080:	dcc01615 	stw	r19,88(sp)
	stw		r20, 92(sp)
  800084:	dd001715 	stw	r20,92(sp)
	stw		r21, 96(sp)
  800088:	dd401815 	stw	r21,96(sp)
	stw		r22, 100(sp)
  80008c:	dd801915 	stw	r22,100(sp)
	stw		r23, 104(sp)
  800090:	ddc01a15 	stw	r23,104(sp)
	stw		gp, 108(sp)
  800094:	de801b15 	stw	gp,108(sp)
	stw		fp, 112(sp)
  800098:	df001c15 	stw	fp,112(sp)

0080009c <save_sp_to_pxCurrentTCB>:
  80009c:	06002074 	movhi	et,129

save_sp_to_pxCurrentTCB:
	movia	et, pxCurrentTCB	# Load the address of the pxCurrentTCB pointer
  8000a0:	c62d4e04 	addi	et,et,-19144
	ldw		et, (et)			# Load the value of the pxCurrentTCB pointer
  8000a4:	c6000017 	ldw	et,0(et)
	stw		sp, (et)			# Store the stack pointer into the top of the TCB
  8000a8:	c6c00015 	stw	sp,0(et)

008000ac <hw_irq_test>:
hw_irq_test:
	/*
     * Test to see if the exception was a software exception or caused 
     * by an external interrupt, and vector accordingly.
     */
    rdctl	r4, ipending		# Load the Pending Interrupts indication
  8000ac:	0009313a 	rdctl	r4,ipending
	rdctl	r5, estatus 		# Load the eStatus (enabled interrupts).
  8000b0:	000b307a 	rdctl	r5,estatus
    andi	r2, r5, 1			# Are interrupts enabled globally.
  8000b4:	2880004c 	andi	r2,r5,1
    beq		r2, zero, soft_exceptions		# Interrupts are not enabled.
  8000b8:	10002526 	beq	r2,zero,800150 <soft_exceptions>
    beq		r4, zero, soft_exceptions		# There are no interrupts triggered.
  8000bc:	20002426 	beq	r4,zero,800150 <soft_exceptions>

008000c0 <hw_irq_handler>:

	.section .exceptions.irqhandler, "xa"
hw_irq_handler:
	call	alt_irq_handler					# Call the alt_irq_handler to deliver to the registered interrupt handler.
  8000c0:	080017c0 	call	80017c <alt_irq_handler>

008000c4 <restore_sp_from_pxCurrentTCB>:
  8000c4:	06002074 	movhi	et,129

    .section .exceptions.irqreturn, "xa"
restore_sp_from_pxCurrentTCB:
	movia	et, pxCurrentTCB		# Load the address of the pxCurrentTCB pointer
  8000c8:	c62d4e04 	addi	et,et,-19144
	ldw		et, (et)				# Load the value of the pxCurrentTCB pointer
  8000cc:	c6000017 	ldw	et,0(et)
	ldw		sp, (et)				# Load the stack pointer with the top value of the TCB
  8000d0:	c6c00017 	ldw	sp,0(et)

008000d4 <restore_context>:

restore_context:
	ldw		ra, 0(sp)		# Restore the registers.
  8000d4:	dfc00017 	ldw	ra,0(sp)
							# Leave a gap for muldiv 0.
	ldw		at, 8(sp)
  8000d8:	d8400217 	ldw	at,8(sp)
	ldw		r2, 12(sp)
  8000dc:	d8800317 	ldw	r2,12(sp)
	ldw		r3, 16(sp)
  8000e0:	d8c00417 	ldw	r3,16(sp)
	ldw		r4, 20(sp)
  8000e4:	d9000517 	ldw	r4,20(sp)
	ldw		r5, 24(sp) 
  8000e8:	d9400617 	ldw	r5,24(sp)
	ldw		r6, 28(sp) 
  8000ec:	d9800717 	ldw	r6,28(sp)
	ldw		r7, 32(sp) 
  8000f0:	d9c00817 	ldw	r7,32(sp)
	ldw		r8, 36(sp) 
  8000f4:	da000917 	ldw	r8,36(sp)
	ldw		r9, 40(sp) 
  8000f8:	da400a17 	ldw	r9,40(sp)
	ldw		r10, 44(sp)
  8000fc:	da800b17 	ldw	r10,44(sp)
	ldw		r11, 48(sp)
  800100:	dac00c17 	ldw	r11,48(sp)
	ldw		r12, 52(sp)
  800104:	db000d17 	ldw	r12,52(sp)
	ldw		r13, 56(sp)
  800108:	db400e17 	ldw	r13,56(sp)
	ldw		r14, 60(sp)
  80010c:	db800f17 	ldw	r14,60(sp)
	ldw		r15, 64(sp)
  800110:	dbc01017 	ldw	r15,64(sp)
	ldw		et, 68(sp)		# Load the eStatus
  800114:	de001117 	ldw	et,68(sp)
	wrctl	estatus, et 	# Write the eStatus
  800118:	c001707a 	wrctl	estatus,et
	ldw		ea, 72(sp)		# Load the Program Counter
  80011c:	df401217 	ldw	ea,72(sp)
	ldw		r16, 76(sp)
  800120:	dc001317 	ldw	r16,76(sp)
	ldw		r17, 80(sp)
  800124:	dc401417 	ldw	r17,80(sp)
	ldw		r18, 84(sp)
  800128:	dc801517 	ldw	r18,84(sp)
	ldw		r19, 88(sp)
  80012c:	dcc01617 	ldw	r19,88(sp)
	ldw		r20, 92(sp)
  800130:	dd001717 	ldw	r20,92(sp)
	ldw		r21, 96(sp)
  800134:	dd401817 	ldw	r21,96(sp)
	ldw		r22, 100(sp)
  800138:	dd801917 	ldw	r22,100(sp)
	ldw		r23, 104(sp)
  80013c:	ddc01a17 	ldw	r23,104(sp)
	ldw		gp, 108(sp)
  800140:	de801b17 	ldw	gp,108(sp)
	ldw		fp, 112(sp)
  800144:	df001c17 	ldw	fp,112(sp)
	addi	sp,	sp, 116		# Release stack space
  800148:	dec01d04 	addi	sp,sp,116

    eret					# Return to address ea, loading eStatus into Status.
  80014c:	ef80083a 	eret

00800150 <soft_exceptions>:
   
	.section .exceptions.soft, "xa"
soft_exceptions:
	ldw		et, 0(ea)				# Load the instruction where the interrupt occured.
  800150:	ee000017 	ldw	et,0(ea)
	movhi	at, %hi(0x003B683A)		# Load the registers with the trap instruction code
  800154:	00400ef4 	movhi	at,59
	ori		at, at, %lo(0x003B683A)
  800158:	085a0e94 	ori	at,at,26682
   	cmpne	et, et, at				# Compare the trap instruction code to the last excuted instruction
  80015c:	c070c03a 	cmpne	et,et,at
  	beq		et, r0, call_scheduler	# its a trap so switchcontext
  800160:	c0000226 	beq	et,zero,80016c <call_scheduler>
  	break							# This is an un-implemented instruction or muldiv problem.
  800164:	003da03a 	break	0
  	br		restore_context			# its something else
  800168:	003fda06 	br	8000d4 <__alt_mem_onchip_memory2_0+0xff7800d4>

0080016c <call_scheduler>:

call_scheduler:
	addi	ea, ea, 4						# A trap was called, increment the program counter so it is not called again.
  80016c:	ef400104 	addi	ea,ea,4
	stw		ea, 72(sp)						# Save the new program counter to the context.
  800170:	df401215 	stw	ea,72(sp)
	call	vTaskSwitchContext				# Pick the next context.
  800174:	08044c80 	call	8044c8 <vTaskSwitchContext>
	br		restore_sp_from_pxCurrentTCB	# Switch in the task context and restore. 
  800178:	003fd206 	br	8000c4 <__alt_mem_onchip_memory2_0+0xff7800c4>

0080017c <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
  80017c:	defff904 	addi	sp,sp,-28
  800180:	dfc00615 	stw	ra,24(sp)
  800184:	df000515 	stw	fp,20(sp)
  800188:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
  80018c:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  800190:	0005313a 	rdctl	r2,ipending
  800194:	e0bffe15 	stw	r2,-8(fp)

  return active;
  800198:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
  80019c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
  8001a0:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
  8001a4:	00800044 	movi	r2,1
  8001a8:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
  8001ac:	e0fffb17 	ldw	r3,-20(fp)
  8001b0:	e0bffc17 	ldw	r2,-16(fp)
  8001b4:	1884703a 	and	r2,r3,r2
  8001b8:	10001526 	beq	r2,zero,800210 <alt_irq_handler+0x94>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
  8001bc:	00802174 	movhi	r2,133
  8001c0:	10a1be04 	addi	r2,r2,-30984
  8001c4:	e0fffd17 	ldw	r3,-12(fp)
  8001c8:	180690fa 	slli	r3,r3,3
  8001cc:	10c5883a 	add	r2,r2,r3
  8001d0:	10c00017 	ldw	r3,0(r2)
  8001d4:	00802174 	movhi	r2,133
  8001d8:	10a1be04 	addi	r2,r2,-30984
  8001dc:	e13ffd17 	ldw	r4,-12(fp)
  8001e0:	200890fa 	slli	r4,r4,3
  8001e4:	1105883a 	add	r2,r2,r4
  8001e8:	10800104 	addi	r2,r2,4
  8001ec:	10800017 	ldw	r2,0(r2)
  8001f0:	e17ffd17 	ldw	r5,-12(fp)
  8001f4:	1009883a 	mov	r4,r2
  8001f8:	183ee83a 	callr	r3
#endif
        break;
  8001fc:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  800200:	0005313a 	rdctl	r2,ipending
  800204:	e0bfff15 	stw	r2,-4(fp)

  return active;
  800208:	e0bfff17 	ldw	r2,-4(fp)
  80020c:	00000706 	br	80022c <alt_irq_handler+0xb0>
      }
      mask <<= 1;
  800210:	e0bffc17 	ldw	r2,-16(fp)
  800214:	1085883a 	add	r2,r2,r2
  800218:	e0bffc15 	stw	r2,-16(fp)
      i++;
  80021c:	e0bffd17 	ldw	r2,-12(fp)
  800220:	10800044 	addi	r2,r2,1
  800224:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
  800228:	003fe006 	br	8001ac <__alt_mem_onchip_memory2_0+0xff7801ac>

    active = alt_irq_pending ();
  80022c:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
  800230:	e0bffb17 	ldw	r2,-20(fp)
  800234:	103fda1e 	bne	r2,zero,8001a0 <__alt_mem_onchip_memory2_0+0xff7801a0>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
  800238:	0001883a 	nop
}
  80023c:	0001883a 	nop
  800240:	e037883a 	mov	sp,fp
  800244:	dfc00117 	ldw	ra,4(sp)
  800248:	df000017 	ldw	fp,0(sp)
  80024c:	dec00204 	addi	sp,sp,8
  800250:	f800283a 	ret

Disassembly of section .text:

00800254 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
  800254:	00820014 	movui	r2,2048
#endif

0:
    initd 0(r2)
  800258:	10000033 	initd	0(r2)
#ifdef NIOS2_ECC_PRESENT
    addi r2, r2, -4
#else
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
  80025c:	10bff804 	addi	r2,r2,-32
#endif
    bgt r2, zero, 0b
  800260:	00bffd16 	blt	zero,r2,800258 <__alt_mem_onchip_memory2_0+0xff780258>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
  800264:	06c04034 	movhi	sp,256
    ori sp, sp, %lo(__alt_stack_pointer)
  800268:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
  80026c:	06802074 	movhi	gp,129
    ori gp, gp, %lo(_gp)
  800270:	d6887c14 	ori	gp,gp,8688
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
  800274:	00802034 	movhi	r2,128
    ori r2, r2, %lo(__bss_start)
  800278:	10ad4c14 	ori	r2,r2,46384

    movhi r3, %hi(__bss_end)
  80027c:	00c02134 	movhi	r3,132
    ori r3, r3, %lo(__bss_end)
  800280:	18e1fe14 	ori	r3,r3,34808

    beq r2, r3, 1f
  800284:	10c00326 	beq	r2,r3,800294 <_start+0x40>

0:
    stw zero, (r2)
  800288:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
  80028c:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
  800290:	10fffd36 	bltu	r2,r3,800288 <__alt_mem_onchip_memory2_0+0xff780288>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
  800294:	08070e00 	call	8070e0 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
  800298:	08071640 	call	807164 <alt_main>

0080029c <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
  80029c:	003fff06 	br	80029c <__alt_mem_onchip_memory2_0+0xff78029c>

008002a0 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
  8002a0:	defffd04 	addi	sp,sp,-12
  8002a4:	dfc00215 	stw	ra,8(sp)
  8002a8:	df000115 	stw	fp,4(sp)
  8002ac:	df000104 	addi	fp,sp,4
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
  8002b0:	01000604 	movi	r4,24
  8002b4:	080101c0 	call	80101c <pvPortMalloc>
  8002b8:	e0bfff15 	stw	r2,-4(fp)

		if( pxEventBits != NULL )
  8002bc:	e0bfff17 	ldw	r2,-4(fp)
  8002c0:	10000626 	beq	r2,zero,8002dc <xEventGroupCreate+0x3c>
		{
			pxEventBits->uxEventBits = 0;
  8002c4:	e0bfff17 	ldw	r2,-4(fp)
  8002c8:	10000015 	stw	zero,0(r2)
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
  8002cc:	e0bfff17 	ldw	r2,-4(fp)
  8002d0:	10800104 	addi	r2,r2,4
  8002d4:	1009883a 	mov	r4,r2
  8002d8:	08009a00 	call	8009a0 <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
  8002dc:	e0bfff17 	ldw	r2,-4(fp)
	}
  8002e0:	e037883a 	mov	sp,fp
  8002e4:	dfc00117 	ldw	ra,4(sp)
  8002e8:	df000017 	ldw	fp,0(sp)
  8002ec:	dec00204 	addi	sp,sp,8
  8002f0:	f800283a 	ret

008002f4 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
  8002f4:	defff504 	addi	sp,sp,-44
  8002f8:	dfc00a15 	stw	ra,40(sp)
  8002fc:	df000915 	stw	fp,36(sp)
  800300:	df000904 	addi	fp,sp,36
  800304:	e13ffc15 	stw	r4,-16(fp)
  800308:	e17ffd15 	stw	r5,-12(fp)
  80030c:	e1bffe15 	stw	r6,-8(fp)
  800310:	e1ffff15 	stw	r7,-4(fp)
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
  800314:	e0bffc17 	ldw	r2,-16(fp)
  800318:	e0bff815 	stw	r2,-32(fp)
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
  80031c:	e03ff915 	stw	zero,-28(fp)
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
  800320:	08040940 	call	804094 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
  800324:	e0bff817 	ldw	r2,-32(fp)
  800328:	10800017 	ldw	r2,0(r2)
  80032c:	e0bffa15 	stw	r2,-24(fp)

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
  800330:	e17ffd17 	ldw	r5,-12(fp)
  800334:	e13ffc17 	ldw	r4,-16(fp)
  800338:	08006c40 	call	8006c4 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
  80033c:	e0fffa17 	ldw	r3,-24(fp)
  800340:	e0bffd17 	ldw	r2,-12(fp)
  800344:	1886b03a 	or	r3,r3,r2
  800348:	e0bffe17 	ldw	r2,-8(fp)
  80034c:	1886703a 	and	r3,r3,r2
  800350:	e0bffe17 	ldw	r2,-8(fp)
  800354:	18800d1e 	bne	r3,r2,80038c <xEventGroupSync+0x98>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
  800358:	e0fffa17 	ldw	r3,-24(fp)
  80035c:	e0bffd17 	ldw	r2,-12(fp)
  800360:	1884b03a 	or	r2,r3,r2
  800364:	e0bff715 	stw	r2,-36(fp)

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
  800368:	e0bff817 	ldw	r2,-32(fp)
  80036c:	10c00017 	ldw	r3,0(r2)
  800370:	e0bffe17 	ldw	r2,-8(fp)
  800374:	0084303a 	nor	r2,zero,r2
  800378:	1886703a 	and	r3,r3,r2
  80037c:	e0bff817 	ldw	r2,-32(fp)
  800380:	10c00015 	stw	r3,0(r2)

			xTicksToWait = 0;
  800384:	e03fff15 	stw	zero,-4(fp)
  800388:	00001106 	br	8003d0 <xEventGroupSync+0xdc>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
  80038c:	e0bfff17 	ldw	r2,-4(fp)
  800390:	10000a26 	beq	r2,zero,8003bc <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
  800394:	e0bff817 	ldw	r2,-32(fp)
  800398:	10c00104 	addi	r3,r2,4
  80039c:	e0bffe17 	ldw	r2,-8(fp)
  8003a0:	10814034 	orhi	r2,r2,1280
  8003a4:	e1bfff17 	ldw	r6,-4(fp)
  8003a8:	100b883a 	mov	r5,r2
  8003ac:	1809883a 	mov	r4,r3
  8003b0:	08045f00 	call	8045f0 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
  8003b4:	e03ff715 	stw	zero,-36(fp)
  8003b8:	00000506 	br	8003d0 <xEventGroupSync+0xdc>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
  8003bc:	e0bff817 	ldw	r2,-32(fp)
  8003c0:	10800017 	ldw	r2,0(r2)
  8003c4:	e0bff715 	stw	r2,-36(fp)
				xTimeoutOccurred = pdTRUE;
  8003c8:	00800044 	movi	r2,1
  8003cc:	e0bff915 	stw	r2,-28(fp)
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
  8003d0:	08040c00 	call	8040c0 <xTaskResumeAll>
  8003d4:	e0bffb15 	stw	r2,-20(fp)

	if( xTicksToWait != ( TickType_t ) 0 )
  8003d8:	e0bfff17 	ldw	r2,-4(fp)
  8003dc:	10002026 	beq	r2,zero,800460 <xEventGroupSync+0x16c>
	{
		if( xAlreadyYielded == pdFALSE )
  8003e0:	e0bffb17 	ldw	r2,-20(fp)
  8003e4:	1000011e 	bne	r2,zero,8003ec <xEventGroupSync+0xf8>
		{
			portYIELD_WITHIN_API();
  8003e8:	003b683a 	trap	0

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
  8003ec:	08050a80 	call	8050a8 <uxTaskResetEventItemValue>
  8003f0:	e0bff715 	stw	r2,-36(fp)

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
  8003f4:	e0bff717 	ldw	r2,-36(fp)
  8003f8:	1080802c 	andhi	r2,r2,512
  8003fc:	1000131e 	bne	r2,zero,80044c <xEventGroupSync+0x158>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
  800400:	0804ff40 	call	804ff4 <vTaskEnterCritical>
			{
				uxReturn = pxEventBits->uxEventBits;
  800404:	e0bff817 	ldw	r2,-32(fp)
  800408:	10800017 	ldw	r2,0(r2)
  80040c:	e0bff715 	stw	r2,-36(fp)

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
  800410:	e0fff717 	ldw	r3,-36(fp)
  800414:	e0bffe17 	ldw	r2,-8(fp)
  800418:	1886703a 	and	r3,r3,r2
  80041c:	e0bffe17 	ldw	r2,-8(fp)
  800420:	1880071e 	bne	r3,r2,800440 <xEventGroupSync+0x14c>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
  800424:	e0bff817 	ldw	r2,-32(fp)
  800428:	10c00017 	ldw	r3,0(r2)
  80042c:	e0bffe17 	ldw	r2,-8(fp)
  800430:	0084303a 	nor	r2,zero,r2
  800434:	1886703a 	and	r3,r3,r2
  800438:	e0bff817 	ldw	r2,-32(fp)
  80043c:	10c00015 	stw	r3,0(r2)
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
  800440:	08050480 	call	805048 <vTaskExitCritical>

			xTimeoutOccurred = pdTRUE;
  800444:	00800044 	movi	r2,1
  800448:	e0bff915 	stw	r2,-28(fp)
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
  80044c:	e0fff717 	ldw	r3,-36(fp)
  800450:	00804034 	movhi	r2,256
  800454:	10bfffc4 	addi	r2,r2,-1
  800458:	1884703a 	and	r2,r3,r2
  80045c:	e0bff715 	stw	r2,-36(fp)
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
  800460:	e0bff717 	ldw	r2,-36(fp)
}
  800464:	e037883a 	mov	sp,fp
  800468:	dfc00117 	ldw	ra,4(sp)
  80046c:	df000017 	ldw	fp,0(sp)
  800470:	dec00204 	addi	sp,sp,8
  800474:	f800283a 	ret

00800478 <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
  800478:	defff304 	addi	sp,sp,-52
  80047c:	dfc00c15 	stw	ra,48(sp)
  800480:	df000b15 	stw	fp,44(sp)
  800484:	df000b04 	addi	fp,sp,44
  800488:	e13ffc15 	stw	r4,-16(fp)
  80048c:	e17ffd15 	stw	r5,-12(fp)
  800490:	e1bffe15 	stw	r6,-8(fp)
  800494:	e1ffff15 	stw	r7,-4(fp)
EventGroup_t *pxEventBits = xEventGroup;
  800498:	e0bffc17 	ldw	r2,-16(fp)
  80049c:	e0bff715 	stw	r2,-36(fp)
EventBits_t uxReturn, uxControlBits = 0;
  8004a0:	e03ff615 	stw	zero,-40(fp)
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
  8004a4:	e03ff815 	stw	zero,-32(fp)
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
  8004a8:	08040940 	call	804094 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
  8004ac:	e0bff717 	ldw	r2,-36(fp)
  8004b0:	10800017 	ldw	r2,0(r2)
  8004b4:	e0bff915 	stw	r2,-28(fp)

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
  8004b8:	e1bfff17 	ldw	r6,-4(fp)
  8004bc:	e17ffd17 	ldw	r5,-12(fp)
  8004c0:	e13ff917 	ldw	r4,-28(fp)
  8004c4:	08009300 	call	800930 <prvTestWaitCondition>
  8004c8:	e0bffa15 	stw	r2,-24(fp)

		if( xWaitConditionMet != pdFALSE )
  8004cc:	e0bffa17 	ldw	r2,-24(fp)
  8004d0:	10000d26 	beq	r2,zero,800508 <xEventGroupWaitBits+0x90>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
  8004d4:	e0bff917 	ldw	r2,-28(fp)
  8004d8:	e0bff515 	stw	r2,-44(fp)
			xTicksToWait = ( TickType_t ) 0;
  8004dc:	e0000215 	stw	zero,8(fp)

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
  8004e0:	e0bffe17 	ldw	r2,-8(fp)
  8004e4:	10002226 	beq	r2,zero,800570 <xEventGroupWaitBits+0xf8>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
  8004e8:	e0bff717 	ldw	r2,-36(fp)
  8004ec:	10c00017 	ldw	r3,0(r2)
  8004f0:	e0bffd17 	ldw	r2,-12(fp)
  8004f4:	0084303a 	nor	r2,zero,r2
  8004f8:	1886703a 	and	r3,r3,r2
  8004fc:	e0bff717 	ldw	r2,-36(fp)
  800500:	10c00015 	stw	r3,0(r2)
  800504:	00001a06 	br	800570 <xEventGroupWaitBits+0xf8>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
  800508:	e0800217 	ldw	r2,8(fp)
  80050c:	1000051e 	bne	r2,zero,800524 <xEventGroupWaitBits+0xac>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
  800510:	e0bff917 	ldw	r2,-28(fp)
  800514:	e0bff515 	stw	r2,-44(fp)
			xTimeoutOccurred = pdTRUE;
  800518:	00800044 	movi	r2,1
  80051c:	e0bff815 	stw	r2,-32(fp)
  800520:	00001306 	br	800570 <xEventGroupWaitBits+0xf8>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
  800524:	e0bffe17 	ldw	r2,-8(fp)
  800528:	10000326 	beq	r2,zero,800538 <xEventGroupWaitBits+0xc0>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
  80052c:	e0bff617 	ldw	r2,-40(fp)
  800530:	10804034 	orhi	r2,r2,256
  800534:	e0bff615 	stw	r2,-40(fp)
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
  800538:	e0bfff17 	ldw	r2,-4(fp)
  80053c:	10000326 	beq	r2,zero,80054c <xEventGroupWaitBits+0xd4>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
  800540:	e0bff617 	ldw	r2,-40(fp)
  800544:	10810034 	orhi	r2,r2,1024
  800548:	e0bff615 	stw	r2,-40(fp)
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
  80054c:	e0bff717 	ldw	r2,-36(fp)
  800550:	11000104 	addi	r4,r2,4
  800554:	e0fffd17 	ldw	r3,-12(fp)
  800558:	e0bff617 	ldw	r2,-40(fp)
  80055c:	1884b03a 	or	r2,r3,r2
  800560:	e1800217 	ldw	r6,8(fp)
  800564:	100b883a 	mov	r5,r2
  800568:	08045f00 	call	8045f0 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
  80056c:	e03ff515 	stw	zero,-44(fp)

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
  800570:	08040c00 	call	8040c0 <xTaskResumeAll>
  800574:	e0bffb15 	stw	r2,-20(fp)

	if( xTicksToWait != ( TickType_t ) 0 )
  800578:	e0800217 	ldw	r2,8(fp)
  80057c:	10002226 	beq	r2,zero,800608 <xEventGroupWaitBits+0x190>
	{
		if( xAlreadyYielded == pdFALSE )
  800580:	e0bffb17 	ldw	r2,-20(fp)
  800584:	1000011e 	bne	r2,zero,80058c <xEventGroupWaitBits+0x114>
		{
			portYIELD_WITHIN_API();
  800588:	003b683a 	trap	0

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
  80058c:	08050a80 	call	8050a8 <uxTaskResetEventItemValue>
  800590:	e0bff515 	stw	r2,-44(fp)

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
  800594:	e0bff517 	ldw	r2,-44(fp)
  800598:	1080802c 	andhi	r2,r2,512
  80059c:	1000151e 	bne	r2,zero,8005f4 <xEventGroupWaitBits+0x17c>
		{
			taskENTER_CRITICAL();
  8005a0:	0804ff40 	call	804ff4 <vTaskEnterCritical>
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
  8005a4:	e0bff717 	ldw	r2,-36(fp)
  8005a8:	10800017 	ldw	r2,0(r2)
  8005ac:	e0bff515 	stw	r2,-44(fp)

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
  8005b0:	e1bfff17 	ldw	r6,-4(fp)
  8005b4:	e17ffd17 	ldw	r5,-12(fp)
  8005b8:	e13ff517 	ldw	r4,-44(fp)
  8005bc:	08009300 	call	800930 <prvTestWaitCondition>
  8005c0:	10000926 	beq	r2,zero,8005e8 <xEventGroupWaitBits+0x170>
				{
					if( xClearOnExit != pdFALSE )
  8005c4:	e0bffe17 	ldw	r2,-8(fp)
  8005c8:	10000726 	beq	r2,zero,8005e8 <xEventGroupWaitBits+0x170>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
  8005cc:	e0bff717 	ldw	r2,-36(fp)
  8005d0:	10c00017 	ldw	r3,0(r2)
  8005d4:	e0bffd17 	ldw	r2,-12(fp)
  8005d8:	0084303a 	nor	r2,zero,r2
  8005dc:	1886703a 	and	r3,r3,r2
  8005e0:	e0bff717 	ldw	r2,-36(fp)
  8005e4:	10c00015 	stw	r3,0(r2)
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
  8005e8:	00800044 	movi	r2,1
  8005ec:	e0bff815 	stw	r2,-32(fp)
			}
			taskEXIT_CRITICAL();
  8005f0:	08050480 	call	805048 <vTaskExitCritical>
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
  8005f4:	e0fff517 	ldw	r3,-44(fp)
  8005f8:	00804034 	movhi	r2,256
  8005fc:	10bfffc4 	addi	r2,r2,-1
  800600:	1884703a 	and	r2,r3,r2
  800604:	e0bff515 	stw	r2,-44(fp)
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
  800608:	e0bff517 	ldw	r2,-44(fp)
}
  80060c:	e037883a 	mov	sp,fp
  800610:	dfc00117 	ldw	ra,4(sp)
  800614:	df000017 	ldw	fp,0(sp)
  800618:	dec00204 	addi	sp,sp,8
  80061c:	f800283a 	ret

00800620 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
  800620:	defffa04 	addi	sp,sp,-24
  800624:	dfc00515 	stw	ra,20(sp)
  800628:	df000415 	stw	fp,16(sp)
  80062c:	df000404 	addi	fp,sp,16
  800630:	e13ffe15 	stw	r4,-8(fp)
  800634:	e17fff15 	stw	r5,-4(fp)
EventGroup_t *pxEventBits = xEventGroup;
  800638:	e0bffe17 	ldw	r2,-8(fp)
  80063c:	e0bffc15 	stw	r2,-16(fp)
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
  800640:	0804ff40 	call	804ff4 <vTaskEnterCritical>
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
  800644:	e0bffc17 	ldw	r2,-16(fp)
  800648:	10800017 	ldw	r2,0(r2)
  80064c:	e0bffd15 	stw	r2,-12(fp)

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
  800650:	e0bffc17 	ldw	r2,-16(fp)
  800654:	10c00017 	ldw	r3,0(r2)
  800658:	e0bfff17 	ldw	r2,-4(fp)
  80065c:	0084303a 	nor	r2,zero,r2
  800660:	1886703a 	and	r3,r3,r2
  800664:	e0bffc17 	ldw	r2,-16(fp)
  800668:	10c00015 	stw	r3,0(r2)
	}
	taskEXIT_CRITICAL();
  80066c:	08050480 	call	805048 <vTaskExitCritical>

	return uxReturn;
  800670:	e0bffd17 	ldw	r2,-12(fp)
}
  800674:	e037883a 	mov	sp,fp
  800678:	dfc00117 	ldw	ra,4(sp)
  80067c:	df000017 	ldw	fp,0(sp)
  800680:	dec00204 	addi	sp,sp,8
  800684:	f800283a 	ret

00800688 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
  800688:	defffb04 	addi	sp,sp,-20
  80068c:	df000415 	stw	fp,16(sp)
  800690:	df000404 	addi	fp,sp,16
  800694:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
  800698:	e0bfff17 	ldw	r2,-4(fp)
  80069c:	e0bffc15 	stw	r2,-16(fp)
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  8006a0:	e03ffd15 	stw	zero,-12(fp)
	{
		uxReturn = pxEventBits->uxEventBits;
  8006a4:	e0bffc17 	ldw	r2,-16(fp)
  8006a8:	10800017 	ldw	r2,0(r2)
  8006ac:	e0bffe15 	stw	r2,-8(fp)
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
  8006b0:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
  8006b4:	e037883a 	mov	sp,fp
  8006b8:	df000017 	ldw	fp,0(sp)
  8006bc:	dec00104 	addi	sp,sp,4
  8006c0:	f800283a 	ret

008006c4 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
  8006c4:	defff304 	addi	sp,sp,-52
  8006c8:	dfc00c15 	stw	ra,48(sp)
  8006cc:	df000b15 	stw	fp,44(sp)
  8006d0:	df000b04 	addi	fp,sp,44
  8006d4:	e13ffe15 	stw	r4,-8(fp)
  8006d8:	e17fff15 	stw	r5,-4(fp)
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
  8006dc:	e03ff615 	stw	zero,-40(fp)
EventGroup_t *pxEventBits = xEventGroup;
  8006e0:	e0bffe17 	ldw	r2,-8(fp)
  8006e4:	e0bff815 	stw	r2,-32(fp)
BaseType_t xMatchFound = pdFALSE;
  8006e8:	e03ff715 	stw	zero,-36(fp)
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
  8006ec:	e0bff817 	ldw	r2,-32(fp)
  8006f0:	10800104 	addi	r2,r2,4
  8006f4:	e0bff915 	stw	r2,-28(fp)
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  8006f8:	e0bff917 	ldw	r2,-28(fp)
  8006fc:	10800204 	addi	r2,r2,8
  800700:	e0bffa15 	stw	r2,-24(fp)
	vTaskSuspendAll();
  800704:	08040940 	call	804094 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
  800708:	e0bff917 	ldw	r2,-28(fp)
  80070c:	10800317 	ldw	r2,12(r2)
  800710:	e0bff515 	stw	r2,-44(fp)

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
  800714:	e0bff817 	ldw	r2,-32(fp)
  800718:	10c00017 	ldw	r3,0(r2)
  80071c:	e0bfff17 	ldw	r2,-4(fp)
  800720:	1886b03a 	or	r3,r3,r2
  800724:	e0bff817 	ldw	r2,-32(fp)
  800728:	10c00015 	stw	r3,0(r2)

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
  80072c:	00003306 	br	8007fc <xEventGroupSetBits+0x138>
		{
			pxNext = listGET_NEXT( pxListItem );
  800730:	e0bff517 	ldw	r2,-44(fp)
  800734:	10800117 	ldw	r2,4(r2)
  800738:	e0bffb15 	stw	r2,-20(fp)
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
  80073c:	e0bff517 	ldw	r2,-44(fp)
  800740:	10800017 	ldw	r2,0(r2)
  800744:	e0bffc15 	stw	r2,-16(fp)
			xMatchFound = pdFALSE;
  800748:	e03ff715 	stw	zero,-36(fp)

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
  80074c:	e0bffc17 	ldw	r2,-16(fp)
  800750:	10bfc02c 	andhi	r2,r2,65280
  800754:	e0bffd15 	stw	r2,-12(fp)
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
  800758:	e0fffc17 	ldw	r3,-16(fp)
  80075c:	00804034 	movhi	r2,256
  800760:	10bfffc4 	addi	r2,r2,-1
  800764:	1884703a 	and	r2,r3,r2
  800768:	e0bffc15 	stw	r2,-16(fp)

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
  80076c:	e0bffd17 	ldw	r2,-12(fp)
  800770:	1081002c 	andhi	r2,r2,1024
  800774:	1000081e 	bne	r2,zero,800798 <xEventGroupSetBits+0xd4>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
  800778:	e0bff817 	ldw	r2,-32(fp)
  80077c:	10c00017 	ldw	r3,0(r2)
  800780:	e0bffc17 	ldw	r2,-16(fp)
  800784:	1884703a 	and	r2,r3,r2
  800788:	10000b26 	beq	r2,zero,8007b8 <xEventGroupSetBits+0xf4>
				{
					xMatchFound = pdTRUE;
  80078c:	00800044 	movi	r2,1
  800790:	e0bff715 	stw	r2,-36(fp)
  800794:	00000806 	br	8007b8 <xEventGroupSetBits+0xf4>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
  800798:	e0bff817 	ldw	r2,-32(fp)
  80079c:	10c00017 	ldw	r3,0(r2)
  8007a0:	e0bffc17 	ldw	r2,-16(fp)
  8007a4:	1886703a 	and	r3,r3,r2
  8007a8:	e0bffc17 	ldw	r2,-16(fp)
  8007ac:	1880021e 	bne	r3,r2,8007b8 <xEventGroupSetBits+0xf4>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
  8007b0:	00800044 	movi	r2,1
  8007b4:	e0bff715 	stw	r2,-36(fp)
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
  8007b8:	e0bff717 	ldw	r2,-36(fp)
  8007bc:	10000d26 	beq	r2,zero,8007f4 <xEventGroupSetBits+0x130>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
  8007c0:	e0bffd17 	ldw	r2,-12(fp)
  8007c4:	1080402c 	andhi	r2,r2,256
  8007c8:	10000426 	beq	r2,zero,8007dc <xEventGroupSetBits+0x118>
				{
					uxBitsToClear |= uxBitsWaitedFor;
  8007cc:	e0fff617 	ldw	r3,-40(fp)
  8007d0:	e0bffc17 	ldw	r2,-16(fp)
  8007d4:	1884b03a 	or	r2,r3,r2
  8007d8:	e0bff615 	stw	r2,-40(fp)
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
  8007dc:	e0bff817 	ldw	r2,-32(fp)
  8007e0:	10800017 	ldw	r2,0(r2)
  8007e4:	10808034 	orhi	r2,r2,512
  8007e8:	100b883a 	mov	r5,r2
  8007ec:	e13ff517 	ldw	r4,-44(fp)
  8007f0:	08047480 	call	804748 <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
  8007f4:	e0bffb17 	ldw	r2,-20(fp)
  8007f8:	e0bff515 	stw	r2,-44(fp)

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
  8007fc:	e0fff517 	ldw	r3,-44(fp)
  800800:	e0bffa17 	ldw	r2,-24(fp)
  800804:	18bfca1e 	bne	r3,r2,800730 <__alt_mem_onchip_memory2_0+0xff780730>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
  800808:	e0bff817 	ldw	r2,-32(fp)
  80080c:	10c00017 	ldw	r3,0(r2)
  800810:	e0bff617 	ldw	r2,-40(fp)
  800814:	0084303a 	nor	r2,zero,r2
  800818:	1886703a 	and	r3,r3,r2
  80081c:	e0bff817 	ldw	r2,-32(fp)
  800820:	10c00015 	stw	r3,0(r2)
	}
	( void ) xTaskResumeAll();
  800824:	08040c00 	call	8040c0 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
  800828:	e0bff817 	ldw	r2,-32(fp)
  80082c:	10800017 	ldw	r2,0(r2)
}
  800830:	e037883a 	mov	sp,fp
  800834:	dfc00117 	ldw	ra,4(sp)
  800838:	df000017 	ldw	fp,0(sp)
  80083c:	dec00204 	addi	sp,sp,8
  800840:	f800283a 	ret

00800844 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
  800844:	defffb04 	addi	sp,sp,-20
  800848:	dfc00415 	stw	ra,16(sp)
  80084c:	df000315 	stw	fp,12(sp)
  800850:	df000304 	addi	fp,sp,12
  800854:	e13fff15 	stw	r4,-4(fp)
EventGroup_t *pxEventBits = xEventGroup;
  800858:	e0bfff17 	ldw	r2,-4(fp)
  80085c:	e0bffd15 	stw	r2,-12(fp)
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
  800860:	e0bffd17 	ldw	r2,-12(fp)
  800864:	10800104 	addi	r2,r2,4
  800868:	e0bffe15 	stw	r2,-8(fp)

	vTaskSuspendAll();
  80086c:	08040940 	call	804094 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
  800870:	00000506 	br	800888 <vEventGroupDelete+0x44>
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
  800874:	e0bffe17 	ldw	r2,-8(fp)
  800878:	10800317 	ldw	r2,12(r2)
  80087c:	01408034 	movhi	r5,512
  800880:	1009883a 	mov	r4,r2
  800884:	08047480 	call	804748 <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
  800888:	e0bffe17 	ldw	r2,-8(fp)
  80088c:	10800017 	ldw	r2,0(r2)
  800890:	103ff81e 	bne	r2,zero,800874 <__alt_mem_onchip_memory2_0+0xff780874>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
  800894:	e13ffd17 	ldw	r4,-12(fp)
  800898:	08010dc0 	call	8010dc <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
  80089c:	08040c00 	call	8040c0 <xTaskResumeAll>
}
  8008a0:	0001883a 	nop
  8008a4:	e037883a 	mov	sp,fp
  8008a8:	dfc00117 	ldw	ra,4(sp)
  8008ac:	df000017 	ldw	fp,0(sp)
  8008b0:	dec00204 	addi	sp,sp,8
  8008b4:	f800283a 	ret

008008b8 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
  8008b8:	defffc04 	addi	sp,sp,-16
  8008bc:	dfc00315 	stw	ra,12(sp)
  8008c0:	df000215 	stw	fp,8(sp)
  8008c4:	df000204 	addi	fp,sp,8
  8008c8:	e13ffe15 	stw	r4,-8(fp)
  8008cc:	e17fff15 	stw	r5,-4(fp)
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
  8008d0:	e17fff17 	ldw	r5,-4(fp)
  8008d4:	e13ffe17 	ldw	r4,-8(fp)
  8008d8:	08006c40 	call	8006c4 <xEventGroupSetBits>
}
  8008dc:	0001883a 	nop
  8008e0:	e037883a 	mov	sp,fp
  8008e4:	dfc00117 	ldw	ra,4(sp)
  8008e8:	df000017 	ldw	fp,0(sp)
  8008ec:	dec00204 	addi	sp,sp,8
  8008f0:	f800283a 	ret

008008f4 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
  8008f4:	defffc04 	addi	sp,sp,-16
  8008f8:	dfc00315 	stw	ra,12(sp)
  8008fc:	df000215 	stw	fp,8(sp)
  800900:	df000204 	addi	fp,sp,8
  800904:	e13ffe15 	stw	r4,-8(fp)
  800908:	e17fff15 	stw	r5,-4(fp)
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
  80090c:	e17fff17 	ldw	r5,-4(fp)
  800910:	e13ffe17 	ldw	r4,-8(fp)
  800914:	08006200 	call	800620 <xEventGroupClearBits>
}
  800918:	0001883a 	nop
  80091c:	e037883a 	mov	sp,fp
  800920:	dfc00117 	ldw	ra,4(sp)
  800924:	df000017 	ldw	fp,0(sp)
  800928:	dec00204 	addi	sp,sp,8
  80092c:	f800283a 	ret

00800930 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
  800930:	defffb04 	addi	sp,sp,-20
  800934:	df000415 	stw	fp,16(sp)
  800938:	df000404 	addi	fp,sp,16
  80093c:	e13ffd15 	stw	r4,-12(fp)
  800940:	e17ffe15 	stw	r5,-8(fp)
  800944:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xWaitConditionMet = pdFALSE;
  800948:	e03ffc15 	stw	zero,-16(fp)

	if( xWaitForAllBits == pdFALSE )
  80094c:	e0bfff17 	ldw	r2,-4(fp)
  800950:	1000071e 	bne	r2,zero,800970 <prvTestWaitCondition+0x40>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
  800954:	e0fffd17 	ldw	r3,-12(fp)
  800958:	e0bffe17 	ldw	r2,-8(fp)
  80095c:	1884703a 	and	r2,r3,r2
  800960:	10000a26 	beq	r2,zero,80098c <prvTestWaitCondition+0x5c>
		{
			xWaitConditionMet = pdTRUE;
  800964:	00800044 	movi	r2,1
  800968:	e0bffc15 	stw	r2,-16(fp)
  80096c:	00000706 	br	80098c <prvTestWaitCondition+0x5c>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
  800970:	e0fffd17 	ldw	r3,-12(fp)
  800974:	e0bffe17 	ldw	r2,-8(fp)
  800978:	1886703a 	and	r3,r3,r2
  80097c:	e0bffe17 	ldw	r2,-8(fp)
  800980:	1880021e 	bne	r3,r2,80098c <prvTestWaitCondition+0x5c>
		{
			xWaitConditionMet = pdTRUE;
  800984:	00800044 	movi	r2,1
  800988:	e0bffc15 	stw	r2,-16(fp)
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
  80098c:	e0bffc17 	ldw	r2,-16(fp)
}
  800990:	e037883a 	mov	sp,fp
  800994:	df000017 	ldw	fp,0(sp)
  800998:	dec00104 	addi	sp,sp,4
  80099c:	f800283a 	ret

008009a0 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
  8009a0:	defffe04 	addi	sp,sp,-8
  8009a4:	df000115 	stw	fp,4(sp)
  8009a8:	df000104 	addi	fp,sp,4
  8009ac:	e13fff15 	stw	r4,-4(fp)
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  8009b0:	e0bfff17 	ldw	r2,-4(fp)
  8009b4:	10c00204 	addi	r3,r2,8
  8009b8:	e0bfff17 	ldw	r2,-4(fp)
  8009bc:	10c00115 	stw	r3,4(r2)

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
  8009c0:	e0bfff17 	ldw	r2,-4(fp)
  8009c4:	00ffffc4 	movi	r3,-1
  8009c8:	10c00215 	stw	r3,8(r2)

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  8009cc:	e0bfff17 	ldw	r2,-4(fp)
  8009d0:	10c00204 	addi	r3,r2,8
  8009d4:	e0bfff17 	ldw	r2,-4(fp)
  8009d8:	10c00315 	stw	r3,12(r2)
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  8009dc:	e0bfff17 	ldw	r2,-4(fp)
  8009e0:	10c00204 	addi	r3,r2,8
  8009e4:	e0bfff17 	ldw	r2,-4(fp)
  8009e8:	10c00415 	stw	r3,16(r2)

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
  8009ec:	e0bfff17 	ldw	r2,-4(fp)
  8009f0:	10000015 	stw	zero,0(r2)

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
  8009f4:	0001883a 	nop
  8009f8:	e037883a 	mov	sp,fp
  8009fc:	df000017 	ldw	fp,0(sp)
  800a00:	dec00104 	addi	sp,sp,4
  800a04:	f800283a 	ret

00800a08 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
  800a08:	defffe04 	addi	sp,sp,-8
  800a0c:	df000115 	stw	fp,4(sp)
  800a10:	df000104 	addi	fp,sp,4
  800a14:	e13fff15 	stw	r4,-4(fp)
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
  800a18:	e0bfff17 	ldw	r2,-4(fp)
  800a1c:	10000415 	stw	zero,16(r2)

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
  800a20:	0001883a 	nop
  800a24:	e037883a 	mov	sp,fp
  800a28:	df000017 	ldw	fp,0(sp)
  800a2c:	dec00104 	addi	sp,sp,4
  800a30:	f800283a 	ret

00800a34 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
  800a34:	defffc04 	addi	sp,sp,-16
  800a38:	df000315 	stw	fp,12(sp)
  800a3c:	df000304 	addi	fp,sp,12
  800a40:	e13ffe15 	stw	r4,-8(fp)
  800a44:	e17fff15 	stw	r5,-4(fp)
ListItem_t * const pxIndex = pxList->pxIndex;
  800a48:	e0bffe17 	ldw	r2,-8(fp)
  800a4c:	10800117 	ldw	r2,4(r2)
  800a50:	e0bffd15 	stw	r2,-12(fp)
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
  800a54:	e0bfff17 	ldw	r2,-4(fp)
  800a58:	e0fffd17 	ldw	r3,-12(fp)
  800a5c:	10c00115 	stw	r3,4(r2)
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
  800a60:	e0bffd17 	ldw	r2,-12(fp)
  800a64:	10c00217 	ldw	r3,8(r2)
  800a68:	e0bfff17 	ldw	r2,-4(fp)
  800a6c:	10c00215 	stw	r3,8(r2)

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
  800a70:	e0bffd17 	ldw	r2,-12(fp)
  800a74:	10800217 	ldw	r2,8(r2)
  800a78:	e0ffff17 	ldw	r3,-4(fp)
  800a7c:	10c00115 	stw	r3,4(r2)
	pxIndex->pxPrevious = pxNewListItem;
  800a80:	e0bffd17 	ldw	r2,-12(fp)
  800a84:	e0ffff17 	ldw	r3,-4(fp)
  800a88:	10c00215 	stw	r3,8(r2)

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
  800a8c:	e0bfff17 	ldw	r2,-4(fp)
  800a90:	e0fffe17 	ldw	r3,-8(fp)
  800a94:	10c00415 	stw	r3,16(r2)

	( pxList->uxNumberOfItems )++;
  800a98:	e0bffe17 	ldw	r2,-8(fp)
  800a9c:	10800017 	ldw	r2,0(r2)
  800aa0:	10c00044 	addi	r3,r2,1
  800aa4:	e0bffe17 	ldw	r2,-8(fp)
  800aa8:	10c00015 	stw	r3,0(r2)
}
  800aac:	0001883a 	nop
  800ab0:	e037883a 	mov	sp,fp
  800ab4:	df000017 	ldw	fp,0(sp)
  800ab8:	dec00104 	addi	sp,sp,4
  800abc:	f800283a 	ret

00800ac0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
  800ac0:	defffb04 	addi	sp,sp,-20
  800ac4:	df000415 	stw	fp,16(sp)
  800ac8:	df000404 	addi	fp,sp,16
  800acc:	e13ffe15 	stw	r4,-8(fp)
  800ad0:	e17fff15 	stw	r5,-4(fp)
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
  800ad4:	e0bfff17 	ldw	r2,-4(fp)
  800ad8:	10800017 	ldw	r2,0(r2)
  800adc:	e0bffd15 	stw	r2,-12(fp)
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
  800ae0:	e0bffd17 	ldw	r2,-12(fp)
  800ae4:	10bfffd8 	cmpnei	r2,r2,-1
  800ae8:	1000041e 	bne	r2,zero,800afc <vListInsert+0x3c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
  800aec:	e0bffe17 	ldw	r2,-8(fp)
  800af0:	10800417 	ldw	r2,16(r2)
  800af4:	e0bffc15 	stw	r2,-16(fp)
  800af8:	00000c06 	br	800b2c <vListInsert+0x6c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
  800afc:	e0bffe17 	ldw	r2,-8(fp)
  800b00:	10800204 	addi	r2,r2,8
  800b04:	e0bffc15 	stw	r2,-16(fp)
  800b08:	00000306 	br	800b18 <vListInsert+0x58>
  800b0c:	e0bffc17 	ldw	r2,-16(fp)
  800b10:	10800117 	ldw	r2,4(r2)
  800b14:	e0bffc15 	stw	r2,-16(fp)
  800b18:	e0bffc17 	ldw	r2,-16(fp)
  800b1c:	10800117 	ldw	r2,4(r2)
  800b20:	10800017 	ldw	r2,0(r2)
  800b24:	e0fffd17 	ldw	r3,-12(fp)
  800b28:	18bff82e 	bgeu	r3,r2,800b0c <__alt_mem_onchip_memory2_0+0xff780b0c>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
  800b2c:	e0bffc17 	ldw	r2,-16(fp)
  800b30:	10c00117 	ldw	r3,4(r2)
  800b34:	e0bfff17 	ldw	r2,-4(fp)
  800b38:	10c00115 	stw	r3,4(r2)
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
  800b3c:	e0bfff17 	ldw	r2,-4(fp)
  800b40:	10800117 	ldw	r2,4(r2)
  800b44:	e0ffff17 	ldw	r3,-4(fp)
  800b48:	10c00215 	stw	r3,8(r2)
	pxNewListItem->pxPrevious = pxIterator;
  800b4c:	e0bfff17 	ldw	r2,-4(fp)
  800b50:	e0fffc17 	ldw	r3,-16(fp)
  800b54:	10c00215 	stw	r3,8(r2)
	pxIterator->pxNext = pxNewListItem;
  800b58:	e0bffc17 	ldw	r2,-16(fp)
  800b5c:	e0ffff17 	ldw	r3,-4(fp)
  800b60:	10c00115 	stw	r3,4(r2)

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
  800b64:	e0bfff17 	ldw	r2,-4(fp)
  800b68:	e0fffe17 	ldw	r3,-8(fp)
  800b6c:	10c00415 	stw	r3,16(r2)

	( pxList->uxNumberOfItems )++;
  800b70:	e0bffe17 	ldw	r2,-8(fp)
  800b74:	10800017 	ldw	r2,0(r2)
  800b78:	10c00044 	addi	r3,r2,1
  800b7c:	e0bffe17 	ldw	r2,-8(fp)
  800b80:	10c00015 	stw	r3,0(r2)
}
  800b84:	0001883a 	nop
  800b88:	e037883a 	mov	sp,fp
  800b8c:	df000017 	ldw	fp,0(sp)
  800b90:	dec00104 	addi	sp,sp,4
  800b94:	f800283a 	ret

00800b98 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
  800b98:	defffd04 	addi	sp,sp,-12
  800b9c:	df000215 	stw	fp,8(sp)
  800ba0:	df000204 	addi	fp,sp,8
  800ba4:	e13fff15 	stw	r4,-4(fp)
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
  800ba8:	e0bfff17 	ldw	r2,-4(fp)
  800bac:	10800417 	ldw	r2,16(r2)
  800bb0:	e0bffe15 	stw	r2,-8(fp)

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
  800bb4:	e0bfff17 	ldw	r2,-4(fp)
  800bb8:	10800117 	ldw	r2,4(r2)
  800bbc:	e0ffff17 	ldw	r3,-4(fp)
  800bc0:	18c00217 	ldw	r3,8(r3)
  800bc4:	10c00215 	stw	r3,8(r2)
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
  800bc8:	e0bfff17 	ldw	r2,-4(fp)
  800bcc:	10800217 	ldw	r2,8(r2)
  800bd0:	e0ffff17 	ldw	r3,-4(fp)
  800bd4:	18c00117 	ldw	r3,4(r3)
  800bd8:	10c00115 	stw	r3,4(r2)

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
  800bdc:	e0bffe17 	ldw	r2,-8(fp)
  800be0:	10c00117 	ldw	r3,4(r2)
  800be4:	e0bfff17 	ldw	r2,-4(fp)
  800be8:	1880041e 	bne	r3,r2,800bfc <uxListRemove+0x64>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
  800bec:	e0bfff17 	ldw	r2,-4(fp)
  800bf0:	10c00217 	ldw	r3,8(r2)
  800bf4:	e0bffe17 	ldw	r2,-8(fp)
  800bf8:	10c00115 	stw	r3,4(r2)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
  800bfc:	e0bfff17 	ldw	r2,-4(fp)
  800c00:	10000415 	stw	zero,16(r2)
	( pxList->uxNumberOfItems )--;
  800c04:	e0bffe17 	ldw	r2,-8(fp)
  800c08:	10800017 	ldw	r2,0(r2)
  800c0c:	10ffffc4 	addi	r3,r2,-1
  800c10:	e0bffe17 	ldw	r2,-8(fp)
  800c14:	10c00015 	stw	r3,0(r2)

	return pxList->uxNumberOfItems;
  800c18:	e0bffe17 	ldw	r2,-8(fp)
  800c1c:	10800017 	ldw	r2,0(r2)
}
  800c20:	e037883a 	mov	sp,fp
  800c24:	df000017 	ldw	fp,0(sp)
  800c28:	dec00104 	addi	sp,sp,4
  800c2c:	f800283a 	ret

00800c30 <prvReadGp>:
void vPortSysTickHandler( void * context, alt_u32 id );

/*-----------------------------------------------------------*/

static void prvReadGp( uint32_t *ulValue )
{
  800c30:	defffe04 	addi	sp,sp,-8
  800c34:	df000115 	stw	fp,4(sp)
  800c38:	df000104 	addi	fp,sp,4
  800c3c:	e13fff15 	stw	r4,-4(fp)
	asm( "stw gp, (%0)" :: "r"(ulValue) );
  800c40:	e0bfff17 	ldw	r2,-4(fp)
  800c44:	16800015 	stw	gp,0(r2)
}
  800c48:	0001883a 	nop
  800c4c:	e037883a 	mov	sp,fp
  800c50:	df000017 	ldw	fp,0(sp)
  800c54:	dec00104 	addi	sp,sp,4
  800c58:	f800283a 	ret

00800c5c <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{    
  800c5c:	defff904 	addi	sp,sp,-28
  800c60:	dfc00615 	stw	ra,24(sp)
  800c64:	df000515 	stw	fp,20(sp)
  800c68:	df000504 	addi	fp,sp,20
  800c6c:	e13ffd15 	stw	r4,-12(fp)
  800c70:	e17ffe15 	stw	r5,-8(fp)
  800c74:	e1bfff15 	stw	r6,-4(fp)
StackType_t *pxFramePointer = pxTopOfStack - 1;
  800c78:	e0bffd17 	ldw	r2,-12(fp)
  800c7c:	10bfff04 	addi	r2,r2,-4
  800c80:	e0bffb15 	stw	r2,-20(fp)
StackType_t xGlobalPointer;

    prvReadGp( &xGlobalPointer ); 
  800c84:	e0bffc04 	addi	r2,fp,-16
  800c88:	1009883a 	mov	r4,r2
  800c8c:	0800c300 	call	800c30 <prvReadGp>

    /* End of stack marker. */
    *pxTopOfStack = 0xdeadbeef;
  800c90:	e0fffd17 	ldw	r3,-12(fp)
  800c94:	00b7abb4 	movhi	r2,57006
  800c98:	10afbbc4 	addi	r2,r2,-16657
  800c9c:	18800015 	stw	r2,0(r3)
    pxTopOfStack--;
  800ca0:	e0bffd17 	ldw	r2,-12(fp)
  800ca4:	10bfff04 	addi	r2,r2,-4
  800ca8:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = ( StackType_t ) pxFramePointer; 
  800cac:	e0fffb17 	ldw	r3,-20(fp)
  800cb0:	e0bffd17 	ldw	r2,-12(fp)
  800cb4:	10c00015 	stw	r3,0(r2)
    pxTopOfStack--;
  800cb8:	e0bffd17 	ldw	r2,-12(fp)
  800cbc:	10bfff04 	addi	r2,r2,-4
  800cc0:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = xGlobalPointer; 
  800cc4:	e0fffc17 	ldw	r3,-16(fp)
  800cc8:	e0bffd17 	ldw	r2,-12(fp)
  800ccc:	10c00015 	stw	r3,0(r2)
    
    /* Space for R23 to R16. */
    pxTopOfStack -= 9;
  800cd0:	e0bffd17 	ldw	r2,-12(fp)
  800cd4:	10bff704 	addi	r2,r2,-36
  800cd8:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = ( StackType_t ) pxCode; 
  800cdc:	e0fffe17 	ldw	r3,-8(fp)
  800ce0:	e0bffd17 	ldw	r2,-12(fp)
  800ce4:	10c00015 	stw	r3,0(r2)
    pxTopOfStack--;
  800ce8:	e0bffd17 	ldw	r2,-12(fp)
  800cec:	10bfff04 	addi	r2,r2,-4
  800cf0:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = portINITIAL_ESTATUS; 
  800cf4:	e0bffd17 	ldw	r2,-12(fp)
  800cf8:	00c00044 	movi	r3,1
  800cfc:	10c00015 	stw	r3,0(r2)

    /* Space for R15 to R5. */    
    pxTopOfStack -= 12;
  800d00:	e0bffd17 	ldw	r2,-12(fp)
  800d04:	10bff404 	addi	r2,r2,-48
  800d08:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = ( StackType_t ) pvParameters; 
  800d0c:	e0ffff17 	ldw	r3,-4(fp)
  800d10:	e0bffd17 	ldw	r2,-12(fp)
  800d14:	10c00015 	stw	r3,0(r2)

    /* Space for R3 to R1, muldiv and RA. */
    pxTopOfStack -= 5;
  800d18:	e0bffd17 	ldw	r2,-12(fp)
  800d1c:	10bffb04 	addi	r2,r2,-20
  800d20:	e0bffd15 	stw	r2,-12(fp)
    
    return pxTopOfStack;
  800d24:	e0bffd17 	ldw	r2,-12(fp)
}
  800d28:	e037883a 	mov	sp,fp
  800d2c:	dfc00117 	ldw	ra,4(sp)
  800d30:	df000017 	ldw	fp,0(sp)
  800d34:	dec00204 	addi	sp,sp,8
  800d38:	f800283a 	ret

00800d3c <xPortStartScheduler>:

/* 
 * See header file for description. 
 */
BaseType_t xPortStartScheduler( void )
{
  800d3c:	defffe04 	addi	sp,sp,-8
  800d40:	dfc00115 	stw	ra,4(sp)
  800d44:	df000015 	stw	fp,0(sp)
  800d48:	d839883a 	mov	fp,sp
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
  800d4c:	0800d940 	call	800d94 <prvSetupTimerInterrupt>
  800d50:	00802034 	movhi	r2,128
	
	/* Start the first task. */
    asm volatile (  " movia r2, restore_sp_from_pxCurrentTCB        \n"
  800d54:	10803104 	addi	r2,r2,196
  800d58:	1000683a 	jmp	r2
                    " jmp r2                                          " );

	/* Should not get here! */
	return 0;
  800d5c:	0005883a 	mov	r2,zero
}
  800d60:	e037883a 	mov	sp,fp
  800d64:	dfc00117 	ldw	ra,4(sp)
  800d68:	df000017 	ldw	fp,0(sp)
  800d6c:	dec00204 	addi	sp,sp,8
  800d70:	f800283a 	ret

00800d74 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
  800d74:	deffff04 	addi	sp,sp,-4
  800d78:	df000015 	stw	fp,0(sp)
  800d7c:	d839883a 	mov	fp,sp
	/* It is unlikely that the NIOS2 port will require this function as there
	is nothing to return to.  */
}
  800d80:	0001883a 	nop
  800d84:	e037883a 	mov	sp,fp
  800d88:	df000017 	ldw	fp,0(sp)
  800d8c:	dec00104 	addi	sp,sp,4
  800d90:	f800283a 	ret

00800d94 <prvSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
  800d94:	defffe04 	addi	sp,sp,-8
  800d98:	dfc00115 	stw	ra,4(sp)
  800d9c:	df000015 	stw	fp,0(sp)
  800da0:	d839883a 	mov	fp,sp
	/* Try to register the interrupt handler. */
	if ( -EINVAL == alt_irq_register( TIMER_0_IRQ, 0x0, vPortSysTickHandler ) )
  800da4:	01802034 	movhi	r6,128
  800da8:	31838c04 	addi	r6,r6,3632
  800dac:	000b883a 	mov	r5,zero
  800db0:	01000044 	movi	r4,1
  800db4:	0800e7c0 	call	800e7c <alt_irq_register>
  800db8:	10bffa98 	cmpnei	r2,r2,-22
  800dbc:	1000021e 	bne	r2,zero,800dc8 <prvSetupTimerInterrupt+0x34>
	{ 
		/* Failed to install the Interrupt Handler. */
		asm( "break" );
  800dc0:	003da03a 	break	0
  800dc4:	00001006 	br	800e08 <prvSetupTimerInterrupt+0x74>
	}
	else
	{
		/* Configure SysTick to interrupt at the requested rate. */
		IOWR_ALTERA_AVALON_TIMER_CONTROL( TIMER_0_BASE, ALTERA_AVALON_TIMER_CONTROL_STOP_MSK );
  800dc8:	00c00204 	movi	r3,8
  800dcc:	00804434 	movhi	r2,272
  800dd0:	10840104 	addi	r2,r2,4100
  800dd4:	10c00035 	stwio	r3,0(r2)
		IOWR_ALTERA_AVALON_TIMER_PERIODL( TIMER_0_BASE, ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) & 0xFFFF );
  800dd8:	00f0d414 	movui	r3,50000
  800ddc:	00804434 	movhi	r2,272
  800de0:	10840204 	addi	r2,r2,4104
  800de4:	10c00035 	stwio	r3,0(r2)
		IOWR_ALTERA_AVALON_TIMER_PERIODH( TIMER_0_BASE, ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) >> 16 );
  800de8:	0007883a 	mov	r3,zero
  800dec:	00804434 	movhi	r2,272
  800df0:	10840304 	addi	r2,r2,4108
  800df4:	10c00035 	stwio	r3,0(r2)
		IOWR_ALTERA_AVALON_TIMER_CONTROL( TIMER_0_BASE, ALTERA_AVALON_TIMER_CONTROL_CONT_MSK | ALTERA_AVALON_TIMER_CONTROL_START_MSK | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK );	
  800df8:	00c001c4 	movi	r3,7
  800dfc:	00804434 	movhi	r2,272
  800e00:	10840104 	addi	r2,r2,4100
  800e04:	10c00035 	stwio	r3,0(r2)
	} 

	/* Clear any already pending interrupts generated by the Timer. */
	IOWR_ALTERA_AVALON_TIMER_STATUS( TIMER_0_BASE, ~ALTERA_AVALON_TIMER_STATUS_TO_MSK );
  800e08:	00ffff84 	movi	r3,-2
  800e0c:	00804434 	movhi	r2,272
  800e10:	10840004 	addi	r2,r2,4096
  800e14:	10c00035 	stwio	r3,0(r2)
}
  800e18:	0001883a 	nop
  800e1c:	e037883a 	mov	sp,fp
  800e20:	dfc00117 	ldw	ra,4(sp)
  800e24:	df000017 	ldw	fp,0(sp)
  800e28:	dec00204 	addi	sp,sp,8
  800e2c:	f800283a 	ret

00800e30 <vPortSysTickHandler>:
/*-----------------------------------------------------------*/

void vPortSysTickHandler( void * context, alt_u32 id )
{
  800e30:	defffc04 	addi	sp,sp,-16
  800e34:	dfc00315 	stw	ra,12(sp)
  800e38:	df000215 	stw	fp,8(sp)
  800e3c:	df000204 	addi	fp,sp,8
  800e40:	e13ffe15 	stw	r4,-8(fp)
  800e44:	e17fff15 	stw	r5,-4(fp)
	/* Increment the kernel tick. */
	if( xTaskIncrementTick() != pdFALSE )
  800e48:	08043180 	call	804318 <xTaskIncrementTick>
  800e4c:	10000126 	beq	r2,zero,800e54 <vPortSysTickHandler+0x24>
	{
        vTaskSwitchContext();
  800e50:	08044c80 	call	8044c8 <vTaskSwitchContext>
	}
		
	/* Clear the interrupt. */
	IOWR_ALTERA_AVALON_TIMER_STATUS( TIMER_0_BASE, ~ALTERA_AVALON_TIMER_STATUS_TO_MSK );
  800e54:	00ffff84 	movi	r3,-2
  800e58:	00804434 	movhi	r2,272
  800e5c:	10840004 	addi	r2,r2,4096
  800e60:	10c00035 	stwio	r3,0(r2)
}
  800e64:	0001883a 	nop
  800e68:	e037883a 	mov	sp,fp
  800e6c:	dfc00117 	ldw	ra,4(sp)
  800e70:	df000017 	ldw	fp,0(sp)
  800e74:	dec00204 	addi	sp,sp,8
  800e78:	f800283a 	ret

00800e7c <alt_irq_register>:
 * when it is registered. Interrupts should only be enabled after the FreeRTOS.org
 * kernel has its scheduler started so that contexts are saved and switched 
 * correctly.
 */
int alt_irq_register( alt_u32 id, void* context, void (*handler)(void*, alt_u32) )
{
  800e7c:	defff104 	addi	sp,sp,-60
  800e80:	df000e15 	stw	fp,56(sp)
  800e84:	df000e04 	addi	fp,sp,56
  800e88:	e13ffd15 	stw	r4,-12(fp)
  800e8c:	e17ffe15 	stw	r5,-8(fp)
  800e90:	e1bfff15 	stw	r6,-4(fp)
	int rc = -EINVAL;  
  800e94:	00bffa84 	movi	r2,-22
  800e98:	e0bff215 	stw	r2,-56(fp)
	alt_irq_context status;

	if (id < ALT_NIRQ)
  800e9c:	e0bffd17 	ldw	r2,-12(fp)
  800ea0:	10800828 	cmpgeui	r2,r2,32
  800ea4:	1000581e 	bne	r2,zero,801008 <alt_irq_register+0x18c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  800ea8:	0005303a 	rdctl	r2,status
  800eac:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  800eb0:	e0fff617 	ldw	r3,-40(fp)
  800eb4:	00bfff84 	movi	r2,-2
  800eb8:	1884703a 	and	r2,r3,r2
  800ebc:	1001703a 	wrctl	status,r2
  
  return context;
  800ec0:	e0bff617 	ldw	r2,-40(fp)
		 * interrupts are disabled while the handler tables are updated to ensure
		 * that an interrupt doesn't occur while the tables are in an inconsistent
		 * state.
		 */
	
		status = alt_irq_disable_all ();
  800ec4:	e0bff415 	stw	r2,-48(fp)
	
		alt_irq[id].handler = handler;
  800ec8:	00802174 	movhi	r2,133
  800ecc:	10a1be04 	addi	r2,r2,-30984
  800ed0:	e0fffd17 	ldw	r3,-12(fp)
  800ed4:	180690fa 	slli	r3,r3,3
  800ed8:	10c5883a 	add	r2,r2,r3
  800edc:	e0ffff17 	ldw	r3,-4(fp)
  800ee0:	10c00015 	stw	r3,0(r2)
		alt_irq[id].context = context;
  800ee4:	00802174 	movhi	r2,133
  800ee8:	10a1be04 	addi	r2,r2,-30984
  800eec:	e0fffd17 	ldw	r3,-12(fp)
  800ef0:	180690fa 	slli	r3,r3,3
  800ef4:	10c5883a 	add	r2,r2,r3
  800ef8:	10800104 	addi	r2,r2,4
  800efc:	e0fffe17 	ldw	r3,-8(fp)
  800f00:	10c00015 	stw	r3,0(r2)
	
		rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
  800f04:	e0bfff17 	ldw	r2,-4(fp)
  800f08:	10001f26 	beq	r2,zero,800f88 <alt_irq_register+0x10c>
  800f0c:	e0bffd17 	ldw	r2,-12(fp)
  800f10:	e0bff315 	stw	r2,-52(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  800f14:	0005303a 	rdctl	r2,status
  800f18:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  800f1c:	e0fff717 	ldw	r3,-36(fp)
  800f20:	00bfff84 	movi	r2,-2
  800f24:	1884703a 	and	r2,r3,r2
  800f28:	1001703a 	wrctl	status,r2
  
  return context;
  800f2c:	e0bff717 	ldw	r2,-36(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  800f30:	e0bff815 	stw	r2,-32(fp)

  alt_irq_active |= (1 << id);
  800f34:	00c00044 	movi	r3,1
  800f38:	e0bff317 	ldw	r2,-52(fp)
  800f3c:	1884983a 	sll	r2,r3,r2
  800f40:	1007883a 	mov	r3,r2
  800f44:	00802074 	movhi	r2,129
  800f48:	10ad6204 	addi	r2,r2,-19064
  800f4c:	10800017 	ldw	r2,0(r2)
  800f50:	1886b03a 	or	r3,r3,r2
  800f54:	00802074 	movhi	r2,129
  800f58:	10ad6204 	addi	r2,r2,-19064
  800f5c:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  800f60:	00802074 	movhi	r2,129
  800f64:	10ad6204 	addi	r2,r2,-19064
  800f68:	10800017 	ldw	r2,0(r2)
  800f6c:	100170fa 	wrctl	ienable,r2
  800f70:	e0bff817 	ldw	r2,-32(fp)
  800f74:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  800f78:	e0bff917 	ldw	r2,-28(fp)
  800f7c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  800f80:	0005883a 	mov	r2,zero
  800f84:	00001f06 	br	801004 <alt_irq_register+0x188>
  800f88:	e0bffd17 	ldw	r2,-12(fp)
  800f8c:	e0bff515 	stw	r2,-44(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  800f90:	0005303a 	rdctl	r2,status
  800f94:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  800f98:	e0fffa17 	ldw	r3,-24(fp)
  800f9c:	00bfff84 	movi	r2,-2
  800fa0:	1884703a 	and	r2,r3,r2
  800fa4:	1001703a 	wrctl	status,r2
  
  return context;
  800fa8:	e0bffa17 	ldw	r2,-24(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  800fac:	e0bffb15 	stw	r2,-20(fp)

  alt_irq_active &= ~(1 << id);
  800fb0:	00c00044 	movi	r3,1
  800fb4:	e0bff517 	ldw	r2,-44(fp)
  800fb8:	1884983a 	sll	r2,r3,r2
  800fbc:	0084303a 	nor	r2,zero,r2
  800fc0:	1007883a 	mov	r3,r2
  800fc4:	00802074 	movhi	r2,129
  800fc8:	10ad6204 	addi	r2,r2,-19064
  800fcc:	10800017 	ldw	r2,0(r2)
  800fd0:	1886703a 	and	r3,r3,r2
  800fd4:	00802074 	movhi	r2,129
  800fd8:	10ad6204 	addi	r2,r2,-19064
  800fdc:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  800fe0:	00802074 	movhi	r2,129
  800fe4:	10ad6204 	addi	r2,r2,-19064
  800fe8:	10800017 	ldw	r2,0(r2)
  800fec:	100170fa 	wrctl	ienable,r2
  800ff0:	e0bffb17 	ldw	r2,-20(fp)
  800ff4:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  800ff8:	e0bffc17 	ldw	r2,-16(fp)
  800ffc:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  801000:	0005883a 	mov	r2,zero
  801004:	e0bff215 	stw	r2,-56(fp)
	
		/* alt_irq_enable_all(status); This line is removed to prevent the interrupt from being immediately enabled. */
	}
    
	return rc; 
  801008:	e0bff217 	ldw	r2,-56(fp)
}
  80100c:	e037883a 	mov	sp,fp
  801010:	df000017 	ldw	fp,0(sp)
  801014:	dec00104 	addi	sp,sp,4
  801018:	f800283a 	ret

0080101c <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
  80101c:	defffc04 	addi	sp,sp,-16
  801020:	dfc00315 	stw	ra,12(sp)
  801024:	df000215 	stw	fp,8(sp)
  801028:	df000204 	addi	fp,sp,8
  80102c:	e13fff15 	stw	r4,-4(fp)
void *pvReturn = NULL;
  801030:	e03ffe15 	stw	zero,-8(fp)
static uint8_t *pucAlignedHeap = NULL;

	/* Ensure that blocks are always aligned to the required number of bytes. */
	#if( portBYTE_ALIGNMENT != 1 )
	{
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
  801034:	e0bfff17 	ldw	r2,-4(fp)
  801038:	108000cc 	andi	r2,r2,3
  80103c:	10000526 	beq	r2,zero,801054 <pvPortMalloc+0x38>
		{
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
  801040:	e0ffff17 	ldw	r3,-4(fp)
  801044:	00bfff04 	movi	r2,-4
  801048:	1884703a 	and	r2,r3,r2
  80104c:	10800104 	addi	r2,r2,4
  801050:	e0bfff15 	stw	r2,-4(fp)
		}
	}
	#endif

	vTaskSuspendAll();
  801054:	08040940 	call	804094 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
  801058:	d0a4d117 	ldw	r2,-27836(gp)
  80105c:	1000051e 	bne	r2,zero,801074 <pvPortMalloc+0x58>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
  801060:	00802074 	movhi	r2,129
  801064:	10ad6904 	addi	r2,r2,-19036
  801068:	00ffff04 	movi	r3,-4
  80106c:	10c4703a 	and	r2,r2,r3
  801070:	d0a4d115 	stw	r2,-27836(gp)
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
  801074:	d0e4d017 	ldw	r3,-27840(gp)
  801078:	e0bfff17 	ldw	r2,-4(fp)
  80107c:	1887883a 	add	r3,r3,r2
  801080:	00800134 	movhi	r2,4
  801084:	10b422c4 	addi	r2,r2,-12149
  801088:	10c00d36 	bltu	r2,r3,8010c0 <pvPortMalloc+0xa4>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
  80108c:	d0e4d017 	ldw	r3,-27840(gp)
  801090:	e0bfff17 	ldw	r2,-4(fp)
  801094:	1885883a 	add	r2,r3,r2
  801098:	d0e4d017 	ldw	r3,-27840(gp)
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
  80109c:	1880082e 	bgeu	r3,r2,8010c0 <pvPortMalloc+0xa4>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
  8010a0:	d0e4d117 	ldw	r3,-27836(gp)
  8010a4:	d0a4d017 	ldw	r2,-27840(gp)
  8010a8:	1885883a 	add	r2,r3,r2
  8010ac:	e0bffe15 	stw	r2,-8(fp)
			xNextFreeByte += xWantedSize;
  8010b0:	d0e4d017 	ldw	r3,-27840(gp)
  8010b4:	e0bfff17 	ldw	r2,-4(fp)
  8010b8:	1885883a 	add	r2,r3,r2
  8010bc:	d0a4d015 	stw	r2,-27840(gp)
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
  8010c0:	08040c00 	call	8040c0 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
  8010c4:	e0bffe17 	ldw	r2,-8(fp)
}
  8010c8:	e037883a 	mov	sp,fp
  8010cc:	dfc00117 	ldw	ra,4(sp)
  8010d0:	df000017 	ldw	fp,0(sp)
  8010d4:	dec00204 	addi	sp,sp,8
  8010d8:	f800283a 	ret

008010dc <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
  8010dc:	defffe04 	addi	sp,sp,-8
  8010e0:	df000115 	stw	fp,4(sp)
  8010e4:	df000104 	addi	fp,sp,4
  8010e8:	e13fff15 	stw	r4,-4(fp)
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
  8010ec:	0001883a 	nop
  8010f0:	e037883a 	mov	sp,fp
  8010f4:	df000017 	ldw	fp,0(sp)
  8010f8:	dec00104 	addi	sp,sp,4
  8010fc:	f800283a 	ret

00801100 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
  801100:	deffff04 	addi	sp,sp,-4
  801104:	df000015 	stw	fp,0(sp)
  801108:	d839883a 	mov	fp,sp
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
  80110c:	d024d015 	stw	zero,-27840(gp)
}
  801110:	0001883a 	nop
  801114:	e037883a 	mov	sp,fp
  801118:	df000017 	ldw	fp,0(sp)
  80111c:	dec00104 	addi	sp,sp,4
  801120:	f800283a 	ret

00801124 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
  801124:	deffff04 	addi	sp,sp,-4
  801128:	df000015 	stw	fp,0(sp)
  80112c:	d839883a 	mov	fp,sp
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
  801130:	d0e4d017 	ldw	r3,-27840(gp)
  801134:	00800134 	movhi	r2,4
  801138:	10b42304 	addi	r2,r2,-12148
  80113c:	10c5c83a 	sub	r2,r2,r3
}
  801140:	e037883a 	mov	sp,fp
  801144:	df000017 	ldw	fp,0(sp)
  801148:	dec00104 	addi	sp,sp,4
  80114c:	f800283a 	ret

00801150 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
  801150:	defffb04 	addi	sp,sp,-20
  801154:	dfc00415 	stw	ra,16(sp)
  801158:	df000315 	stw	fp,12(sp)
  80115c:	df000304 	addi	fp,sp,12
  801160:	e13ffe15 	stw	r4,-8(fp)
  801164:	e17fff15 	stw	r5,-4(fp)
Queue_t * const pxQueue = xQueue;
  801168:	e0bffe17 	ldw	r2,-8(fp)
  80116c:	e0bffd15 	stw	r2,-12(fp)

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
  801170:	0804ff40 	call	804ff4 <vTaskEnterCritical>
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
  801174:	e0bffd17 	ldw	r2,-12(fp)
  801178:	10c00017 	ldw	r3,0(r2)
  80117c:	e0bffd17 	ldw	r2,-12(fp)
  801180:	11000f17 	ldw	r4,60(r2)
  801184:	e0bffd17 	ldw	r2,-12(fp)
  801188:	10801017 	ldw	r2,64(r2)
  80118c:	2085383a 	mul	r2,r4,r2
  801190:	1887883a 	add	r3,r3,r2
  801194:	e0bffd17 	ldw	r2,-12(fp)
  801198:	10c00215 	stw	r3,8(r2)
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
  80119c:	e0bffd17 	ldw	r2,-12(fp)
  8011a0:	10000e15 	stw	zero,56(r2)
		pxQueue->pcWriteTo = pxQueue->pcHead;
  8011a4:	e0bffd17 	ldw	r2,-12(fp)
  8011a8:	10c00017 	ldw	r3,0(r2)
  8011ac:	e0bffd17 	ldw	r2,-12(fp)
  8011b0:	10c00115 	stw	r3,4(r2)
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
  8011b4:	e0bffd17 	ldw	r2,-12(fp)
  8011b8:	10c00017 	ldw	r3,0(r2)
  8011bc:	e0bffd17 	ldw	r2,-12(fp)
  8011c0:	10800f17 	ldw	r2,60(r2)
  8011c4:	113fffc4 	addi	r4,r2,-1
  8011c8:	e0bffd17 	ldw	r2,-12(fp)
  8011cc:	10801017 	ldw	r2,64(r2)
  8011d0:	2085383a 	mul	r2,r4,r2
  8011d4:	1887883a 	add	r3,r3,r2
  8011d8:	e0bffd17 	ldw	r2,-12(fp)
  8011dc:	10c00315 	stw	r3,12(r2)
		pxQueue->cRxLock = queueUNLOCKED;
  8011e0:	e0bffd17 	ldw	r2,-12(fp)
  8011e4:	00ffffc4 	movi	r3,-1
  8011e8:	10c01105 	stb	r3,68(r2)
		pxQueue->cTxLock = queueUNLOCKED;
  8011ec:	e0bffd17 	ldw	r2,-12(fp)
  8011f0:	00ffffc4 	movi	r3,-1
  8011f4:	10c01145 	stb	r3,69(r2)

		if( xNewQueue == pdFALSE )
  8011f8:	e0bfff17 	ldw	r2,-4(fp)
  8011fc:	10000a1e 	bne	r2,zero,801228 <xQueueGenericReset+0xd8>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  801200:	e0bffd17 	ldw	r2,-12(fp)
  801204:	10800417 	ldw	r2,16(r2)
  801208:	10000f26 	beq	r2,zero,801248 <xQueueGenericReset+0xf8>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  80120c:	e0bffd17 	ldw	r2,-12(fp)
  801210:	10800404 	addi	r2,r2,16
  801214:	1009883a 	mov	r4,r2
  801218:	08046540 	call	804654 <xTaskRemoveFromEventList>
  80121c:	10000a26 	beq	r2,zero,801248 <xQueueGenericReset+0xf8>
				{
					queueYIELD_IF_USING_PREEMPTION();
  801220:	003b683a 	trap	0
  801224:	00000806 	br	801248 <xQueueGenericReset+0xf8>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
  801228:	e0bffd17 	ldw	r2,-12(fp)
  80122c:	10800404 	addi	r2,r2,16
  801230:	1009883a 	mov	r4,r2
  801234:	08009a00 	call	8009a0 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
  801238:	e0bffd17 	ldw	r2,-12(fp)
  80123c:	10800904 	addi	r2,r2,36
  801240:	1009883a 	mov	r4,r2
  801244:	08009a00 	call	8009a0 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
  801248:	08050480 	call	805048 <vTaskExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
  80124c:	00800044 	movi	r2,1
}
  801250:	e037883a 	mov	sp,fp
  801254:	dfc00117 	ldw	ra,4(sp)
  801258:	df000017 	ldw	fp,0(sp)
  80125c:	dec00204 	addi	sp,sp,8
  801260:	f800283a 	ret

00801264 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
  801264:	defff704 	addi	sp,sp,-36
  801268:	dfc00815 	stw	ra,32(sp)
  80126c:	df000715 	stw	fp,28(sp)
  801270:	df000704 	addi	fp,sp,28
  801274:	e13ffd15 	stw	r4,-12(fp)
  801278:	e17ffe15 	stw	r5,-8(fp)
  80127c:	3005883a 	mov	r2,r6
  801280:	e0bfff05 	stb	r2,-4(fp)
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		/* Allocate enough space to hold the maximum number of items that
		can be in the queue at any time.  It is valid for uxItemSize to be
		zero in the case the queue is used as a semaphore. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  801284:	e0fffd17 	ldw	r3,-12(fp)
  801288:	e0bffe17 	ldw	r2,-8(fp)
  80128c:	1885383a 	mul	r2,r3,r2
  801290:	e0bffa15 	stw	r2,-24(fp)
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
  801294:	e0bffa17 	ldw	r2,-24(fp)
  801298:	10801204 	addi	r2,r2,72
  80129c:	1009883a 	mov	r4,r2
  8012a0:	080101c0 	call	80101c <pvPortMalloc>
  8012a4:	e0bffb15 	stw	r2,-20(fp)

		if( pxNewQueue != NULL )
  8012a8:	e0bffb17 	ldw	r2,-20(fp)
  8012ac:	10000d26 	beq	r2,zero,8012e4 <xQueueGenericCreate+0x80>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
  8012b0:	e0bffb17 	ldw	r2,-20(fp)
  8012b4:	e0bffc15 	stw	r2,-16(fp)
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
  8012b8:	e0bffc17 	ldw	r2,-16(fp)
  8012bc:	10801204 	addi	r2,r2,72
  8012c0:	e0bffc15 	stw	r2,-16(fp)
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
  8012c4:	e0ffff03 	ldbu	r3,-4(fp)
  8012c8:	e0bffb17 	ldw	r2,-20(fp)
  8012cc:	d8800015 	stw	r2,0(sp)
  8012d0:	180f883a 	mov	r7,r3
  8012d4:	e1bffc17 	ldw	r6,-16(fp)
  8012d8:	e17ffe17 	ldw	r5,-8(fp)
  8012dc:	e13ffd17 	ldw	r4,-12(fp)
  8012e0:	08012fc0 	call	8012fc <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
  8012e4:	e0bffb17 	ldw	r2,-20(fp)
	}
  8012e8:	e037883a 	mov	sp,fp
  8012ec:	dfc00117 	ldw	ra,4(sp)
  8012f0:	df000017 	ldw	fp,0(sp)
  8012f4:	dec00204 	addi	sp,sp,8
  8012f8:	f800283a 	ret

008012fc <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
  8012fc:	defffa04 	addi	sp,sp,-24
  801300:	dfc00515 	stw	ra,20(sp)
  801304:	df000415 	stw	fp,16(sp)
  801308:	df000404 	addi	fp,sp,16
  80130c:	e13ffc15 	stw	r4,-16(fp)
  801310:	e17ffd15 	stw	r5,-12(fp)
  801314:	e1bffe15 	stw	r6,-8(fp)
  801318:	3805883a 	mov	r2,r7
  80131c:	e0bfff05 	stb	r2,-4(fp)
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
  801320:	e0bffd17 	ldw	r2,-12(fp)
  801324:	1000041e 	bne	r2,zero,801338 <prvInitialiseNewQueue+0x3c>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
  801328:	e0800217 	ldw	r2,8(fp)
  80132c:	e0c00217 	ldw	r3,8(fp)
  801330:	10c00015 	stw	r3,0(r2)
  801334:	00000306 	br	801344 <prvInitialiseNewQueue+0x48>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
  801338:	e0800217 	ldw	r2,8(fp)
  80133c:	e0fffe17 	ldw	r3,-8(fp)
  801340:	10c00015 	stw	r3,0(r2)
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
  801344:	e0800217 	ldw	r2,8(fp)
  801348:	e0fffc17 	ldw	r3,-16(fp)
  80134c:	10c00f15 	stw	r3,60(r2)
	pxNewQueue->uxItemSize = uxItemSize;
  801350:	e0800217 	ldw	r2,8(fp)
  801354:	e0fffd17 	ldw	r3,-12(fp)
  801358:	10c01015 	stw	r3,64(r2)
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
  80135c:	01400044 	movi	r5,1
  801360:	e1000217 	ldw	r4,8(fp)
  801364:	08011500 	call	801150 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
  801368:	0001883a 	nop
  80136c:	e037883a 	mov	sp,fp
  801370:	dfc00117 	ldw	ra,4(sp)
  801374:	df000017 	ldw	fp,0(sp)
  801378:	dec00204 	addi	sp,sp,8
  80137c:	f800283a 	ret

00801380 <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
  801380:	defffd04 	addi	sp,sp,-12
  801384:	dfc00215 	stw	ra,8(sp)
  801388:	df000115 	stw	fp,4(sp)
  80138c:	df000104 	addi	fp,sp,4
  801390:	e13fff15 	stw	r4,-4(fp)
		if( pxNewQueue != NULL )
  801394:	e0bfff17 	ldw	r2,-4(fp)
  801398:	10000b26 	beq	r2,zero,8013c8 <prvInitialiseMutex+0x48>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
  80139c:	e0bfff17 	ldw	r2,-4(fp)
  8013a0:	10000215 	stw	zero,8(r2)
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
  8013a4:	e0bfff17 	ldw	r2,-4(fp)
  8013a8:	10000015 	stw	zero,0(r2)

			/* In case this is a recursive mutex. */
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
  8013ac:	e0bfff17 	ldw	r2,-4(fp)
  8013b0:	10000315 	stw	zero,12(r2)

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
  8013b4:	000f883a 	mov	r7,zero
  8013b8:	000d883a 	mov	r6,zero
  8013bc:	000b883a 	mov	r5,zero
  8013c0:	e13fff17 	ldw	r4,-4(fp)
  8013c4:	08015c00 	call	8015c0 <xQueueGenericSend>
		}
		else
		{
			traceCREATE_MUTEX_FAILED();
		}
	}
  8013c8:	0001883a 	nop
  8013cc:	e037883a 	mov	sp,fp
  8013d0:	dfc00117 	ldw	ra,4(sp)
  8013d4:	df000017 	ldw	fp,0(sp)
  8013d8:	dec00204 	addi	sp,sp,8
  8013dc:	f800283a 	ret

008013e0 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
  8013e0:	defffa04 	addi	sp,sp,-24
  8013e4:	dfc00515 	stw	ra,20(sp)
  8013e8:	df000415 	stw	fp,16(sp)
  8013ec:	df000404 	addi	fp,sp,16
  8013f0:	2005883a 	mov	r2,r4
  8013f4:	e0bfff05 	stb	r2,-4(fp)
	QueueHandle_t xNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
  8013f8:	00800044 	movi	r2,1
  8013fc:	e0bffc15 	stw	r2,-16(fp)
  801400:	e03ffd15 	stw	zero,-12(fp)

		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
  801404:	e0bfff03 	ldbu	r2,-4(fp)
  801408:	100d883a 	mov	r6,r2
  80140c:	e17ffd17 	ldw	r5,-12(fp)
  801410:	e13ffc17 	ldw	r4,-16(fp)
  801414:	08012640 	call	801264 <xQueueGenericCreate>
  801418:	e0bffe15 	stw	r2,-8(fp)
		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
  80141c:	e13ffe17 	ldw	r4,-8(fp)
  801420:	08013800 	call	801380 <prvInitialiseMutex>

		return xNewQueue;
  801424:	e0bffe17 	ldw	r2,-8(fp)
	}
  801428:	e037883a 	mov	sp,fp
  80142c:	dfc00117 	ldw	ra,4(sp)
  801430:	df000017 	ldw	fp,0(sp)
  801434:	dec00204 	addi	sp,sp,8
  801438:	f800283a 	ret

0080143c <xQueueGiveMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
	{
  80143c:	defffa04 	addi	sp,sp,-24
  801440:	dfc00515 	stw	ra,20(sp)
  801444:	df000415 	stw	fp,16(sp)
  801448:	dc000315 	stw	r16,12(sp)
  80144c:	df000404 	addi	fp,sp,16
  801450:	e13ffe15 	stw	r4,-8(fp)
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
  801454:	e0bffe17 	ldw	r2,-8(fp)
  801458:	e0bffd15 	stw	r2,-12(fp)
		change outside of this task.  If this task does not hold the mutex then
		pxMutexHolder can never coincidentally equal the tasks handle, and as
		this is the only condition we are interested in it does not matter if
		pxMutexHolder is accessed simultaneously by another task.  Therefore no
		mutual exclusion is required to test the pxMutexHolder variable. */
		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
  80145c:	e0bffd17 	ldw	r2,-12(fp)
  801460:	14000217 	ldw	r16,8(r2)
  801464:	0804c500 	call	804c50 <xTaskGetCurrentTaskHandle>
  801468:	8080101e 	bne	r16,r2,8014ac <xQueueGiveMutexRecursive+0x70>
			/* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
			the task handle, therefore no underflow check is required.  Also,
			uxRecursiveCallCount is only modified by the mutex holder, and as
			there can only be one, no mutual exclusion is required to modify the
			uxRecursiveCallCount member. */
			( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
  80146c:	e0bffd17 	ldw	r2,-12(fp)
  801470:	10800317 	ldw	r2,12(r2)
  801474:	10ffffc4 	addi	r3,r2,-1
  801478:	e0bffd17 	ldw	r2,-12(fp)
  80147c:	10c00315 	stw	r3,12(r2)

			/* Has the recursive call count unwound to 0? */
			if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
  801480:	e0bffd17 	ldw	r2,-12(fp)
  801484:	10800317 	ldw	r2,12(r2)
  801488:	1000051e 	bne	r2,zero,8014a0 <xQueueGiveMutexRecursive+0x64>
			{
				/* Return the mutex.  This will automatically unblock any other
				task that might be waiting to access the mutex. */
				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
  80148c:	000f883a 	mov	r7,zero
  801490:	000d883a 	mov	r6,zero
  801494:	000b883a 	mov	r5,zero
  801498:	e13ffd17 	ldw	r4,-12(fp)
  80149c:	08015c00 	call	8015c0 <xQueueGenericSend>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
  8014a0:	00800044 	movi	r2,1
  8014a4:	e0bffc15 	stw	r2,-16(fp)
  8014a8:	00000106 	br	8014b0 <xQueueGiveMutexRecursive+0x74>
		}
		else
		{
			/* The mutex cannot be given because the calling task is not the
			holder. */
			xReturn = pdFAIL;
  8014ac:	e03ffc15 	stw	zero,-16(fp)

			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
		}

		return xReturn;
  8014b0:	e0bffc17 	ldw	r2,-16(fp)
	}
  8014b4:	e6ffff04 	addi	sp,fp,-4
  8014b8:	dfc00217 	ldw	ra,8(sp)
  8014bc:	df000117 	ldw	fp,4(sp)
  8014c0:	dc000017 	ldw	r16,0(sp)
  8014c4:	dec00304 	addi	sp,sp,12
  8014c8:	f800283a 	ret

008014cc <xQueueTakeMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
	{
  8014cc:	defff904 	addi	sp,sp,-28
  8014d0:	dfc00615 	stw	ra,24(sp)
  8014d4:	df000515 	stw	fp,20(sp)
  8014d8:	dc000415 	stw	r16,16(sp)
  8014dc:	df000504 	addi	fp,sp,20
  8014e0:	e13ffd15 	stw	r4,-12(fp)
  8014e4:	e17ffe15 	stw	r5,-8(fp)
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
  8014e8:	e0bffd17 	ldw	r2,-12(fp)
  8014ec:	e0bffc15 	stw	r2,-16(fp)
		/* Comments regarding mutual exclusion as per those within
		xQueueGiveMutexRecursive(). */

		traceTAKE_MUTEX_RECURSIVE( pxMutex );

		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
  8014f0:	e0bffc17 	ldw	r2,-16(fp)
  8014f4:	14000217 	ldw	r16,8(r2)
  8014f8:	0804c500 	call	804c50 <xTaskGetCurrentTaskHandle>
  8014fc:	8080081e 	bne	r16,r2,801520 <xQueueTakeMutexRecursive+0x54>
		{
			( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
  801500:	e0bffc17 	ldw	r2,-16(fp)
  801504:	10800317 	ldw	r2,12(r2)
  801508:	10c00044 	addi	r3,r2,1
  80150c:	e0bffc17 	ldw	r2,-16(fp)
  801510:	10c00315 	stw	r3,12(r2)
			xReturn = pdPASS;
  801514:	00800044 	movi	r2,1
  801518:	e0bffb15 	stw	r2,-20(fp)
  80151c:	00000b06 	br	80154c <xQueueTakeMutexRecursive+0x80>
		}
		else
		{
			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
  801520:	e17ffe17 	ldw	r5,-8(fp)
  801524:	e13ffc17 	ldw	r4,-16(fp)
  801528:	0801aec0 	call	801aec <xQueueSemaphoreTake>
  80152c:	e0bffb15 	stw	r2,-20(fp)

			/* pdPASS will only be returned if the mutex was successfully
			obtained.  The calling task may have entered the Blocked state
			before reaching here. */
			if( xReturn != pdFAIL )
  801530:	e0bffb17 	ldw	r2,-20(fp)
  801534:	10000526 	beq	r2,zero,80154c <xQueueTakeMutexRecursive+0x80>
			{
				( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
  801538:	e0bffc17 	ldw	r2,-16(fp)
  80153c:	10800317 	ldw	r2,12(r2)
  801540:	10c00044 	addi	r3,r2,1
  801544:	e0bffc17 	ldw	r2,-16(fp)
  801548:	10c00315 	stw	r3,12(r2)
			{
				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
			}
		}

		return xReturn;
  80154c:	e0bffb17 	ldw	r2,-20(fp)
	}
  801550:	e6ffff04 	addi	sp,fp,-4
  801554:	dfc00217 	ldw	ra,8(sp)
  801558:	df000117 	ldw	fp,4(sp)
  80155c:	dc000017 	ldw	r16,0(sp)
  801560:	dec00304 	addi	sp,sp,12
  801564:	f800283a 	ret

00801568 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
  801568:	defffb04 	addi	sp,sp,-20
  80156c:	dfc00415 	stw	ra,16(sp)
  801570:	df000315 	stw	fp,12(sp)
  801574:	df000304 	addi	fp,sp,12
  801578:	e13ffe15 	stw	r4,-8(fp)
  80157c:	e17fff15 	stw	r5,-4(fp)
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
		configASSERT( uxInitialCount <= uxMaxCount );

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
  801580:	01800084 	movi	r6,2
  801584:	000b883a 	mov	r5,zero
  801588:	e13ffe17 	ldw	r4,-8(fp)
  80158c:	08012640 	call	801264 <xQueueGenericCreate>
  801590:	e0bffd15 	stw	r2,-12(fp)

		if( xHandle != NULL )
  801594:	e0bffd17 	ldw	r2,-12(fp)
  801598:	10000326 	beq	r2,zero,8015a8 <xQueueCreateCountingSemaphore+0x40>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
  80159c:	e0bffd17 	ldw	r2,-12(fp)
  8015a0:	e0ffff17 	ldw	r3,-4(fp)
  8015a4:	10c00e15 	stw	r3,56(r2)
		else
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		return xHandle;
  8015a8:	e0bffd17 	ldw	r2,-12(fp)
	}
  8015ac:	e037883a 	mov	sp,fp
  8015b0:	dfc00117 	ldw	ra,4(sp)
  8015b4:	df000017 	ldw	fp,0(sp)
  8015b8:	dec00204 	addi	sp,sp,8
  8015bc:	f800283a 	ret

008015c0 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
  8015c0:	defff504 	addi	sp,sp,-44
  8015c4:	dfc00a15 	stw	ra,40(sp)
  8015c8:	df000915 	stw	fp,36(sp)
  8015cc:	df000904 	addi	fp,sp,36
  8015d0:	e13ffc15 	stw	r4,-16(fp)
  8015d4:	e17ffd15 	stw	r5,-12(fp)
  8015d8:	e1bffe15 	stw	r6,-8(fp)
  8015dc:	e1ffff15 	stw	r7,-4(fp)
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
  8015e0:	e03ff715 	stw	zero,-36(fp)
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
  8015e4:	e0bffc17 	ldw	r2,-16(fp)
  8015e8:	e0bff815 	stw	r2,-32(fp)
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
  8015ec:	0804ff40 	call	804ff4 <vTaskEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
  8015f0:	e0bff817 	ldw	r2,-32(fp)
  8015f4:	10c00e17 	ldw	r3,56(r2)
  8015f8:	e0bff817 	ldw	r2,-32(fp)
  8015fc:	10800f17 	ldw	r2,60(r2)
  801600:	18800336 	bltu	r3,r2,801610 <xQueueGenericSend+0x50>
  801604:	e0bfff17 	ldw	r2,-4(fp)
  801608:	10800098 	cmpnei	r2,r2,2
  80160c:	1000151e 	bne	r2,zero,801664 <xQueueGenericSend+0xa4>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  801610:	e1bfff17 	ldw	r6,-4(fp)
  801614:	e17ffd17 	ldw	r5,-12(fp)
  801618:	e13ff817 	ldw	r4,-32(fp)
  80161c:	08021640 	call	802164 <prvCopyDataToQueue>
  801620:	e0bff915 	stw	r2,-28(fp)

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  801624:	e0bff817 	ldw	r2,-32(fp)
  801628:	10800917 	ldw	r2,36(r2)
  80162c:	10000726 	beq	r2,zero,80164c <xQueueGenericSend+0x8c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  801630:	e0bff817 	ldw	r2,-32(fp)
  801634:	10800904 	addi	r2,r2,36
  801638:	1009883a 	mov	r4,r2
  80163c:	08046540 	call	804654 <xTaskRemoveFromEventList>
  801640:	10000526 	beq	r2,zero,801658 <xQueueGenericSend+0x98>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
  801644:	003b683a 	trap	0
  801648:	00000306 	br	801658 <xQueueGenericSend+0x98>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
  80164c:	e0bff917 	ldw	r2,-28(fp)
  801650:	10000126 	beq	r2,zero,801658 <xQueueGenericSend+0x98>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
  801654:	003b683a 	trap	0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
  801658:	08050480 	call	805048 <vTaskExitCritical>
				return pdPASS;
  80165c:	00800044 	movi	r2,1
  801660:	00003f06 	br	801760 <xQueueGenericSend+0x1a0>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
  801664:	e0bffe17 	ldw	r2,-8(fp)
  801668:	1000031e 	bne	r2,zero,801678 <xQueueGenericSend+0xb8>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
  80166c:	08050480 	call	805048 <vTaskExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
  801670:	0005883a 	mov	r2,zero
  801674:	00003a06 	br	801760 <xQueueGenericSend+0x1a0>
				}
				else if( xEntryTimeSet == pdFALSE )
  801678:	e0bff717 	ldw	r2,-36(fp)
  80167c:	1000051e 	bne	r2,zero,801694 <xQueueGenericSend+0xd4>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
  801680:	e0bffa04 	addi	r2,fp,-24
  801684:	1009883a 	mov	r4,r2
  801688:	080485c0 	call	80485c <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
  80168c:	00800044 	movi	r2,1
  801690:	e0bff715 	stw	r2,-36(fp)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
  801694:	08050480 	call	805048 <vTaskExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  801698:	08040940 	call	804094 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
  80169c:	0804ff40 	call	804ff4 <vTaskEnterCritical>
  8016a0:	e0bff817 	ldw	r2,-32(fp)
  8016a4:	10801103 	ldbu	r2,68(r2)
  8016a8:	10803fcc 	andi	r2,r2,255
  8016ac:	1080201c 	xori	r2,r2,128
  8016b0:	10bfe004 	addi	r2,r2,-128
  8016b4:	10bfffd8 	cmpnei	r2,r2,-1
  8016b8:	1000021e 	bne	r2,zero,8016c4 <xQueueGenericSend+0x104>
  8016bc:	e0bff817 	ldw	r2,-32(fp)
  8016c0:	10001105 	stb	zero,68(r2)
  8016c4:	e0bff817 	ldw	r2,-32(fp)
  8016c8:	10801143 	ldbu	r2,69(r2)
  8016cc:	10803fcc 	andi	r2,r2,255
  8016d0:	1080201c 	xori	r2,r2,128
  8016d4:	10bfe004 	addi	r2,r2,-128
  8016d8:	10bfffd8 	cmpnei	r2,r2,-1
  8016dc:	1000021e 	bne	r2,zero,8016e8 <xQueueGenericSend+0x128>
  8016e0:	e0bff817 	ldw	r2,-32(fp)
  8016e4:	10001145 	stb	zero,69(r2)
  8016e8:	08050480 	call	805048 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  8016ec:	e0fffe04 	addi	r3,fp,-8
  8016f0:	e0bffa04 	addi	r2,fp,-24
  8016f4:	180b883a 	mov	r5,r3
  8016f8:	1009883a 	mov	r4,r2
  8016fc:	08048980 	call	804898 <xTaskCheckForTimeOut>
  801700:	1000131e 	bne	r2,zero,801750 <xQueueGenericSend+0x190>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
  801704:	e13ff817 	ldw	r4,-32(fp)
  801708:	08025180 	call	802518 <prvIsQueueFull>
  80170c:	10000c26 	beq	r2,zero,801740 <xQueueGenericSend+0x180>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
  801710:	e0bff817 	ldw	r2,-32(fp)
  801714:	10800404 	addi	r2,r2,16
  801718:	e0fffe17 	ldw	r3,-8(fp)
  80171c:	180b883a 	mov	r5,r3
  801720:	1009883a 	mov	r4,r2
  801724:	08045a00 	call	8045a0 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
  801728:	e13ff817 	ldw	r4,-32(fp)
  80172c:	080238c0 	call	80238c <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
  801730:	08040c00 	call	8040c0 <xTaskResumeAll>
  801734:	103fad1e 	bne	r2,zero,8015ec <__alt_mem_onchip_memory2_0+0xff7815ec>
				{
					portYIELD_WITHIN_API();
  801738:	003b683a 	trap	0
  80173c:	003fab06 	br	8015ec <__alt_mem_onchip_memory2_0+0xff7815ec>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
  801740:	e13ff817 	ldw	r4,-32(fp)
  801744:	080238c0 	call	80238c <prvUnlockQueue>
				( void ) xTaskResumeAll();
  801748:	08040c00 	call	8040c0 <xTaskResumeAll>
  80174c:	003fa706 	br	8015ec <__alt_mem_onchip_memory2_0+0xff7815ec>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
  801750:	e13ff817 	ldw	r4,-32(fp)
  801754:	080238c0 	call	80238c <prvUnlockQueue>
			( void ) xTaskResumeAll();
  801758:	08040c00 	call	8040c0 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
  80175c:	0005883a 	mov	r2,zero
		}
	} /*lint -restore */
}
  801760:	e037883a 	mov	sp,fp
  801764:	dfc00117 	ldw	ra,4(sp)
  801768:	df000017 	ldw	fp,0(sp)
  80176c:	dec00204 	addi	sp,sp,8
  801770:	f800283a 	ret

00801774 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
  801774:	defff504 	addi	sp,sp,-44
  801778:	dfc00a15 	stw	ra,40(sp)
  80177c:	df000915 	stw	fp,36(sp)
  801780:	df000904 	addi	fp,sp,36
  801784:	e13ffc15 	stw	r4,-16(fp)
  801788:	e17ffd15 	stw	r5,-12(fp)
  80178c:	e1bffe15 	stw	r6,-8(fp)
  801790:	e1ffff15 	stw	r7,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
  801794:	e0bffc17 	ldw	r2,-16(fp)
  801798:	e0bff815 	stw	r2,-32(fp)
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  80179c:	e03ff915 	stw	zero,-28(fp)
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
  8017a0:	e0bff817 	ldw	r2,-32(fp)
  8017a4:	10c00e17 	ldw	r3,56(r2)
  8017a8:	e0bff817 	ldw	r2,-32(fp)
  8017ac:	10800f17 	ldw	r2,60(r2)
  8017b0:	18800336 	bltu	r3,r2,8017c0 <xQueueGenericSendFromISR+0x4c>
  8017b4:	e0bfff17 	ldw	r2,-4(fp)
  8017b8:	10800098 	cmpnei	r2,r2,2
  8017bc:	1000231e 	bne	r2,zero,80184c <xQueueGenericSendFromISR+0xd8>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
  8017c0:	e0bff817 	ldw	r2,-32(fp)
  8017c4:	10801143 	ldbu	r2,69(r2)
  8017c8:	e0bffa05 	stb	r2,-24(fp)
			const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
  8017cc:	e0bff817 	ldw	r2,-32(fp)
  8017d0:	10800e17 	ldw	r2,56(r2)
  8017d4:	e0bffb15 	stw	r2,-20(fp)
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  8017d8:	e1bfff17 	ldw	r6,-4(fp)
  8017dc:	e17ffd17 	ldw	r5,-12(fp)
  8017e0:	e13ff817 	ldw	r4,-32(fp)
  8017e4:	08021640 	call	802164 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
  8017e8:	e0bffa07 	ldb	r2,-24(fp)
  8017ec:	10bfffd8 	cmpnei	r2,r2,-1
  8017f0:	10000e1e 	bne	r2,zero,80182c <xQueueGenericSendFromISR+0xb8>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  8017f4:	e0bff817 	ldw	r2,-32(fp)
  8017f8:	10800917 	ldw	r2,36(r2)
  8017fc:	10001026 	beq	r2,zero,801840 <xQueueGenericSendFromISR+0xcc>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  801800:	e0bff817 	ldw	r2,-32(fp)
  801804:	10800904 	addi	r2,r2,36
  801808:	1009883a 	mov	r4,r2
  80180c:	08046540 	call	804654 <xTaskRemoveFromEventList>
  801810:	10000b26 	beq	r2,zero,801840 <xQueueGenericSendFromISR+0xcc>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
  801814:	e0bffe17 	ldw	r2,-8(fp)
  801818:	10000926 	beq	r2,zero,801840 <xQueueGenericSendFromISR+0xcc>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
  80181c:	e0bffe17 	ldw	r2,-8(fp)
  801820:	00c00044 	movi	r3,1
  801824:	10c00015 	stw	r3,0(r2)
  801828:	00000506 	br	801840 <xQueueGenericSendFromISR+0xcc>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
  80182c:	e0bffa03 	ldbu	r2,-24(fp)
  801830:	10800044 	addi	r2,r2,1
  801834:	1007883a 	mov	r3,r2
  801838:	e0bff817 	ldw	r2,-32(fp)
  80183c:	10c01145 	stb	r3,69(r2)
			}

			xReturn = pdPASS;
  801840:	00800044 	movi	r2,1
  801844:	e0bff715 	stw	r2,-36(fp)
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
		{
  801848:	00000106 	br	801850 <xQueueGenericSendFromISR+0xdc>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
  80184c:	e03ff715 	stw	zero,-36(fp)
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
  801850:	e0bff717 	ldw	r2,-36(fp)
}
  801854:	e037883a 	mov	sp,fp
  801858:	dfc00117 	ldw	ra,4(sp)
  80185c:	df000017 	ldw	fp,0(sp)
  801860:	dec00204 	addi	sp,sp,8
  801864:	f800283a 	ret

00801868 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
  801868:	defff704 	addi	sp,sp,-36
  80186c:	dfc00815 	stw	ra,32(sp)
  801870:	df000715 	stw	fp,28(sp)
  801874:	df000704 	addi	fp,sp,28
  801878:	e13ffe15 	stw	r4,-8(fp)
  80187c:	e17fff15 	stw	r5,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
  801880:	e0bffe17 	ldw	r2,-8(fp)
  801884:	e0bffa15 	stw	r2,-24(fp)
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  801888:	e03ffb15 	stw	zero,-20(fp)
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  80188c:	e0bffa17 	ldw	r2,-24(fp)
  801890:	10800e17 	ldw	r2,56(r2)
  801894:	e0bffc15 	stw	r2,-16(fp)

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
  801898:	e0bffa17 	ldw	r2,-24(fp)
  80189c:	10800f17 	ldw	r2,60(r2)
  8018a0:	e0fffc17 	ldw	r3,-16(fp)
  8018a4:	1880202e 	bgeu	r3,r2,801928 <xQueueGiveFromISR+0xc0>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
  8018a8:	e0bffa17 	ldw	r2,-24(fp)
  8018ac:	10801143 	ldbu	r2,69(r2)
  8018b0:	e0bffd05 	stb	r2,-12(fp)
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
  8018b4:	e0bffc17 	ldw	r2,-16(fp)
  8018b8:	10c00044 	addi	r3,r2,1
  8018bc:	e0bffa17 	ldw	r2,-24(fp)
  8018c0:	10c00e15 	stw	r3,56(r2)

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
  8018c4:	e0bffd07 	ldb	r2,-12(fp)
  8018c8:	10bfffd8 	cmpnei	r2,r2,-1
  8018cc:	10000e1e 	bne	r2,zero,801908 <xQueueGiveFromISR+0xa0>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  8018d0:	e0bffa17 	ldw	r2,-24(fp)
  8018d4:	10800917 	ldw	r2,36(r2)
  8018d8:	10001026 	beq	r2,zero,80191c <xQueueGiveFromISR+0xb4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  8018dc:	e0bffa17 	ldw	r2,-24(fp)
  8018e0:	10800904 	addi	r2,r2,36
  8018e4:	1009883a 	mov	r4,r2
  8018e8:	08046540 	call	804654 <xTaskRemoveFromEventList>
  8018ec:	10000b26 	beq	r2,zero,80191c <xQueueGiveFromISR+0xb4>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
  8018f0:	e0bfff17 	ldw	r2,-4(fp)
  8018f4:	10000926 	beq	r2,zero,80191c <xQueueGiveFromISR+0xb4>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
  8018f8:	e0bfff17 	ldw	r2,-4(fp)
  8018fc:	00c00044 	movi	r3,1
  801900:	10c00015 	stw	r3,0(r2)
  801904:	00000506 	br	80191c <xQueueGiveFromISR+0xb4>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
  801908:	e0bffd03 	ldbu	r2,-12(fp)
  80190c:	10800044 	addi	r2,r2,1
  801910:	1007883a 	mov	r3,r2
  801914:	e0bffa17 	ldw	r2,-24(fp)
  801918:	10c01145 	stb	r3,69(r2)
			}

			xReturn = pdPASS;
  80191c:	00800044 	movi	r2,1
  801920:	e0bff915 	stw	r2,-28(fp)
  801924:	00000106 	br	80192c <xQueueGiveFromISR+0xc4>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
  801928:	e03ff915 	stw	zero,-28(fp)
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
  80192c:	e0bff917 	ldw	r2,-28(fp)
}
  801930:	e037883a 	mov	sp,fp
  801934:	dfc00117 	ldw	ra,4(sp)
  801938:	df000017 	ldw	fp,0(sp)
  80193c:	dec00204 	addi	sp,sp,8
  801940:	f800283a 	ret

00801944 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
  801944:	defff604 	addi	sp,sp,-40
  801948:	dfc00915 	stw	ra,36(sp)
  80194c:	df000815 	stw	fp,32(sp)
  801950:	df000804 	addi	fp,sp,32
  801954:	e13ffd15 	stw	r4,-12(fp)
  801958:	e17ffe15 	stw	r5,-8(fp)
  80195c:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xEntryTimeSet = pdFALSE;
  801960:	e03ff815 	stw	zero,-32(fp)
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
  801964:	e0bffd17 	ldw	r2,-12(fp)
  801968:	e0bff915 	stw	r2,-28(fp)
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
  80196c:	0804ff40 	call	804ff4 <vTaskEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  801970:	e0bff917 	ldw	r2,-28(fp)
  801974:	10800e17 	ldw	r2,56(r2)
  801978:	e0bffa15 	stw	r2,-24(fp)

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
  80197c:	e0bffa17 	ldw	r2,-24(fp)
  801980:	10001326 	beq	r2,zero,8019d0 <xQueueReceive+0x8c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
  801984:	e17ffe17 	ldw	r5,-8(fp)
  801988:	e13ff917 	ldw	r4,-28(fp)
  80198c:	08022f00 	call	8022f0 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
  801990:	e0bffa17 	ldw	r2,-24(fp)
  801994:	10ffffc4 	addi	r3,r2,-1
  801998:	e0bff917 	ldw	r2,-28(fp)
  80199c:	10c00e15 	stw	r3,56(r2)

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  8019a0:	e0bff917 	ldw	r2,-28(fp)
  8019a4:	10800417 	ldw	r2,16(r2)
  8019a8:	10000626 	beq	r2,zero,8019c4 <xQueueReceive+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  8019ac:	e0bff917 	ldw	r2,-28(fp)
  8019b0:	10800404 	addi	r2,r2,16
  8019b4:	1009883a 	mov	r4,r2
  8019b8:	08046540 	call	804654 <xTaskRemoveFromEventList>
  8019bc:	10000126 	beq	r2,zero,8019c4 <xQueueReceive+0x80>
					{
						queueYIELD_IF_USING_PREEMPTION();
  8019c0:	003b683a 	trap	0
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
  8019c4:	08050480 	call	805048 <vTaskExitCritical>
				return pdPASS;
  8019c8:	00800044 	movi	r2,1
  8019cc:	00004206 	br	801ad8 <xQueueReceive+0x194>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
  8019d0:	e0bfff17 	ldw	r2,-4(fp)
  8019d4:	1000031e 	bne	r2,zero,8019e4 <xQueueReceive+0xa0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
  8019d8:	08050480 	call	805048 <vTaskExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
  8019dc:	0005883a 	mov	r2,zero
  8019e0:	00003d06 	br	801ad8 <xQueueReceive+0x194>
				}
				else if( xEntryTimeSet == pdFALSE )
  8019e4:	e0bff817 	ldw	r2,-32(fp)
  8019e8:	1000051e 	bne	r2,zero,801a00 <xQueueReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
  8019ec:	e0bffb04 	addi	r2,fp,-20
  8019f0:	1009883a 	mov	r4,r2
  8019f4:	080485c0 	call	80485c <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
  8019f8:	00800044 	movi	r2,1
  8019fc:	e0bff815 	stw	r2,-32(fp)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
  801a00:	08050480 	call	805048 <vTaskExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  801a04:	08040940 	call	804094 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
  801a08:	0804ff40 	call	804ff4 <vTaskEnterCritical>
  801a0c:	e0bff917 	ldw	r2,-28(fp)
  801a10:	10801103 	ldbu	r2,68(r2)
  801a14:	10803fcc 	andi	r2,r2,255
  801a18:	1080201c 	xori	r2,r2,128
  801a1c:	10bfe004 	addi	r2,r2,-128
  801a20:	10bfffd8 	cmpnei	r2,r2,-1
  801a24:	1000021e 	bne	r2,zero,801a30 <xQueueReceive+0xec>
  801a28:	e0bff917 	ldw	r2,-28(fp)
  801a2c:	10001105 	stb	zero,68(r2)
  801a30:	e0bff917 	ldw	r2,-28(fp)
  801a34:	10801143 	ldbu	r2,69(r2)
  801a38:	10803fcc 	andi	r2,r2,255
  801a3c:	1080201c 	xori	r2,r2,128
  801a40:	10bfe004 	addi	r2,r2,-128
  801a44:	10bfffd8 	cmpnei	r2,r2,-1
  801a48:	1000021e 	bne	r2,zero,801a54 <xQueueReceive+0x110>
  801a4c:	e0bff917 	ldw	r2,-28(fp)
  801a50:	10001145 	stb	zero,69(r2)
  801a54:	08050480 	call	805048 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  801a58:	e0ffff04 	addi	r3,fp,-4
  801a5c:	e0bffb04 	addi	r2,fp,-20
  801a60:	180b883a 	mov	r5,r3
  801a64:	1009883a 	mov	r4,r2
  801a68:	08048980 	call	804898 <xTaskCheckForTimeOut>
  801a6c:	1000131e 	bne	r2,zero,801abc <xQueueReceive+0x178>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
  801a70:	e13ff917 	ldw	r4,-28(fp)
  801a74:	08024800 	call	802480 <prvIsQueueEmpty>
  801a78:	10000c26 	beq	r2,zero,801aac <xQueueReceive+0x168>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  801a7c:	e0bff917 	ldw	r2,-28(fp)
  801a80:	10800904 	addi	r2,r2,36
  801a84:	e0ffff17 	ldw	r3,-4(fp)
  801a88:	180b883a 	mov	r5,r3
  801a8c:	1009883a 	mov	r4,r2
  801a90:	08045a00 	call	8045a0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
  801a94:	e13ff917 	ldw	r4,-28(fp)
  801a98:	080238c0 	call	80238c <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
  801a9c:	08040c00 	call	8040c0 <xTaskResumeAll>
  801aa0:	103fb21e 	bne	r2,zero,80196c <__alt_mem_onchip_memory2_0+0xff78196c>
				{
					portYIELD_WITHIN_API();
  801aa4:	003b683a 	trap	0
  801aa8:	003fb006 	br	80196c <__alt_mem_onchip_memory2_0+0xff78196c>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
  801aac:	e13ff917 	ldw	r4,-28(fp)
  801ab0:	080238c0 	call	80238c <prvUnlockQueue>
				( void ) xTaskResumeAll();
  801ab4:	08040c00 	call	8040c0 <xTaskResumeAll>
  801ab8:	003fac06 	br	80196c <__alt_mem_onchip_memory2_0+0xff78196c>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
  801abc:	e13ff917 	ldw	r4,-28(fp)
  801ac0:	080238c0 	call	80238c <prvUnlockQueue>
			( void ) xTaskResumeAll();
  801ac4:	08040c00 	call	8040c0 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
  801ac8:	e13ff917 	ldw	r4,-28(fp)
  801acc:	08024800 	call	802480 <prvIsQueueEmpty>
  801ad0:	103fa626 	beq	r2,zero,80196c <__alt_mem_onchip_memory2_0+0xff78196c>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
  801ad4:	0005883a 	mov	r2,zero
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
  801ad8:	e037883a 	mov	sp,fp
  801adc:	dfc00117 	ldw	ra,4(sp)
  801ae0:	df000017 	ldw	fp,0(sp)
  801ae4:	dec00204 	addi	sp,sp,8
  801ae8:	f800283a 	ret

00801aec <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
  801aec:	defff504 	addi	sp,sp,-44
  801af0:	dfc00a15 	stw	ra,40(sp)
  801af4:	df000915 	stw	fp,36(sp)
  801af8:	df000904 	addi	fp,sp,36
  801afc:	e13ffe15 	stw	r4,-8(fp)
  801b00:	e17fff15 	stw	r5,-4(fp)
BaseType_t xEntryTimeSet = pdFALSE;
  801b04:	e03ff715 	stw	zero,-36(fp)
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
  801b08:	e0bffe17 	ldw	r2,-8(fp)
  801b0c:	e0bff915 	stw	r2,-28(fp)

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
  801b10:	e03ff815 	stw	zero,-32(fp)
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
  801b14:	0804ff40 	call	804ff4 <vTaskEnterCritical>
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
  801b18:	e0bff917 	ldw	r2,-28(fp)
  801b1c:	10800e17 	ldw	r2,56(r2)
  801b20:	e0bffa15 	stw	r2,-24(fp)

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
  801b24:	e0bffa17 	ldw	r2,-24(fp)
  801b28:	10001726 	beq	r2,zero,801b88 <xQueueSemaphoreTake+0x9c>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
  801b2c:	e0bffa17 	ldw	r2,-24(fp)
  801b30:	10ffffc4 	addi	r3,r2,-1
  801b34:	e0bff917 	ldw	r2,-28(fp)
  801b38:	10c00e15 	stw	r3,56(r2)

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  801b3c:	e0bff917 	ldw	r2,-28(fp)
  801b40:	10800017 	ldw	r2,0(r2)
  801b44:	1000041e 	bne	r2,zero,801b58 <xQueueSemaphoreTake+0x6c>
					{
						/* Record the information required to implement
						priority inheritance should it become necessary. */
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
  801b48:	08050ec0 	call	8050ec <pvTaskIncrementMutexHeldCount>
  801b4c:	1007883a 	mov	r3,r2
  801b50:	e0bff917 	ldw	r2,-28(fp)
  801b54:	10c00215 	stw	r3,8(r2)
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  801b58:	e0bff917 	ldw	r2,-28(fp)
  801b5c:	10800417 	ldw	r2,16(r2)
  801b60:	10000626 	beq	r2,zero,801b7c <xQueueSemaphoreTake+0x90>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  801b64:	e0bff917 	ldw	r2,-28(fp)
  801b68:	10800404 	addi	r2,r2,16
  801b6c:	1009883a 	mov	r4,r2
  801b70:	08046540 	call	804654 <xTaskRemoveFromEventList>
  801b74:	10000126 	beq	r2,zero,801b7c <xQueueSemaphoreTake+0x90>
					{
						queueYIELD_IF_USING_PREEMPTION();
  801b78:	003b683a 	trap	0
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
  801b7c:	08050480 	call	805048 <vTaskExitCritical>
				return pdPASS;
  801b80:	00800044 	movi	r2,1
  801b84:	00005806 	br	801ce8 <xQueueSemaphoreTake+0x1fc>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
  801b88:	e0bfff17 	ldw	r2,-4(fp)
  801b8c:	1000031e 	bne	r2,zero,801b9c <xQueueSemaphoreTake+0xb0>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
  801b90:	08050480 	call	805048 <vTaskExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
  801b94:	0005883a 	mov	r2,zero
  801b98:	00005306 	br	801ce8 <xQueueSemaphoreTake+0x1fc>
				}
				else if( xEntryTimeSet == pdFALSE )
  801b9c:	e0bff717 	ldw	r2,-36(fp)
  801ba0:	1000051e 	bne	r2,zero,801bb8 <xQueueSemaphoreTake+0xcc>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
  801ba4:	e0bffc04 	addi	r2,fp,-16
  801ba8:	1009883a 	mov	r4,r2
  801bac:	080485c0 	call	80485c <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
  801bb0:	00800044 	movi	r2,1
  801bb4:	e0bff715 	stw	r2,-36(fp)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
  801bb8:	08050480 	call	805048 <vTaskExitCritical>

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
  801bbc:	08040940 	call	804094 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
  801bc0:	0804ff40 	call	804ff4 <vTaskEnterCritical>
  801bc4:	e0bff917 	ldw	r2,-28(fp)
  801bc8:	10801103 	ldbu	r2,68(r2)
  801bcc:	10803fcc 	andi	r2,r2,255
  801bd0:	1080201c 	xori	r2,r2,128
  801bd4:	10bfe004 	addi	r2,r2,-128
  801bd8:	10bfffd8 	cmpnei	r2,r2,-1
  801bdc:	1000021e 	bne	r2,zero,801be8 <xQueueSemaphoreTake+0xfc>
  801be0:	e0bff917 	ldw	r2,-28(fp)
  801be4:	10001105 	stb	zero,68(r2)
  801be8:	e0bff917 	ldw	r2,-28(fp)
  801bec:	10801143 	ldbu	r2,69(r2)
  801bf0:	10803fcc 	andi	r2,r2,255
  801bf4:	1080201c 	xori	r2,r2,128
  801bf8:	10bfe004 	addi	r2,r2,-128
  801bfc:	10bfffd8 	cmpnei	r2,r2,-1
  801c00:	1000021e 	bne	r2,zero,801c0c <xQueueSemaphoreTake+0x120>
  801c04:	e0bff917 	ldw	r2,-28(fp)
  801c08:	10001145 	stb	zero,69(r2)
  801c0c:	08050480 	call	805048 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  801c10:	e0ffff04 	addi	r3,fp,-4
  801c14:	e0bffc04 	addi	r2,fp,-16
  801c18:	180b883a 	mov	r5,r3
  801c1c:	1009883a 	mov	r4,r2
  801c20:	08048980 	call	804898 <xTaskCheckForTimeOut>
  801c24:	10001d1e 	bne	r2,zero,801c9c <xQueueSemaphoreTake+0x1b0>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
  801c28:	e13ff917 	ldw	r4,-28(fp)
  801c2c:	08024800 	call	802480 <prvIsQueueEmpty>
  801c30:	10001626 	beq	r2,zero,801c8c <xQueueSemaphoreTake+0x1a0>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  801c34:	e0bff917 	ldw	r2,-28(fp)
  801c38:	10800017 	ldw	r2,0(r2)
  801c3c:	1000071e 	bne	r2,zero,801c5c <xQueueSemaphoreTake+0x170>
					{
						taskENTER_CRITICAL();
  801c40:	0804ff40 	call	804ff4 <vTaskEnterCritical>
						{
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
  801c44:	e0bff917 	ldw	r2,-28(fp)
  801c48:	10800217 	ldw	r2,8(r2)
  801c4c:	1009883a 	mov	r4,r2
  801c50:	0804c780 	call	804c78 <xTaskPriorityInherit>
  801c54:	e0bff815 	stw	r2,-32(fp)
						}
						taskEXIT_CRITICAL();
  801c58:	08050480 	call	805048 <vTaskExitCritical>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  801c5c:	e0bff917 	ldw	r2,-28(fp)
  801c60:	10800904 	addi	r2,r2,36
  801c64:	e0ffff17 	ldw	r3,-4(fp)
  801c68:	180b883a 	mov	r5,r3
  801c6c:	1009883a 	mov	r4,r2
  801c70:	08045a00 	call	8045a0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
  801c74:	e13ff917 	ldw	r4,-28(fp)
  801c78:	080238c0 	call	80238c <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
  801c7c:	08040c00 	call	8040c0 <xTaskResumeAll>
  801c80:	103fa41e 	bne	r2,zero,801b14 <__alt_mem_onchip_memory2_0+0xff781b14>
				{
					portYIELD_WITHIN_API();
  801c84:	003b683a 	trap	0
  801c88:	003fa206 	br	801b14 <__alt_mem_onchip_memory2_0+0xff781b14>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
  801c8c:	e13ff917 	ldw	r4,-28(fp)
  801c90:	080238c0 	call	80238c <prvUnlockQueue>
				( void ) xTaskResumeAll();
  801c94:	08040c00 	call	8040c0 <xTaskResumeAll>
  801c98:	003f9e06 	br	801b14 <__alt_mem_onchip_memory2_0+0xff781b14>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
  801c9c:	e13ff917 	ldw	r4,-28(fp)
  801ca0:	080238c0 	call	80238c <prvUnlockQueue>
			( void ) xTaskResumeAll();
  801ca4:	08040c00 	call	8040c0 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
  801ca8:	e13ff917 	ldw	r4,-28(fp)
  801cac:	08024800 	call	802480 <prvIsQueueEmpty>
  801cb0:	103f9826 	beq	r2,zero,801b14 <__alt_mem_onchip_memory2_0+0xff781b14>
				#if ( configUSE_MUTEXES == 1 )
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if( xInheritanceOccurred != pdFALSE )
  801cb4:	e0bff817 	ldw	r2,-32(fp)
  801cb8:	10000a26 	beq	r2,zero,801ce4 <xQueueSemaphoreTake+0x1f8>
					{
						taskENTER_CRITICAL();
  801cbc:	0804ff40 	call	804ff4 <vTaskEnterCritical>
							/* This task blocking on the mutex caused another
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
  801cc0:	e13ff917 	ldw	r4,-28(fp)
  801cc4:	08021140 	call	802114 <prvGetDisinheritPriorityAfterTimeout>
  801cc8:	e0bffb15 	stw	r2,-20(fp)
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
  801ccc:	e0bff917 	ldw	r2,-28(fp)
  801cd0:	10800217 	ldw	r2,8(r2)
  801cd4:	e17ffb17 	ldw	r5,-20(fp)
  801cd8:	1009883a 	mov	r4,r2
  801cdc:	0804eb40 	call	804eb4 <vTaskPriorityDisinheritAfterTimeout>
						}
						taskEXIT_CRITICAL();
  801ce0:	08050480 	call	805048 <vTaskExitCritical>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
  801ce4:	0005883a 	mov	r2,zero
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
  801ce8:	e037883a 	mov	sp,fp
  801cec:	dfc00117 	ldw	ra,4(sp)
  801cf0:	df000017 	ldw	fp,0(sp)
  801cf4:	dec00204 	addi	sp,sp,8
  801cf8:	f800283a 	ret

00801cfc <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
  801cfc:	defff504 	addi	sp,sp,-44
  801d00:	dfc00a15 	stw	ra,40(sp)
  801d04:	df000915 	stw	fp,36(sp)
  801d08:	df000904 	addi	fp,sp,36
  801d0c:	e13ffd15 	stw	r4,-12(fp)
  801d10:	e17ffe15 	stw	r5,-8(fp)
  801d14:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xEntryTimeSet = pdFALSE;
  801d18:	e03ff715 	stw	zero,-36(fp)
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
  801d1c:	e0bffd17 	ldw	r2,-12(fp)
  801d20:	e0bff815 	stw	r2,-32(fp)
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
  801d24:	0804ff40 	call	804ff4 <vTaskEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  801d28:	e0bff817 	ldw	r2,-32(fp)
  801d2c:	10800e17 	ldw	r2,56(r2)
  801d30:	e0bff915 	stw	r2,-28(fp)

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
  801d34:	e0bff917 	ldw	r2,-28(fp)
  801d38:	10001526 	beq	r2,zero,801d90 <xQueuePeek+0x94>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
  801d3c:	e0bff817 	ldw	r2,-32(fp)
  801d40:	10800317 	ldw	r2,12(r2)
  801d44:	e0bffa15 	stw	r2,-24(fp)

				prvCopyDataFromQueue( pxQueue, pvBuffer );
  801d48:	e17ffe17 	ldw	r5,-8(fp)
  801d4c:	e13ff817 	ldw	r4,-32(fp)
  801d50:	08022f00 	call	8022f0 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
  801d54:	e0bff817 	ldw	r2,-32(fp)
  801d58:	e0fffa17 	ldw	r3,-24(fp)
  801d5c:	10c00315 	stw	r3,12(r2)

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  801d60:	e0bff817 	ldw	r2,-32(fp)
  801d64:	10800917 	ldw	r2,36(r2)
  801d68:	10000626 	beq	r2,zero,801d84 <xQueuePeek+0x88>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  801d6c:	e0bff817 	ldw	r2,-32(fp)
  801d70:	10800904 	addi	r2,r2,36
  801d74:	1009883a 	mov	r4,r2
  801d78:	08046540 	call	804654 <xTaskRemoveFromEventList>
  801d7c:	10000126 	beq	r2,zero,801d84 <xQueuePeek+0x88>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
  801d80:	003b683a 	trap	0
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
  801d84:	08050480 	call	805048 <vTaskExitCritical>
				return pdPASS;
  801d88:	00800044 	movi	r2,1
  801d8c:	00004206 	br	801e98 <xQueuePeek+0x19c>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
  801d90:	e0bfff17 	ldw	r2,-4(fp)
  801d94:	1000031e 	bne	r2,zero,801da4 <xQueuePeek+0xa8>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
  801d98:	08050480 	call	805048 <vTaskExitCritical>
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
  801d9c:	0005883a 	mov	r2,zero
  801da0:	00003d06 	br	801e98 <xQueuePeek+0x19c>
				}
				else if( xEntryTimeSet == pdFALSE )
  801da4:	e0bff717 	ldw	r2,-36(fp)
  801da8:	1000051e 	bne	r2,zero,801dc0 <xQueuePeek+0xc4>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
  801dac:	e0bffb04 	addi	r2,fp,-20
  801db0:	1009883a 	mov	r4,r2
  801db4:	080485c0 	call	80485c <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
  801db8:	00800044 	movi	r2,1
  801dbc:	e0bff715 	stw	r2,-36(fp)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
  801dc0:	08050480 	call	805048 <vTaskExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  801dc4:	08040940 	call	804094 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
  801dc8:	0804ff40 	call	804ff4 <vTaskEnterCritical>
  801dcc:	e0bff817 	ldw	r2,-32(fp)
  801dd0:	10801103 	ldbu	r2,68(r2)
  801dd4:	10803fcc 	andi	r2,r2,255
  801dd8:	1080201c 	xori	r2,r2,128
  801ddc:	10bfe004 	addi	r2,r2,-128
  801de0:	10bfffd8 	cmpnei	r2,r2,-1
  801de4:	1000021e 	bne	r2,zero,801df0 <xQueuePeek+0xf4>
  801de8:	e0bff817 	ldw	r2,-32(fp)
  801dec:	10001105 	stb	zero,68(r2)
  801df0:	e0bff817 	ldw	r2,-32(fp)
  801df4:	10801143 	ldbu	r2,69(r2)
  801df8:	10803fcc 	andi	r2,r2,255
  801dfc:	1080201c 	xori	r2,r2,128
  801e00:	10bfe004 	addi	r2,r2,-128
  801e04:	10bfffd8 	cmpnei	r2,r2,-1
  801e08:	1000021e 	bne	r2,zero,801e14 <xQueuePeek+0x118>
  801e0c:	e0bff817 	ldw	r2,-32(fp)
  801e10:	10001145 	stb	zero,69(r2)
  801e14:	08050480 	call	805048 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  801e18:	e0ffff04 	addi	r3,fp,-4
  801e1c:	e0bffb04 	addi	r2,fp,-20
  801e20:	180b883a 	mov	r5,r3
  801e24:	1009883a 	mov	r4,r2
  801e28:	08048980 	call	804898 <xTaskCheckForTimeOut>
  801e2c:	1000131e 	bne	r2,zero,801e7c <xQueuePeek+0x180>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
  801e30:	e13ff817 	ldw	r4,-32(fp)
  801e34:	08024800 	call	802480 <prvIsQueueEmpty>
  801e38:	10000c26 	beq	r2,zero,801e6c <xQueuePeek+0x170>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  801e3c:	e0bff817 	ldw	r2,-32(fp)
  801e40:	10800904 	addi	r2,r2,36
  801e44:	e0ffff17 	ldw	r3,-4(fp)
  801e48:	180b883a 	mov	r5,r3
  801e4c:	1009883a 	mov	r4,r2
  801e50:	08045a00 	call	8045a0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
  801e54:	e13ff817 	ldw	r4,-32(fp)
  801e58:	080238c0 	call	80238c <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
  801e5c:	08040c00 	call	8040c0 <xTaskResumeAll>
  801e60:	103fb01e 	bne	r2,zero,801d24 <__alt_mem_onchip_memory2_0+0xff781d24>
				{
					portYIELD_WITHIN_API();
  801e64:	003b683a 	trap	0
  801e68:	003fae06 	br	801d24 <__alt_mem_onchip_memory2_0+0xff781d24>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
  801e6c:	e13ff817 	ldw	r4,-32(fp)
  801e70:	080238c0 	call	80238c <prvUnlockQueue>
				( void ) xTaskResumeAll();
  801e74:	08040c00 	call	8040c0 <xTaskResumeAll>
  801e78:	003faa06 	br	801d24 <__alt_mem_onchip_memory2_0+0xff781d24>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
  801e7c:	e13ff817 	ldw	r4,-32(fp)
  801e80:	080238c0 	call	80238c <prvUnlockQueue>
			( void ) xTaskResumeAll();
  801e84:	08040c00 	call	8040c0 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
  801e88:	e13ff817 	ldw	r4,-32(fp)
  801e8c:	08024800 	call	802480 <prvIsQueueEmpty>
  801e90:	103fa426 	beq	r2,zero,801d24 <__alt_mem_onchip_memory2_0+0xff781d24>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
  801e94:	0005883a 	mov	r2,zero
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
  801e98:	e037883a 	mov	sp,fp
  801e9c:	dfc00117 	ldw	ra,4(sp)
  801ea0:	df000017 	ldw	fp,0(sp)
  801ea4:	dec00204 	addi	sp,sp,8
  801ea8:	f800283a 	ret

00801eac <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
  801eac:	defff604 	addi	sp,sp,-40
  801eb0:	dfc00915 	stw	ra,36(sp)
  801eb4:	df000815 	stw	fp,32(sp)
  801eb8:	df000804 	addi	fp,sp,32
  801ebc:	e13ffd15 	stw	r4,-12(fp)
  801ec0:	e17ffe15 	stw	r5,-8(fp)
  801ec4:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
  801ec8:	e0bffd17 	ldw	r2,-12(fp)
  801ecc:	e0bff915 	stw	r2,-28(fp)
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  801ed0:	e03ffa15 	stw	zero,-24(fp)
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  801ed4:	e0bff917 	ldw	r2,-28(fp)
  801ed8:	10800e17 	ldw	r2,56(r2)
  801edc:	e0bffb15 	stw	r2,-20(fp)

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
  801ee0:	e0bffb17 	ldw	r2,-20(fp)
  801ee4:	10002326 	beq	r2,zero,801f74 <xQueueReceiveFromISR+0xc8>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
  801ee8:	e0bff917 	ldw	r2,-28(fp)
  801eec:	10801103 	ldbu	r2,68(r2)
  801ef0:	e0bffc05 	stb	r2,-16(fp)

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
  801ef4:	e17ffe17 	ldw	r5,-8(fp)
  801ef8:	e13ff917 	ldw	r4,-28(fp)
  801efc:	08022f00 	call	8022f0 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
  801f00:	e0bffb17 	ldw	r2,-20(fp)
  801f04:	10ffffc4 	addi	r3,r2,-1
  801f08:	e0bff917 	ldw	r2,-28(fp)
  801f0c:	10c00e15 	stw	r3,56(r2)

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
  801f10:	e0bffc07 	ldb	r2,-16(fp)
  801f14:	10bfffd8 	cmpnei	r2,r2,-1
  801f18:	10000e1e 	bne	r2,zero,801f54 <xQueueReceiveFromISR+0xa8>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  801f1c:	e0bff917 	ldw	r2,-28(fp)
  801f20:	10800417 	ldw	r2,16(r2)
  801f24:	10001026 	beq	r2,zero,801f68 <xQueueReceiveFromISR+0xbc>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  801f28:	e0bff917 	ldw	r2,-28(fp)
  801f2c:	10800404 	addi	r2,r2,16
  801f30:	1009883a 	mov	r4,r2
  801f34:	08046540 	call	804654 <xTaskRemoveFromEventList>
  801f38:	10000b26 	beq	r2,zero,801f68 <xQueueReceiveFromISR+0xbc>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
  801f3c:	e0bfff17 	ldw	r2,-4(fp)
  801f40:	10000926 	beq	r2,zero,801f68 <xQueueReceiveFromISR+0xbc>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
  801f44:	e0bfff17 	ldw	r2,-4(fp)
  801f48:	00c00044 	movi	r3,1
  801f4c:	10c00015 	stw	r3,0(r2)
  801f50:	00000506 	br	801f68 <xQueueReceiveFromISR+0xbc>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
  801f54:	e0bffc03 	ldbu	r2,-16(fp)
  801f58:	10800044 	addi	r2,r2,1
  801f5c:	1007883a 	mov	r3,r2
  801f60:	e0bff917 	ldw	r2,-28(fp)
  801f64:	10c01105 	stb	r3,68(r2)
			}

			xReturn = pdPASS;
  801f68:	00800044 	movi	r2,1
  801f6c:	e0bff815 	stw	r2,-32(fp)
  801f70:	00000106 	br	801f78 <xQueueReceiveFromISR+0xcc>
		}
		else
		{
			xReturn = pdFAIL;
  801f74:	e03ff815 	stw	zero,-32(fp)
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
  801f78:	e0bff817 	ldw	r2,-32(fp)
}
  801f7c:	e037883a 	mov	sp,fp
  801f80:	dfc00117 	ldw	ra,4(sp)
  801f84:	df000017 	ldw	fp,0(sp)
  801f88:	dec00204 	addi	sp,sp,8
  801f8c:	f800283a 	ret

00801f90 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
  801f90:	defff804 	addi	sp,sp,-32
  801f94:	dfc00715 	stw	ra,28(sp)
  801f98:	df000615 	stw	fp,24(sp)
  801f9c:	df000604 	addi	fp,sp,24
  801fa0:	e13ffe15 	stw	r4,-8(fp)
  801fa4:	e17fff15 	stw	r5,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
  801fa8:	e0bffe17 	ldw	r2,-8(fp)
  801fac:	e0bffb15 	stw	r2,-20(fp)
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  801fb0:	e03ffc15 	stw	zero,-16(fp)
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
  801fb4:	e0bffb17 	ldw	r2,-20(fp)
  801fb8:	10800e17 	ldw	r2,56(r2)
  801fbc:	10000c26 	beq	r2,zero,801ff0 <xQueuePeekFromISR+0x60>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
  801fc0:	e0bffb17 	ldw	r2,-20(fp)
  801fc4:	10800317 	ldw	r2,12(r2)
  801fc8:	e0bffd15 	stw	r2,-12(fp)
			prvCopyDataFromQueue( pxQueue, pvBuffer );
  801fcc:	e17fff17 	ldw	r5,-4(fp)
  801fd0:	e13ffb17 	ldw	r4,-20(fp)
  801fd4:	08022f00 	call	8022f0 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
  801fd8:	e0bffb17 	ldw	r2,-20(fp)
  801fdc:	e0fffd17 	ldw	r3,-12(fp)
  801fe0:	10c00315 	stw	r3,12(r2)

			xReturn = pdPASS;
  801fe4:	00800044 	movi	r2,1
  801fe8:	e0bffa15 	stw	r2,-24(fp)
  801fec:	00000106 	br	801ff4 <xQueuePeekFromISR+0x64>
		}
		else
		{
			xReturn = pdFAIL;
  801ff0:	e03ffa15 	stw	zero,-24(fp)
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
  801ff4:	e0bffa17 	ldw	r2,-24(fp)
}
  801ff8:	e037883a 	mov	sp,fp
  801ffc:	dfc00117 	ldw	ra,4(sp)
  802000:	df000017 	ldw	fp,0(sp)
  802004:	dec00204 	addi	sp,sp,8
  802008:	f800283a 	ret

0080200c <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
  80200c:	defffc04 	addi	sp,sp,-16
  802010:	dfc00315 	stw	ra,12(sp)
  802014:	df000215 	stw	fp,8(sp)
  802018:	df000204 	addi	fp,sp,8
  80201c:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
  802020:	0804ff40 	call	804ff4 <vTaskEnterCritical>
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
  802024:	e0bfff17 	ldw	r2,-4(fp)
  802028:	10800e17 	ldw	r2,56(r2)
  80202c:	e0bffe15 	stw	r2,-8(fp)
	}
	taskEXIT_CRITICAL();
  802030:	08050480 	call	805048 <vTaskExitCritical>

	return uxReturn;
  802034:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
  802038:	e037883a 	mov	sp,fp
  80203c:	dfc00117 	ldw	ra,4(sp)
  802040:	df000017 	ldw	fp,0(sp)
  802044:	dec00204 	addi	sp,sp,8
  802048:	f800283a 	ret

0080204c <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
  80204c:	defffb04 	addi	sp,sp,-20
  802050:	dfc00415 	stw	ra,16(sp)
  802054:	df000315 	stw	fp,12(sp)
  802058:	df000304 	addi	fp,sp,12
  80205c:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
  802060:	e0bfff17 	ldw	r2,-4(fp)
  802064:	e0bffd15 	stw	r2,-12(fp)

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
  802068:	0804ff40 	call	804ff4 <vTaskEnterCritical>
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
  80206c:	e0bffd17 	ldw	r2,-12(fp)
  802070:	10c00f17 	ldw	r3,60(r2)
  802074:	e0bffd17 	ldw	r2,-12(fp)
  802078:	10800e17 	ldw	r2,56(r2)
  80207c:	1885c83a 	sub	r2,r3,r2
  802080:	e0bffe15 	stw	r2,-8(fp)
	}
	taskEXIT_CRITICAL();
  802084:	08050480 	call	805048 <vTaskExitCritical>

	return uxReturn;
  802088:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
  80208c:	e037883a 	mov	sp,fp
  802090:	dfc00117 	ldw	ra,4(sp)
  802094:	df000017 	ldw	fp,0(sp)
  802098:	dec00204 	addi	sp,sp,8
  80209c:	f800283a 	ret

008020a0 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
  8020a0:	defffc04 	addi	sp,sp,-16
  8020a4:	df000315 	stw	fp,12(sp)
  8020a8:	df000304 	addi	fp,sp,12
  8020ac:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
  8020b0:	e0bfff17 	ldw	r2,-4(fp)
  8020b4:	e0bffd15 	stw	r2,-12(fp)

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
  8020b8:	e0bffd17 	ldw	r2,-12(fp)
  8020bc:	10800e17 	ldw	r2,56(r2)
  8020c0:	e0bffe15 	stw	r2,-8(fp)

	return uxReturn;
  8020c4:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
  8020c8:	e037883a 	mov	sp,fp
  8020cc:	df000017 	ldw	fp,0(sp)
  8020d0:	dec00104 	addi	sp,sp,4
  8020d4:	f800283a 	ret

008020d8 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
  8020d8:	defffc04 	addi	sp,sp,-16
  8020dc:	dfc00315 	stw	ra,12(sp)
  8020e0:	df000215 	stw	fp,8(sp)
  8020e4:	df000204 	addi	fp,sp,8
  8020e8:	e13fff15 	stw	r4,-4(fp)
Queue_t * const pxQueue = xQueue;
  8020ec:	e0bfff17 	ldw	r2,-4(fp)
  8020f0:	e0bffe15 	stw	r2,-8(fp)

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
  8020f4:	e13ffe17 	ldw	r4,-8(fp)
  8020f8:	08010dc0 	call	8010dc <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
  8020fc:	0001883a 	nop
  802100:	e037883a 	mov	sp,fp
  802104:	dfc00117 	ldw	ra,4(sp)
  802108:	df000017 	ldw	fp,0(sp)
  80210c:	dec00204 	addi	sp,sp,8
  802110:	f800283a 	ret

00802114 <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
	{
  802114:	defffd04 	addi	sp,sp,-12
  802118:	df000215 	stw	fp,8(sp)
  80211c:	df000204 	addi	fp,sp,8
  802120:	e13fff15 	stw	r4,-4(fp)
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
  802124:	e0bfff17 	ldw	r2,-4(fp)
  802128:	10800917 	ldw	r2,36(r2)
  80212c:	10000726 	beq	r2,zero,80214c <prvGetDisinheritPriorityAfterTimeout+0x38>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
  802130:	e0bfff17 	ldw	r2,-4(fp)
  802134:	10800c17 	ldw	r2,48(r2)
  802138:	10800017 	ldw	r2,0(r2)
  80213c:	00c00144 	movi	r3,5
  802140:	1885c83a 	sub	r2,r3,r2
  802144:	e0bffe15 	stw	r2,-8(fp)
  802148:	00000106 	br	802150 <prvGetDisinheritPriorityAfterTimeout+0x3c>
		}
		else
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
  80214c:	e03ffe15 	stw	zero,-8(fp)
		}

		return uxHighestPriorityOfWaitingTasks;
  802150:	e0bffe17 	ldw	r2,-8(fp)
	}
  802154:	e037883a 	mov	sp,fp
  802158:	df000017 	ldw	fp,0(sp)
  80215c:	dec00104 	addi	sp,sp,4
  802160:	f800283a 	ret

00802164 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
  802164:	defff904 	addi	sp,sp,-28
  802168:	dfc00615 	stw	ra,24(sp)
  80216c:	df000515 	stw	fp,20(sp)
  802170:	df000504 	addi	fp,sp,20
  802174:	e13ffd15 	stw	r4,-12(fp)
  802178:	e17ffe15 	stw	r5,-8(fp)
  80217c:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xReturn = pdFALSE;
  802180:	e03ffb15 	stw	zero,-20(fp)
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  802184:	e0bffd17 	ldw	r2,-12(fp)
  802188:	10800e17 	ldw	r2,56(r2)
  80218c:	e0bffc15 	stw	r2,-16(fp)

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
  802190:	e0bffd17 	ldw	r2,-12(fp)
  802194:	10801017 	ldw	r2,64(r2)
  802198:	10000b1e 	bne	r2,zero,8021c8 <prvCopyDataToQueue+0x64>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  80219c:	e0bffd17 	ldw	r2,-12(fp)
  8021a0:	10800017 	ldw	r2,0(r2)
  8021a4:	1000481e 	bne	r2,zero,8022c8 <prvCopyDataToQueue+0x164>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
  8021a8:	e0bffd17 	ldw	r2,-12(fp)
  8021ac:	10800217 	ldw	r2,8(r2)
  8021b0:	1009883a 	mov	r4,r2
  8021b4:	0804db80 	call	804db8 <xTaskPriorityDisinherit>
  8021b8:	e0bffb15 	stw	r2,-20(fp)
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
  8021bc:	e0bffd17 	ldw	r2,-12(fp)
  8021c0:	10000215 	stw	zero,8(r2)
  8021c4:	00004006 	br	8022c8 <prvCopyDataToQueue+0x164>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
  8021c8:	e0bfff17 	ldw	r2,-4(fp)
  8021cc:	1000191e 	bne	r2,zero,802234 <prvCopyDataToQueue+0xd0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
  8021d0:	e0bffd17 	ldw	r2,-12(fp)
  8021d4:	10c00117 	ldw	r3,4(r2)
  8021d8:	e0bffd17 	ldw	r2,-12(fp)
  8021dc:	10801017 	ldw	r2,64(r2)
  8021e0:	100d883a 	mov	r6,r2
  8021e4:	e17ffe17 	ldw	r5,-8(fp)
  8021e8:	1809883a 	mov	r4,r3
  8021ec:	08065900 	call	806590 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
  8021f0:	e0bffd17 	ldw	r2,-12(fp)
  8021f4:	10c00117 	ldw	r3,4(r2)
  8021f8:	e0bffd17 	ldw	r2,-12(fp)
  8021fc:	10801017 	ldw	r2,64(r2)
  802200:	1887883a 	add	r3,r3,r2
  802204:	e0bffd17 	ldw	r2,-12(fp)
  802208:	10c00115 	stw	r3,4(r2)
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
  80220c:	e0bffd17 	ldw	r2,-12(fp)
  802210:	10c00117 	ldw	r3,4(r2)
  802214:	e0bffd17 	ldw	r2,-12(fp)
  802218:	10800217 	ldw	r2,8(r2)
  80221c:	18802a36 	bltu	r3,r2,8022c8 <prvCopyDataToQueue+0x164>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
  802220:	e0bffd17 	ldw	r2,-12(fp)
  802224:	10c00017 	ldw	r3,0(r2)
  802228:	e0bffd17 	ldw	r2,-12(fp)
  80222c:	10c00115 	stw	r3,4(r2)
  802230:	00002506 	br	8022c8 <prvCopyDataToQueue+0x164>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
  802234:	e0bffd17 	ldw	r2,-12(fp)
  802238:	10c00317 	ldw	r3,12(r2)
  80223c:	e0bffd17 	ldw	r2,-12(fp)
  802240:	10801017 	ldw	r2,64(r2)
  802244:	100d883a 	mov	r6,r2
  802248:	e17ffe17 	ldw	r5,-8(fp)
  80224c:	1809883a 	mov	r4,r3
  802250:	08065900 	call	806590 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
  802254:	e0bffd17 	ldw	r2,-12(fp)
  802258:	10c00317 	ldw	r3,12(r2)
  80225c:	e0bffd17 	ldw	r2,-12(fp)
  802260:	10801017 	ldw	r2,64(r2)
  802264:	0085c83a 	sub	r2,zero,r2
  802268:	1887883a 	add	r3,r3,r2
  80226c:	e0bffd17 	ldw	r2,-12(fp)
  802270:	10c00315 	stw	r3,12(r2)
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
  802274:	e0bffd17 	ldw	r2,-12(fp)
  802278:	10c00317 	ldw	r3,12(r2)
  80227c:	e0bffd17 	ldw	r2,-12(fp)
  802280:	10800017 	ldw	r2,0(r2)
  802284:	1880082e 	bgeu	r3,r2,8022a8 <prvCopyDataToQueue+0x144>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
  802288:	e0bffd17 	ldw	r2,-12(fp)
  80228c:	10c00217 	ldw	r3,8(r2)
  802290:	e0bffd17 	ldw	r2,-12(fp)
  802294:	10801017 	ldw	r2,64(r2)
  802298:	0085c83a 	sub	r2,zero,r2
  80229c:	1887883a 	add	r3,r3,r2
  8022a0:	e0bffd17 	ldw	r2,-12(fp)
  8022a4:	10c00315 	stw	r3,12(r2)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
  8022a8:	e0bfff17 	ldw	r2,-4(fp)
  8022ac:	10800098 	cmpnei	r2,r2,2
  8022b0:	1000051e 	bne	r2,zero,8022c8 <prvCopyDataToQueue+0x164>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
  8022b4:	e0bffc17 	ldw	r2,-16(fp)
  8022b8:	10000326 	beq	r2,zero,8022c8 <prvCopyDataToQueue+0x164>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
  8022bc:	e0bffc17 	ldw	r2,-16(fp)
  8022c0:	10bfffc4 	addi	r2,r2,-1
  8022c4:	e0bffc15 	stw	r2,-16(fp)
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
  8022c8:	e0bffc17 	ldw	r2,-16(fp)
  8022cc:	10c00044 	addi	r3,r2,1
  8022d0:	e0bffd17 	ldw	r2,-12(fp)
  8022d4:	10c00e15 	stw	r3,56(r2)

	return xReturn;
  8022d8:	e0bffb17 	ldw	r2,-20(fp)
}
  8022dc:	e037883a 	mov	sp,fp
  8022e0:	dfc00117 	ldw	ra,4(sp)
  8022e4:	df000017 	ldw	fp,0(sp)
  8022e8:	dec00204 	addi	sp,sp,8
  8022ec:	f800283a 	ret

008022f0 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
  8022f0:	defffc04 	addi	sp,sp,-16
  8022f4:	dfc00315 	stw	ra,12(sp)
  8022f8:	df000215 	stw	fp,8(sp)
  8022fc:	df000204 	addi	fp,sp,8
  802300:	e13ffe15 	stw	r4,-8(fp)
  802304:	e17fff15 	stw	r5,-4(fp)
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
  802308:	e0bffe17 	ldw	r2,-8(fp)
  80230c:	10801017 	ldw	r2,64(r2)
  802310:	10001826 	beq	r2,zero,802374 <prvCopyDataFromQueue+0x84>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
  802314:	e0bffe17 	ldw	r2,-8(fp)
  802318:	10c00317 	ldw	r3,12(r2)
  80231c:	e0bffe17 	ldw	r2,-8(fp)
  802320:	10801017 	ldw	r2,64(r2)
  802324:	1887883a 	add	r3,r3,r2
  802328:	e0bffe17 	ldw	r2,-8(fp)
  80232c:	10c00315 	stw	r3,12(r2)
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
  802330:	e0bffe17 	ldw	r2,-8(fp)
  802334:	10c00317 	ldw	r3,12(r2)
  802338:	e0bffe17 	ldw	r2,-8(fp)
  80233c:	10800217 	ldw	r2,8(r2)
  802340:	18800436 	bltu	r3,r2,802354 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
  802344:	e0bffe17 	ldw	r2,-8(fp)
  802348:	10c00017 	ldw	r3,0(r2)
  80234c:	e0bffe17 	ldw	r2,-8(fp)
  802350:	10c00315 	stw	r3,12(r2)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
  802354:	e0bffe17 	ldw	r2,-8(fp)
  802358:	10c00317 	ldw	r3,12(r2)
  80235c:	e0bffe17 	ldw	r2,-8(fp)
  802360:	10801017 	ldw	r2,64(r2)
  802364:	100d883a 	mov	r6,r2
  802368:	180b883a 	mov	r5,r3
  80236c:	e13fff17 	ldw	r4,-4(fp)
  802370:	08065900 	call	806590 <memcpy>
	}
}
  802374:	0001883a 	nop
  802378:	e037883a 	mov	sp,fp
  80237c:	dfc00117 	ldw	ra,4(sp)
  802380:	df000017 	ldw	fp,0(sp)
  802384:	dec00204 	addi	sp,sp,8
  802388:	f800283a 	ret

0080238c <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
  80238c:	defffc04 	addi	sp,sp,-16
  802390:	dfc00315 	stw	ra,12(sp)
  802394:	df000215 	stw	fp,8(sp)
  802398:	df000204 	addi	fp,sp,8
  80239c:	e13fff15 	stw	r4,-4(fp)

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
  8023a0:	0804ff40 	call	804ff4 <vTaskEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
  8023a4:	e0bfff17 	ldw	r2,-4(fp)
  8023a8:	10801143 	ldbu	r2,69(r2)
  8023ac:	e0bffe05 	stb	r2,-8(fp)

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
  8023b0:	00000c06 	br	8023e4 <prvUnlockQueue+0x58>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  8023b4:	e0bfff17 	ldw	r2,-4(fp)
  8023b8:	10800917 	ldw	r2,36(r2)
  8023bc:	10000c26 	beq	r2,zero,8023f0 <prvUnlockQueue+0x64>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  8023c0:	e0bfff17 	ldw	r2,-4(fp)
  8023c4:	10800904 	addi	r2,r2,36
  8023c8:	1009883a 	mov	r4,r2
  8023cc:	08046540 	call	804654 <xTaskRemoveFromEventList>
  8023d0:	10000126 	beq	r2,zero,8023d8 <prvUnlockQueue+0x4c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
  8023d4:	08049780 	call	804978 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
  8023d8:	e0bffe03 	ldbu	r2,-8(fp)
  8023dc:	10bfffc4 	addi	r2,r2,-1
  8023e0:	e0bffe05 	stb	r2,-8(fp)
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
  8023e4:	e0bffe07 	ldb	r2,-8(fp)
  8023e8:	00bff216 	blt	zero,r2,8023b4 <__alt_mem_onchip_memory2_0+0xff7823b4>
  8023ec:	00000106 	br	8023f4 <prvUnlockQueue+0x68>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				else
				{
					break;
  8023f0:	0001883a 	nop
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
  8023f4:	e0bfff17 	ldw	r2,-4(fp)
  8023f8:	00ffffc4 	movi	r3,-1
  8023fc:	10c01145 	stb	r3,69(r2)
	}
	taskEXIT_CRITICAL();
  802400:	08050480 	call	805048 <vTaskExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
  802404:	0804ff40 	call	804ff4 <vTaskEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
  802408:	e0bfff17 	ldw	r2,-4(fp)
  80240c:	10801103 	ldbu	r2,68(r2)
  802410:	e0bffe45 	stb	r2,-7(fp)

		while( cRxLock > queueLOCKED_UNMODIFIED )
  802414:	00000c06 	br	802448 <prvUnlockQueue+0xbc>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  802418:	e0bfff17 	ldw	r2,-4(fp)
  80241c:	10800417 	ldw	r2,16(r2)
  802420:	10000c26 	beq	r2,zero,802454 <prvUnlockQueue+0xc8>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  802424:	e0bfff17 	ldw	r2,-4(fp)
  802428:	10800404 	addi	r2,r2,16
  80242c:	1009883a 	mov	r4,r2
  802430:	08046540 	call	804654 <xTaskRemoveFromEventList>
  802434:	10000126 	beq	r2,zero,80243c <prvUnlockQueue+0xb0>
				{
					vTaskMissedYield();
  802438:	08049780 	call	804978 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
  80243c:	e0bffe43 	ldbu	r2,-7(fp)
  802440:	10bfffc4 	addi	r2,r2,-1
  802444:	e0bffe45 	stb	r2,-7(fp)
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
  802448:	e0bffe47 	ldb	r2,-7(fp)
  80244c:	00bff216 	blt	zero,r2,802418 <__alt_mem_onchip_memory2_0+0xff782418>
  802450:	00000106 	br	802458 <prvUnlockQueue+0xcc>

				--cRxLock;
			}
			else
			{
				break;
  802454:	0001883a 	nop
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
  802458:	e0bfff17 	ldw	r2,-4(fp)
  80245c:	00ffffc4 	movi	r3,-1
  802460:	10c01105 	stb	r3,68(r2)
	}
	taskEXIT_CRITICAL();
  802464:	08050480 	call	805048 <vTaskExitCritical>
}
  802468:	0001883a 	nop
  80246c:	e037883a 	mov	sp,fp
  802470:	dfc00117 	ldw	ra,4(sp)
  802474:	df000017 	ldw	fp,0(sp)
  802478:	dec00204 	addi	sp,sp,8
  80247c:	f800283a 	ret

00802480 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
  802480:	defffc04 	addi	sp,sp,-16
  802484:	dfc00315 	stw	ra,12(sp)
  802488:	df000215 	stw	fp,8(sp)
  80248c:	df000204 	addi	fp,sp,8
  802490:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;

	taskENTER_CRITICAL();
  802494:	0804ff40 	call	804ff4 <vTaskEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
  802498:	e0bfff17 	ldw	r2,-4(fp)
  80249c:	10800e17 	ldw	r2,56(r2)
  8024a0:	1000031e 	bne	r2,zero,8024b0 <prvIsQueueEmpty+0x30>
		{
			xReturn = pdTRUE;
  8024a4:	00800044 	movi	r2,1
  8024a8:	e0bffe15 	stw	r2,-8(fp)
  8024ac:	00000106 	br	8024b4 <prvIsQueueEmpty+0x34>
		}
		else
		{
			xReturn = pdFALSE;
  8024b0:	e03ffe15 	stw	zero,-8(fp)
		}
	}
	taskEXIT_CRITICAL();
  8024b4:	08050480 	call	805048 <vTaskExitCritical>

	return xReturn;
  8024b8:	e0bffe17 	ldw	r2,-8(fp)
}
  8024bc:	e037883a 	mov	sp,fp
  8024c0:	dfc00117 	ldw	ra,4(sp)
  8024c4:	df000017 	ldw	fp,0(sp)
  8024c8:	dec00204 	addi	sp,sp,8
  8024cc:	f800283a 	ret

008024d0 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
  8024d0:	defffc04 	addi	sp,sp,-16
  8024d4:	df000315 	stw	fp,12(sp)
  8024d8:	df000304 	addi	fp,sp,12
  8024dc:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
  8024e0:	e0bfff17 	ldw	r2,-4(fp)
  8024e4:	e0bffe15 	stw	r2,-8(fp)

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
  8024e8:	e0bffe17 	ldw	r2,-8(fp)
  8024ec:	10800e17 	ldw	r2,56(r2)
  8024f0:	1000031e 	bne	r2,zero,802500 <xQueueIsQueueEmptyFromISR+0x30>
	{
		xReturn = pdTRUE;
  8024f4:	00800044 	movi	r2,1
  8024f8:	e0bffd15 	stw	r2,-12(fp)
  8024fc:	00000106 	br	802504 <xQueueIsQueueEmptyFromISR+0x34>
	}
	else
	{
		xReturn = pdFALSE;
  802500:	e03ffd15 	stw	zero,-12(fp)
	}

	return xReturn;
  802504:	e0bffd17 	ldw	r2,-12(fp)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
  802508:	e037883a 	mov	sp,fp
  80250c:	df000017 	ldw	fp,0(sp)
  802510:	dec00104 	addi	sp,sp,4
  802514:	f800283a 	ret

00802518 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
  802518:	defffc04 	addi	sp,sp,-16
  80251c:	dfc00315 	stw	ra,12(sp)
  802520:	df000215 	stw	fp,8(sp)
  802524:	df000204 	addi	fp,sp,8
  802528:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;

	taskENTER_CRITICAL();
  80252c:	0804ff40 	call	804ff4 <vTaskEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
  802530:	e0bfff17 	ldw	r2,-4(fp)
  802534:	10c00e17 	ldw	r3,56(r2)
  802538:	e0bfff17 	ldw	r2,-4(fp)
  80253c:	10800f17 	ldw	r2,60(r2)
  802540:	1880031e 	bne	r3,r2,802550 <prvIsQueueFull+0x38>
		{
			xReturn = pdTRUE;
  802544:	00800044 	movi	r2,1
  802548:	e0bffe15 	stw	r2,-8(fp)
  80254c:	00000106 	br	802554 <prvIsQueueFull+0x3c>
		}
		else
		{
			xReturn = pdFALSE;
  802550:	e03ffe15 	stw	zero,-8(fp)
		}
	}
	taskEXIT_CRITICAL();
  802554:	08050480 	call	805048 <vTaskExitCritical>

	return xReturn;
  802558:	e0bffe17 	ldw	r2,-8(fp)
}
  80255c:	e037883a 	mov	sp,fp
  802560:	dfc00117 	ldw	ra,4(sp)
  802564:	df000017 	ldw	fp,0(sp)
  802568:	dec00204 	addi	sp,sp,8
  80256c:	f800283a 	ret

00802570 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
  802570:	defffc04 	addi	sp,sp,-16
  802574:	df000315 	stw	fp,12(sp)
  802578:	df000304 	addi	fp,sp,12
  80257c:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
  802580:	e0bfff17 	ldw	r2,-4(fp)
  802584:	e0bffe15 	stw	r2,-8(fp)

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
  802588:	e0bffe17 	ldw	r2,-8(fp)
  80258c:	10c00e17 	ldw	r3,56(r2)
  802590:	e0bffe17 	ldw	r2,-8(fp)
  802594:	10800f17 	ldw	r2,60(r2)
  802598:	1880031e 	bne	r3,r2,8025a8 <xQueueIsQueueFullFromISR+0x38>
	{
		xReturn = pdTRUE;
  80259c:	00800044 	movi	r2,1
  8025a0:	e0bffd15 	stw	r2,-12(fp)
  8025a4:	00000106 	br	8025ac <xQueueIsQueueFullFromISR+0x3c>
	}
	else
	{
		xReturn = pdFALSE;
  8025a8:	e03ffd15 	stw	zero,-12(fp)
	}

	return xReturn;
  8025ac:	e0bffd17 	ldw	r2,-12(fp)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
  8025b0:	e037883a 	mov	sp,fp
  8025b4:	df000017 	ldw	fp,0(sp)
  8025b8:	dec00104 	addi	sp,sp,4
  8025bc:	f800283a 	ret

008025c0 <xStreamBufferGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
	{
  8025c0:	defff804 	addi	sp,sp,-32
  8025c4:	dfc00715 	stw	ra,28(sp)
  8025c8:	df000615 	stw	fp,24(sp)
  8025cc:	df000604 	addi	fp,sp,24
  8025d0:	e13ffd15 	stw	r4,-12(fp)
  8025d4:	e17ffe15 	stw	r5,-8(fp)
  8025d8:	e1bfff15 	stw	r6,-4(fp)

		/* In case the stream buffer is going to be used as a message buffer
		(that is, it will hold discrete messages with a little meta data that
		says how big the next message is) check the buffer will be large enough
		to hold at least one message. */
		if( xIsMessageBuffer == pdTRUE )
  8025dc:	e0bfff17 	ldw	r2,-4(fp)
  8025e0:	10800058 	cmpnei	r2,r2,1
  8025e4:	1000031e 	bne	r2,zero,8025f4 <xStreamBufferGenericCreate+0x34>
		{
			/* Is a message buffer but not statically allocated. */
			ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
  8025e8:	00800044 	movi	r2,1
  8025ec:	e0bffb05 	stb	r2,-20(fp)
  8025f0:	00000106 	br	8025f8 <xStreamBufferGenericCreate+0x38>
			configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
		}
		else
		{
			/* Not a message buffer and not statically allocated. */
			ucFlags = 0;
  8025f4:	e03ffb05 	stb	zero,-20(fp)
		}
		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

		/* A trigger level of 0 would cause a waiting task to unblock even when
		the buffer was empty. */
		if( xTriggerLevelBytes == ( size_t ) 0 )
  8025f8:	e0bffe17 	ldw	r2,-8(fp)
  8025fc:	1000021e 	bne	r2,zero,802608 <xStreamBufferGenericCreate+0x48>
		{
			xTriggerLevelBytes = ( size_t ) 1;
  802600:	00800044 	movi	r2,1
  802604:	e0bffe15 	stw	r2,-8(fp)
		and the buffer follows immediately after.  The requested size is
		incremented so the free space is returned as the user would expect -
		this is a quirk of the implementation that means otherwise the free
		space would be reported as one byte smaller than would be logically
		expected. */
		xBufferSizeBytes++;
  802608:	e0bffd17 	ldw	r2,-12(fp)
  80260c:	10800044 	addi	r2,r2,1
  802610:	e0bffd15 	stw	r2,-12(fp)
		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
  802614:	e0bffd17 	ldw	r2,-12(fp)
  802618:	10800804 	addi	r2,r2,32
  80261c:	1009883a 	mov	r4,r2
  802620:	080101c0 	call	80101c <pvPortMalloc>
  802624:	e0bffc15 	stw	r2,-16(fp)

		if( pucAllocatedMemory != NULL )
  802628:	e0bffc17 	ldw	r2,-16(fp)
  80262c:	10000926 	beq	r2,zero,802654 <xStreamBufferGenericCreate+0x94>
		{
			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
  802630:	e0bffc17 	ldw	r2,-16(fp)
  802634:	10c00804 	addi	r3,r2,32
  802638:	e0bffb03 	ldbu	r2,-20(fp)
  80263c:	d8800015 	stw	r2,0(sp)
  802640:	e1fffe17 	ldw	r7,-8(fp)
  802644:	e1bffd17 	ldw	r6,-12(fp)
  802648:	180b883a 	mov	r5,r3
  80264c:	e13ffc17 	ldw	r4,-16(fp)
  802650:	08033e40 	call	8033e4 <prvInitialiseNewStreamBuffer>
		else
		{
			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
		}

		return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
  802654:	e0bffc17 	ldw	r2,-16(fp)
	}
  802658:	e037883a 	mov	sp,fp
  80265c:	dfc00117 	ldw	ra,4(sp)
  802660:	df000017 	ldw	fp,0(sp)
  802664:	dec00204 	addi	sp,sp,8
  802668:	f800283a 	ret

0080266c <vStreamBufferDelete>:

#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
  80266c:	defffc04 	addi	sp,sp,-16
  802670:	dfc00315 	stw	ra,12(sp)
  802674:	df000215 	stw	fp,8(sp)
  802678:	df000204 	addi	fp,sp,8
  80267c:	e13fff15 	stw	r4,-4(fp)
StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
  802680:	e0bfff17 	ldw	r2,-4(fp)
  802684:	e0bffe15 	stw	r2,-8(fp)

	configASSERT( pxStreamBuffer );

	traceSTREAM_BUFFER_DELETE( xStreamBuffer );

	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
  802688:	e0bffe17 	ldw	r2,-8(fp)
  80268c:	10800703 	ldbu	r2,28(r2)
  802690:	10803fcc 	andi	r2,r2,255
  802694:	1080008c 	andi	r2,r2,2
  802698:	1000031e 	bne	r2,zero,8026a8 <vStreamBufferDelete+0x3c>
	{
		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
		{
			/* Both the structure and the buffer were allocated using a single call
			to pvPortMalloc(), hence only one call to vPortFree() is required. */
			vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
  80269c:	e13ffe17 	ldw	r4,-8(fp)
  8026a0:	08010dc0 	call	8010dc <vPortFree>
	{
		/* The structure and buffer were not allocated dynamically and cannot be
		freed - just scrub the structure so future use will assert. */
		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
	}
}
  8026a4:	00000406 	br	8026b8 <vStreamBufferDelete+0x4c>
	}
	else
	{
		/* The structure and buffer were not allocated dynamically and cannot be
		freed - just scrub the structure so future use will assert. */
		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
  8026a8:	01800804 	movi	r6,32
  8026ac:	000b883a 	mov	r5,zero
  8026b0:	e13ffe17 	ldw	r4,-8(fp)
  8026b4:	08065b80 	call	8065b8 <memset>
	}
}
  8026b8:	0001883a 	nop
  8026bc:	e037883a 	mov	sp,fp
  8026c0:	dfc00117 	ldw	ra,4(sp)
  8026c4:	df000017 	ldw	fp,0(sp)
  8026c8:	dec00204 	addi	sp,sp,8
  8026cc:	f800283a 	ret

008026d0 <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
  8026d0:	defffa04 	addi	sp,sp,-24
  8026d4:	dfc00515 	stw	ra,20(sp)
  8026d8:	df000415 	stw	fp,16(sp)
  8026dc:	df000404 	addi	fp,sp,16
  8026e0:	e13fff15 	stw	r4,-4(fp)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
  8026e4:	e0bfff17 	ldw	r2,-4(fp)
  8026e8:	e0bffe15 	stw	r2,-8(fp)
BaseType_t xReturn = pdFAIL;
  8026ec:	e03ffd15 	stw	zero,-12(fp)
		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
	}
	#endif

	/* Can only reset a message buffer if there are no tasks blocked on it. */
	taskENTER_CRITICAL();
  8026f0:	0804ff40 	call	804ff4 <vTaskEnterCritical>
	{
		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
  8026f4:	e0bffe17 	ldw	r2,-8(fp)
  8026f8:	10800417 	ldw	r2,16(r2)
  8026fc:	1000141e 	bne	r2,zero,802750 <xStreamBufferReset+0x80>
		{
			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
  802700:	e0bffe17 	ldw	r2,-8(fp)
  802704:	10800517 	ldw	r2,20(r2)
  802708:	1000111e 	bne	r2,zero,802750 <xStreamBufferReset+0x80>
			{
				prvInitialiseNewStreamBuffer( pxStreamBuffer,
  80270c:	e0bffe17 	ldw	r2,-8(fp)
  802710:	10c00617 	ldw	r3,24(r2)
  802714:	e0bffe17 	ldw	r2,-8(fp)
  802718:	11000217 	ldw	r4,8(r2)
  80271c:	e0bffe17 	ldw	r2,-8(fp)
  802720:	11400317 	ldw	r5,12(r2)
											  pxStreamBuffer->pucBuffer,
											  pxStreamBuffer->xLength,
											  pxStreamBuffer->xTriggerLevelBytes,
											  pxStreamBuffer->ucFlags );
  802724:	e0bffe17 	ldw	r2,-8(fp)
  802728:	10800703 	ldbu	r2,28(r2)
	{
		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
		{
			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
			{
				prvInitialiseNewStreamBuffer( pxStreamBuffer,
  80272c:	10803fcc 	andi	r2,r2,255
  802730:	d8800015 	stw	r2,0(sp)
  802734:	280f883a 	mov	r7,r5
  802738:	200d883a 	mov	r6,r4
  80273c:	180b883a 	mov	r5,r3
  802740:	e13ffe17 	ldw	r4,-8(fp)
  802744:	08033e40 	call	8033e4 <prvInitialiseNewStreamBuffer>
											  pxStreamBuffer->pucBuffer,
											  pxStreamBuffer->xLength,
											  pxStreamBuffer->xTriggerLevelBytes,
											  pxStreamBuffer->ucFlags );
				xReturn = pdPASS;
  802748:	00800044 	movi	r2,1
  80274c:	e0bffd15 	stw	r2,-12(fp)

				traceSTREAM_BUFFER_RESET( xStreamBuffer );
			}
		}
	}
	taskEXIT_CRITICAL();
  802750:	08050480 	call	805048 <vTaskExitCritical>

	return xReturn;
  802754:	e0bffd17 	ldw	r2,-12(fp)
}
  802758:	e037883a 	mov	sp,fp
  80275c:	dfc00117 	ldw	ra,4(sp)
  802760:	df000017 	ldw	fp,0(sp)
  802764:	dec00204 	addi	sp,sp,8
  802768:	f800283a 	ret

0080276c <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
{
  80276c:	defffb04 	addi	sp,sp,-20
  802770:	df000415 	stw	fp,16(sp)
  802774:	df000404 	addi	fp,sp,16
  802778:	e13ffe15 	stw	r4,-8(fp)
  80277c:	e17fff15 	stw	r5,-4(fp)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
  802780:	e0bffe17 	ldw	r2,-8(fp)
  802784:	e0bffd15 	stw	r2,-12(fp)
BaseType_t xReturn;

	configASSERT( pxStreamBuffer );

	/* It is not valid for the trigger level to be 0. */
	if( xTriggerLevel == ( size_t ) 0 )
  802788:	e0bfff17 	ldw	r2,-4(fp)
  80278c:	1000021e 	bne	r2,zero,802798 <xStreamBufferSetTriggerLevel+0x2c>
	{
		xTriggerLevel = ( size_t ) 1;
  802790:	00800044 	movi	r2,1
  802794:	e0bfff15 	stw	r2,-4(fp)
	}

	/* The trigger level is the number of bytes that must be in the stream
	buffer before a task that is waiting for data is unblocked. */
	if( xTriggerLevel <= pxStreamBuffer->xLength )
  802798:	e0bffd17 	ldw	r2,-12(fp)
  80279c:	10c00217 	ldw	r3,8(r2)
  8027a0:	e0bfff17 	ldw	r2,-4(fp)
  8027a4:	18800636 	bltu	r3,r2,8027c0 <xStreamBufferSetTriggerLevel+0x54>
	{
		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
  8027a8:	e0bffd17 	ldw	r2,-12(fp)
  8027ac:	e0ffff17 	ldw	r3,-4(fp)
  8027b0:	10c00315 	stw	r3,12(r2)
		xReturn = pdPASS;
  8027b4:	00800044 	movi	r2,1
  8027b8:	e0bffc15 	stw	r2,-16(fp)
  8027bc:	00000106 	br	8027c4 <xStreamBufferSetTriggerLevel+0x58>
	}
	else
	{
		xReturn = pdFALSE;
  8027c0:	e03ffc15 	stw	zero,-16(fp)
	}

	return xReturn;
  8027c4:	e0bffc17 	ldw	r2,-16(fp)
}
  8027c8:	e037883a 	mov	sp,fp
  8027cc:	df000017 	ldw	fp,0(sp)
  8027d0:	dec00104 	addi	sp,sp,4
  8027d4:	f800283a 	ret

008027d8 <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
  8027d8:	defffc04 	addi	sp,sp,-16
  8027dc:	df000315 	stw	fp,12(sp)
  8027e0:	df000304 	addi	fp,sp,12
  8027e4:	e13fff15 	stw	r4,-4(fp)
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
  8027e8:	e0bfff17 	ldw	r2,-4(fp)
  8027ec:	e0bffe15 	stw	r2,-8(fp)
size_t xSpace;

	configASSERT( pxStreamBuffer );

	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
  8027f0:	e0bffe17 	ldw	r2,-8(fp)
  8027f4:	10c00217 	ldw	r3,8(r2)
  8027f8:	e0bffe17 	ldw	r2,-8(fp)
  8027fc:	10800017 	ldw	r2,0(r2)
  802800:	1885883a 	add	r2,r3,r2
  802804:	e0bffd15 	stw	r2,-12(fp)
	xSpace -= pxStreamBuffer->xHead;
  802808:	e0bffe17 	ldw	r2,-8(fp)
  80280c:	10800117 	ldw	r2,4(r2)
  802810:	e0fffd17 	ldw	r3,-12(fp)
  802814:	1885c83a 	sub	r2,r3,r2
  802818:	e0bffd15 	stw	r2,-12(fp)
	xSpace -= ( size_t ) 1;
  80281c:	e0bffd17 	ldw	r2,-12(fp)
  802820:	10bfffc4 	addi	r2,r2,-1
  802824:	e0bffd15 	stw	r2,-12(fp)

	if( xSpace >= pxStreamBuffer->xLength )
  802828:	e0bffe17 	ldw	r2,-8(fp)
  80282c:	10800217 	ldw	r2,8(r2)
  802830:	e0fffd17 	ldw	r3,-12(fp)
  802834:	18800536 	bltu	r3,r2,80284c <xStreamBufferSpacesAvailable+0x74>
	{
		xSpace -= pxStreamBuffer->xLength;
  802838:	e0bffe17 	ldw	r2,-8(fp)
  80283c:	10800217 	ldw	r2,8(r2)
  802840:	e0fffd17 	ldw	r3,-12(fp)
  802844:	1885c83a 	sub	r2,r3,r2
  802848:	e0bffd15 	stw	r2,-12(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xSpace;
  80284c:	e0bffd17 	ldw	r2,-12(fp)
}
  802850:	e037883a 	mov	sp,fp
  802854:	df000017 	ldw	fp,0(sp)
  802858:	dec00104 	addi	sp,sp,4
  80285c:	f800283a 	ret

00802860 <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
  802860:	defffb04 	addi	sp,sp,-20
  802864:	dfc00415 	stw	ra,16(sp)
  802868:	df000315 	stw	fp,12(sp)
  80286c:	df000304 	addi	fp,sp,12
  802870:	e13fff15 	stw	r4,-4(fp)
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
  802874:	e0bfff17 	ldw	r2,-4(fp)
  802878:	e0bffd15 	stw	r2,-12(fp)
size_t xReturn;

	configASSERT( pxStreamBuffer );

	xReturn = prvBytesInBuffer( pxStreamBuffer );
  80287c:	e13ffd17 	ldw	r4,-12(fp)
  802880:	08033700 	call	803370 <prvBytesInBuffer>
  802884:	e0bffe15 	stw	r2,-8(fp)
	return xReturn;
  802888:	e0bffe17 	ldw	r2,-8(fp)
}
  80288c:	e037883a 	mov	sp,fp
  802890:	dfc00117 	ldw	ra,4(sp)
  802894:	df000017 	ldw	fp,0(sp)
  802898:	dec00204 	addi	sp,sp,8
  80289c:	f800283a 	ret

008028a0 <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
						  const void *pvTxData,
						  size_t xDataLengthBytes,
						  TickType_t xTicksToWait )
{
  8028a0:	defff304 	addi	sp,sp,-52
  8028a4:	dfc00c15 	stw	ra,48(sp)
  8028a8:	df000b15 	stw	fp,44(sp)
  8028ac:	df000b04 	addi	fp,sp,44
  8028b0:	e13ffc15 	stw	r4,-16(fp)
  8028b4:	e17ffd15 	stw	r5,-12(fp)
  8028b8:	e1bffe15 	stw	r6,-8(fp)
  8028bc:	e1ffff15 	stw	r7,-4(fp)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
  8028c0:	e0bffc17 	ldw	r2,-16(fp)
  8028c4:	e0bff815 	stw	r2,-32(fp)
size_t xReturn, xSpace = 0;
  8028c8:	e03ff615 	stw	zero,-40(fp)
size_t xRequiredSpace = xDataLengthBytes;
  8028cc:	e0bffe17 	ldw	r2,-8(fp)
  8028d0:	e0bff715 	stw	r2,-36(fp)

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
  8028d4:	e0bff817 	ldw	r2,-32(fp)
  8028d8:	10800703 	ldbu	r2,28(r2)
  8028dc:	10803fcc 	andi	r2,r2,255
  8028e0:	1080004c 	andi	r2,r2,1
  8028e4:	10000326 	beq	r2,zero,8028f4 <xStreamBufferSend+0x54>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
  8028e8:	e0bff717 	ldw	r2,-36(fp)
  8028ec:	10800104 	addi	r2,r2,4
  8028f0:	e0bff715 	stw	r2,-36(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xTicksToWait != ( TickType_t ) 0 )
  8028f4:	e0bfff17 	ldw	r2,-4(fp)
  8028f8:	10002226 	beq	r2,zero,802984 <xStreamBufferSend+0xe4>
	{
		vTaskSetTimeOutState( &xTimeOut );
  8028fc:	e0bffa04 	addi	r2,fp,-24
  802900:	1009883a 	mov	r4,r2
  802904:	08048100 	call	804810 <vTaskSetTimeOutState>

		do
		{
			/* Wait until the required number of bytes are free in the message
			buffer. */
			taskENTER_CRITICAL();
  802908:	0804ff40 	call	804ff4 <vTaskEnterCritical>
			{
				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
  80290c:	e13ff817 	ldw	r4,-32(fp)
  802910:	08027d80 	call	8027d8 <xStreamBufferSpacesAvailable>
  802914:	e0bff615 	stw	r2,-40(fp)

				if( xSpace < xRequiredSpace )
  802918:	e0fff617 	ldw	r3,-40(fp)
  80291c:	e0bff717 	ldw	r2,-36(fp)
  802920:	1880072e 	bgeu	r3,r2,802940 <xStreamBufferSend+0xa0>
				{
					/* Clear notification state as going to wait for space. */
					( void ) xTaskNotifyStateClear( NULL );
  802924:	0009883a 	mov	r4,zero
  802928:	08057780 	call	805778 <xTaskNotifyStateClear>

					/* Should only be one writer. */
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
  80292c:	0804c500 	call	804c50 <xTaskGetCurrentTaskHandle>
  802930:	1007883a 	mov	r3,r2
  802934:	e0bff817 	ldw	r2,-32(fp)
  802938:	10c00515 	stw	r3,20(r2)
  80293c:	00000206 	br	802948 <xStreamBufferSend+0xa8>
				}
				else
				{
					taskEXIT_CRITICAL();
  802940:	08050480 	call	805048 <vTaskExitCritical>
					break;
  802944:	00000f06 	br	802984 <xStreamBufferSend+0xe4>
				}
			}
			taskEXIT_CRITICAL();
  802948:	08050480 	call	805048 <vTaskExitCritical>

			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
  80294c:	e0bfff17 	ldw	r2,-4(fp)
  802950:	100f883a 	mov	r7,r2
  802954:	000d883a 	mov	r6,zero
  802958:	000b883a 	mov	r5,zero
  80295c:	0009883a 	mov	r4,zero
  802960:	08051d40 	call	8051d4 <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToSend = NULL;
  802964:	e0bff817 	ldw	r2,-32(fp)
  802968:	10000515 	stw	zero,20(r2)

		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
  80296c:	e0ffff04 	addi	r3,fp,-4
  802970:	e0bffa04 	addi	r2,fp,-24
  802974:	180b883a 	mov	r5,r3
  802978:	1009883a 	mov	r4,r2
  80297c:	08048980 	call	804898 <xTaskCheckForTimeOut>
  802980:	103fe126 	beq	r2,zero,802908 <__alt_mem_onchip_memory2_0+0xff782908>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xSpace == ( size_t ) 0 )
  802984:	e0bff617 	ldw	r2,-40(fp)
  802988:	1000031e 	bne	r2,zero,802998 <xStreamBufferSend+0xf8>
	{
		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
  80298c:	e13ff817 	ldw	r4,-32(fp)
  802990:	08027d80 	call	8027d8 <xStreamBufferSpacesAvailable>
  802994:	e0bff615 	stw	r2,-40(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
  802998:	e0bff717 	ldw	r2,-36(fp)
  80299c:	d8800015 	stw	r2,0(sp)
  8029a0:	e1fff617 	ldw	r7,-40(fp)
  8029a4:	e1bffe17 	ldw	r6,-8(fp)
  8029a8:	e17ffd17 	ldw	r5,-12(fp)
  8029ac:	e13ff817 	ldw	r4,-32(fp)
  8029b0:	0802b180 	call	802b18 <prvWriteMessageToBuffer>
  8029b4:	e0bff915 	stw	r2,-28(fp)

	if( xReturn > ( size_t ) 0 )
  8029b8:	e0bff917 	ldw	r2,-28(fp)
  8029bc:	10001426 	beq	r2,zero,802a10 <xStreamBufferSend+0x170>
	{
		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
  8029c0:	e13ff817 	ldw	r4,-32(fp)
  8029c4:	08033700 	call	803370 <prvBytesInBuffer>
  8029c8:	1007883a 	mov	r3,r2
  8029cc:	e0bff817 	ldw	r2,-32(fp)
  8029d0:	10800317 	ldw	r2,12(r2)
  8029d4:	18800e36 	bltu	r3,r2,802a10 <xStreamBufferSend+0x170>
		{
			sbSEND_COMPLETED( pxStreamBuffer );
  8029d8:	08040940 	call	804094 <vTaskSuspendAll>
  8029dc:	e0bff817 	ldw	r2,-32(fp)
  8029e0:	10800417 	ldw	r2,16(r2)
  8029e4:	10000926 	beq	r2,zero,802a0c <xStreamBufferSend+0x16c>
  8029e8:	e0bff817 	ldw	r2,-32(fp)
  8029ec:	10800417 	ldw	r2,16(r2)
  8029f0:	000f883a 	mov	r7,zero
  8029f4:	000d883a 	mov	r6,zero
  8029f8:	000b883a 	mov	r5,zero
  8029fc:	1009883a 	mov	r4,r2
  802a00:	08052c80 	call	8052c8 <xTaskGenericNotify>
  802a04:	e0bff817 	ldw	r2,-32(fp)
  802a08:	10000415 	stw	zero,16(r2)
  802a0c:	08040c00 	call	8040c0 <xTaskResumeAll>
	{
		mtCOVERAGE_TEST_MARKER();
		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
	}

	return xReturn;
  802a10:	e0bff917 	ldw	r2,-28(fp)
}
  802a14:	e037883a 	mov	sp,fp
  802a18:	dfc00117 	ldw	ra,4(sp)
  802a1c:	df000017 	ldw	fp,0(sp)
  802a20:	dec00204 	addi	sp,sp,8
  802a24:	f800283a 	ret

00802a28 <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
								 const void *pvTxData,
								 size_t xDataLengthBytes,
								 BaseType_t * const pxHigherPriorityTaskWoken )
{
  802a28:	defff404 	addi	sp,sp,-48
  802a2c:	dfc00b15 	stw	ra,44(sp)
  802a30:	df000a15 	stw	fp,40(sp)
  802a34:	df000a04 	addi	fp,sp,40
  802a38:	e13ffc15 	stw	r4,-16(fp)
  802a3c:	e17ffd15 	stw	r5,-12(fp)
  802a40:	e1bffe15 	stw	r6,-8(fp)
  802a44:	e1ffff15 	stw	r7,-4(fp)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
  802a48:	e0bffc17 	ldw	r2,-16(fp)
  802a4c:	e0bff815 	stw	r2,-32(fp)
size_t xReturn, xSpace;
size_t xRequiredSpace = xDataLengthBytes;
  802a50:	e0bffe17 	ldw	r2,-8(fp)
  802a54:	e0bff715 	stw	r2,-36(fp)

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
  802a58:	e0bff817 	ldw	r2,-32(fp)
  802a5c:	10800703 	ldbu	r2,28(r2)
  802a60:	10803fcc 	andi	r2,r2,255
  802a64:	1080004c 	andi	r2,r2,1
  802a68:	10000326 	beq	r2,zero,802a78 <xStreamBufferSendFromISR+0x50>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
  802a6c:	e0bff717 	ldw	r2,-36(fp)
  802a70:	10800104 	addi	r2,r2,4
  802a74:	e0bff715 	stw	r2,-36(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
  802a78:	e13ff817 	ldw	r4,-32(fp)
  802a7c:	08027d80 	call	8027d8 <xStreamBufferSpacesAvailable>
  802a80:	e0bff915 	stw	r2,-28(fp)
	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
  802a84:	e0bff717 	ldw	r2,-36(fp)
  802a88:	d8800015 	stw	r2,0(sp)
  802a8c:	e1fff917 	ldw	r7,-28(fp)
  802a90:	e1bffe17 	ldw	r6,-8(fp)
  802a94:	e17ffd17 	ldw	r5,-12(fp)
  802a98:	e13ff817 	ldw	r4,-32(fp)
  802a9c:	0802b180 	call	802b18 <prvWriteMessageToBuffer>
  802aa0:	e0bffa15 	stw	r2,-24(fp)

	if( xReturn > ( size_t ) 0 )
  802aa4:	e0bffa17 	ldw	r2,-24(fp)
  802aa8:	10001526 	beq	r2,zero,802b00 <xStreamBufferSendFromISR+0xd8>
	{
		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
  802aac:	e13ff817 	ldw	r4,-32(fp)
  802ab0:	08033700 	call	803370 <prvBytesInBuffer>
  802ab4:	1007883a 	mov	r3,r2
  802ab8:	e0bff817 	ldw	r2,-32(fp)
  802abc:	10800317 	ldw	r2,12(r2)
  802ac0:	18800f36 	bltu	r3,r2,802b00 <xStreamBufferSendFromISR+0xd8>
		{
			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
  802ac4:	e03ffb15 	stw	zero,-20(fp)
  802ac8:	e0bff817 	ldw	r2,-32(fp)
  802acc:	10800417 	ldw	r2,16(r2)
  802ad0:	10000b26 	beq	r2,zero,802b00 <xStreamBufferSendFromISR+0xd8>
  802ad4:	e0bff817 	ldw	r2,-32(fp)
  802ad8:	10c00417 	ldw	r3,16(r2)
  802adc:	e0bfff17 	ldw	r2,-4(fp)
  802ae0:	d8800015 	stw	r2,0(sp)
  802ae4:	000f883a 	mov	r7,zero
  802ae8:	000d883a 	mov	r6,zero
  802aec:	000b883a 	mov	r5,zero
  802af0:	1809883a 	mov	r4,r3
  802af4:	08054740 	call	805474 <xTaskGenericNotifyFromISR>
  802af8:	e0bff817 	ldw	r2,-32(fp)
  802afc:	10000415 	stw	zero,16(r2)
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

	return xReturn;
  802b00:	e0bffa17 	ldw	r2,-24(fp)
}
  802b04:	e037883a 	mov	sp,fp
  802b08:	dfc00117 	ldw	ra,4(sp)
  802b0c:	df000017 	ldw	fp,0(sp)
  802b10:	dec00204 	addi	sp,sp,8
  802b14:	f800283a 	ret

00802b18 <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
									   const void * pvTxData,
									   size_t xDataLengthBytes,
									   size_t xSpace,
									   size_t xRequiredSpace )
{
  802b18:	defff804 	addi	sp,sp,-32
  802b1c:	dfc00715 	stw	ra,28(sp)
  802b20:	df000615 	stw	fp,24(sp)
  802b24:	df000604 	addi	fp,sp,24
  802b28:	e13ffc15 	stw	r4,-16(fp)
  802b2c:	e17ffd15 	stw	r5,-12(fp)
  802b30:	e1bffe15 	stw	r6,-8(fp)
  802b34:	e1ffff15 	stw	r7,-4(fp)
	BaseType_t xShouldWrite;
	size_t xReturn;

	if( xSpace == ( size_t ) 0 )
  802b38:	e0bfff17 	ldw	r2,-4(fp)
  802b3c:	1000021e 	bne	r2,zero,802b48 <prvWriteMessageToBuffer+0x30>
	{
		/* Doesn't matter if this is a stream buffer or a message buffer, there
		is no space to write. */
		xShouldWrite = pdFALSE;
  802b40:	e03ffa15 	stw	zero,-24(fp)
  802b44:	00001906 	br	802bac <prvWriteMessageToBuffer+0x94>
	}
	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
  802b48:	e0bffc17 	ldw	r2,-16(fp)
  802b4c:	10800703 	ldbu	r2,28(r2)
  802b50:	10803fcc 	andi	r2,r2,255
  802b54:	1080004c 	andi	r2,r2,1
  802b58:	1000081e 	bne	r2,zero,802b7c <prvWriteMessageToBuffer+0x64>
	{
		/* This is a stream buffer, as opposed to a message buffer, so writing a
		stream of bytes rather than discrete messages.  Write as many bytes as
		possible. */
		xShouldWrite = pdTRUE;
  802b5c:	00800044 	movi	r2,1
  802b60:	e0bffa15 	stw	r2,-24(fp)
		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
  802b64:	e0fffe17 	ldw	r3,-8(fp)
  802b68:	e0bfff17 	ldw	r2,-4(fp)
  802b6c:	1880012e 	bgeu	r3,r2,802b74 <prvWriteMessageToBuffer+0x5c>
  802b70:	1805883a 	mov	r2,r3
  802b74:	e0bffe15 	stw	r2,-8(fp)
  802b78:	00000c06 	br	802bac <prvWriteMessageToBuffer+0x94>
	}
	else if( xSpace >= xRequiredSpace )
  802b7c:	e0ffff17 	ldw	r3,-4(fp)
  802b80:	e0800217 	ldw	r2,8(fp)
  802b84:	18800836 	bltu	r3,r2,802ba8 <prvWriteMessageToBuffer+0x90>
	{
		/* This is a message buffer, as opposed to a stream buffer, and there
		is enough space to write both the message length and the message itself
		into the buffer.  Start by writing the length of the data, the data
		itself will be written later in this function. */
		xShouldWrite = pdTRUE;
  802b88:	00800044 	movi	r2,1
  802b8c:	e0bffa15 	stw	r2,-24(fp)
		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
  802b90:	e0bffe04 	addi	r2,fp,-8
  802b94:	01800104 	movi	r6,4
  802b98:	100b883a 	mov	r5,r2
  802b9c:	e13ffc17 	ldw	r4,-16(fp)
  802ba0:	08031680 	call	803168 <prvWriteBytesToBuffer>
  802ba4:	00000106 	br	802bac <prvWriteMessageToBuffer+0x94>
	}
	else
	{
		/* There is space available, but not enough space. */
		xShouldWrite = pdFALSE;
  802ba8:	e03ffa15 	stw	zero,-24(fp)
	}

	if( xShouldWrite != pdFALSE )
  802bac:	e0bffa17 	ldw	r2,-24(fp)
  802bb0:	10000726 	beq	r2,zero,802bd0 <prvWriteMessageToBuffer+0xb8>
	{
		/* Writes the data itself. */
		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
  802bb4:	e0bffe17 	ldw	r2,-8(fp)
  802bb8:	100d883a 	mov	r6,r2
  802bbc:	e17ffd17 	ldw	r5,-12(fp)
  802bc0:	e13ffc17 	ldw	r4,-16(fp)
  802bc4:	08031680 	call	803168 <prvWriteBytesToBuffer>
  802bc8:	e0bffb15 	stw	r2,-20(fp)
  802bcc:	00000106 	br	802bd4 <prvWriteMessageToBuffer+0xbc>
	}
	else
	{
		xReturn = 0;
  802bd0:	e03ffb15 	stw	zero,-20(fp)
	}

	return xReturn;
  802bd4:	e0bffb17 	ldw	r2,-20(fp)
}
  802bd8:	e037883a 	mov	sp,fp
  802bdc:	dfc00117 	ldw	ra,4(sp)
  802be0:	df000017 	ldw	fp,0(sp)
  802be4:	dec00204 	addi	sp,sp,8
  802be8:	f800283a 	ret

00802bec <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
							 void *pvRxData,
							 size_t xBufferLengthBytes,
							 TickType_t xTicksToWait )
{
  802bec:	defff504 	addi	sp,sp,-44
  802bf0:	dfc00a15 	stw	ra,40(sp)
  802bf4:	df000915 	stw	fp,36(sp)
  802bf8:	df000904 	addi	fp,sp,36
  802bfc:	e13ffc15 	stw	r4,-16(fp)
  802c00:	e17ffd15 	stw	r5,-12(fp)
  802c04:	e1bffe15 	stw	r6,-8(fp)
  802c08:	e1ffff15 	stw	r7,-4(fp)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
  802c0c:	e0bffc17 	ldw	r2,-16(fp)
  802c10:	e0bffb15 	stw	r2,-20(fp)
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
  802c14:	e03ff815 	stw	zero,-32(fp)
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
  802c18:	e0bffb17 	ldw	r2,-20(fp)
  802c1c:	10800703 	ldbu	r2,28(r2)
  802c20:	10803fcc 	andi	r2,r2,255
  802c24:	1080004c 	andi	r2,r2,1
  802c28:	10000326 	beq	r2,zero,802c38 <xStreamBufferReceive+0x4c>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
  802c2c:	00800104 	movi	r2,4
  802c30:	e0bffa15 	stw	r2,-24(fp)
  802c34:	00000106 	br	802c3c <xStreamBufferReceive+0x50>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
  802c38:	e03ffa15 	stw	zero,-24(fp)
	}

	if( xTicksToWait != ( TickType_t ) 0 )
  802c3c:	e0bfff17 	ldw	r2,-4(fp)
  802c40:	10001c26 	beq	r2,zero,802cb4 <xStreamBufferReceive+0xc8>
	{
		/* Checking if there is data and clearing the notification state must be
		performed atomically. */
		taskENTER_CRITICAL();
  802c44:	0804ff40 	call	804ff4 <vTaskEnterCritical>
		{
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
  802c48:	e13ffb17 	ldw	r4,-20(fp)
  802c4c:	08033700 	call	803370 <prvBytesInBuffer>
  802c50:	e0bff915 	stw	r2,-28(fp)
			/* If this function was invoked by a message buffer read then
			xBytesToStoreMessageLength holds the number of bytes used to hold
			the length of the next discrete message.  If this function was
			invoked by a stream buffer read then xBytesToStoreMessageLength will
			be 0. */
			if( xBytesAvailable <= xBytesToStoreMessageLength )
  802c54:	e0bff917 	ldw	r2,-28(fp)
  802c58:	e0fffa17 	ldw	r3,-24(fp)
  802c5c:	18800636 	bltu	r3,r2,802c78 <xStreamBufferReceive+0x8c>
			{
				/* Clear notification state as going to wait for data. */
				( void ) xTaskNotifyStateClear( NULL );
  802c60:	0009883a 	mov	r4,zero
  802c64:	08057780 	call	805778 <xTaskNotifyStateClear>

				/* Should only be one reader. */
				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
  802c68:	0804c500 	call	804c50 <xTaskGetCurrentTaskHandle>
  802c6c:	1007883a 	mov	r3,r2
  802c70:	e0bffb17 	ldw	r2,-20(fp)
  802c74:	10c00415 	stw	r3,16(r2)
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
  802c78:	08050480 	call	805048 <vTaskExitCritical>

		if( xBytesAvailable <= xBytesToStoreMessageLength )
  802c7c:	e0bff917 	ldw	r2,-28(fp)
  802c80:	e0fffa17 	ldw	r3,-24(fp)
  802c84:	18800e36 	bltu	r3,r2,802cc0 <xStreamBufferReceive+0xd4>
		{
			/* Wait for data to be available. */
			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
  802c88:	e1ffff17 	ldw	r7,-4(fp)
  802c8c:	000d883a 	mov	r6,zero
  802c90:	000b883a 	mov	r5,zero
  802c94:	0009883a 	mov	r4,zero
  802c98:	08051d40 	call	8051d4 <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToReceive = NULL;
  802c9c:	e0bffb17 	ldw	r2,-20(fp)
  802ca0:	10000415 	stw	zero,16(r2)

			/* Recheck the data available after blocking. */
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
  802ca4:	e13ffb17 	ldw	r4,-20(fp)
  802ca8:	08033700 	call	803370 <prvBytesInBuffer>
  802cac:	e0bff915 	stw	r2,-28(fp)
  802cb0:	00000306 	br	802cc0 <xStreamBufferReceive+0xd4>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
  802cb4:	e13ffb17 	ldw	r4,-20(fp)
  802cb8:	08033700 	call	803370 <prvBytesInBuffer>
  802cbc:	e0bff915 	stw	r2,-28(fp)
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
  802cc0:	e0bff917 	ldw	r2,-28(fp)
  802cc4:	e0fffa17 	ldw	r3,-24(fp)
  802cc8:	1880182e 	bgeu	r3,r2,802d2c <xStreamBufferReceive+0x140>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
  802ccc:	e0bffa17 	ldw	r2,-24(fp)
  802cd0:	d8800015 	stw	r2,0(sp)
  802cd4:	e1fff917 	ldw	r7,-28(fp)
  802cd8:	e1bffe17 	ldw	r6,-8(fp)
  802cdc:	e17ffd17 	ldw	r5,-12(fp)
  802ce0:	e13ffb17 	ldw	r4,-20(fp)
  802ce4:	0802ed00 	call	802ed0 <prvReadMessageFromBuffer>
  802ce8:	e0bff815 	stw	r2,-32(fp)

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
  802cec:	e0bff817 	ldw	r2,-32(fp)
  802cf0:	10000e26 	beq	r2,zero,802d2c <xStreamBufferReceive+0x140>
		{
			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
			sbRECEIVE_COMPLETED( pxStreamBuffer );
  802cf4:	08040940 	call	804094 <vTaskSuspendAll>
  802cf8:	e0bffb17 	ldw	r2,-20(fp)
  802cfc:	10800517 	ldw	r2,20(r2)
  802d00:	10000926 	beq	r2,zero,802d28 <xStreamBufferReceive+0x13c>
  802d04:	e0bffb17 	ldw	r2,-20(fp)
  802d08:	10800517 	ldw	r2,20(r2)
  802d0c:	000f883a 	mov	r7,zero
  802d10:	000d883a 	mov	r6,zero
  802d14:	000b883a 	mov	r5,zero
  802d18:	1009883a 	mov	r4,r2
  802d1c:	08052c80 	call	8052c8 <xTaskGenericNotify>
  802d20:	e0bffb17 	ldw	r2,-20(fp)
  802d24:	10000515 	stw	zero,20(r2)
  802d28:	08040c00 	call	8040c0 <xTaskResumeAll>
	{
		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
		mtCOVERAGE_TEST_MARKER();
	}

	return xReceivedLength;
  802d2c:	e0bff817 	ldw	r2,-32(fp)
}
  802d30:	e037883a 	mov	sp,fp
  802d34:	dfc00117 	ldw	ra,4(sp)
  802d38:	df000017 	ldw	fp,0(sp)
  802d3c:	dec00204 	addi	sp,sp,8
  802d40:	f800283a 	ret

00802d44 <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
  802d44:	defff804 	addi	sp,sp,-32
  802d48:	dfc00715 	stw	ra,28(sp)
  802d4c:	df000615 	stw	fp,24(sp)
  802d50:	df000604 	addi	fp,sp,24
  802d54:	e13fff15 	stw	r4,-4(fp)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
  802d58:	e0bfff17 	ldw	r2,-4(fp)
  802d5c:	e0bffb15 	stw	r2,-20(fp)
configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

	configASSERT( pxStreamBuffer );

	/* Ensure the stream buffer is being used as a message buffer. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
  802d60:	e0bffb17 	ldw	r2,-20(fp)
  802d64:	10800703 	ldbu	r2,28(r2)
  802d68:	10803fcc 	andi	r2,r2,255
  802d6c:	1080004c 	andi	r2,r2,1
  802d70:	10001726 	beq	r2,zero,802dd0 <xStreamBufferNextMessageLengthBytes+0x8c>
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
  802d74:	e13ffb17 	ldw	r4,-20(fp)
  802d78:	08033700 	call	803370 <prvBytesInBuffer>
  802d7c:	e0bffc15 	stw	r2,-16(fp)
		if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
  802d80:	e0bffc17 	ldw	r2,-16(fp)
  802d84:	10800170 	cmpltui	r2,r2,5
  802d88:	10000f1e 	bne	r2,zero,802dc8 <xStreamBufferNextMessageLengthBytes+0x84>
			required to hold the length of the next message, so another message
			is available.  Return its length without removing the length bytes
			from the buffer.  A copy of the tail is stored so the buffer can be
			returned to its prior state as the message is not actually being
			removed from the buffer. */
			xOriginalTail = pxStreamBuffer->xTail;
  802d8c:	e0bffb17 	ldw	r2,-20(fp)
  802d90:	10800017 	ldw	r2,0(r2)
  802d94:	e0bffd15 	stw	r2,-12(fp)
			( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );
  802d98:	e0bffe04 	addi	r2,fp,-8
  802d9c:	e1fffc17 	ldw	r7,-16(fp)
  802da0:	01800104 	movi	r6,4
  802da4:	100b883a 	mov	r5,r2
  802da8:	e13ffb17 	ldw	r4,-20(fp)
  802dac:	080325c0 	call	80325c <prvReadBytesFromBuffer>
			xReturn = ( size_t ) xTempReturn;
  802db0:	e0bffe17 	ldw	r2,-8(fp)
  802db4:	e0bffa15 	stw	r2,-24(fp)
			pxStreamBuffer->xTail = xOriginalTail;
  802db8:	e0bffb17 	ldw	r2,-20(fp)
  802dbc:	e0fffd17 	ldw	r3,-12(fp)
  802dc0:	10c00015 	stw	r3,0(r2)
  802dc4:	00000306 	br	802dd4 <xStreamBufferNextMessageLengthBytes+0x90>
			/* The minimum amount of bytes in a message buffer is
			( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
			less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
			value is 0. */
			configASSERT( xBytesAvailable == 0 );
			xReturn = 0;
  802dc8:	e03ffa15 	stw	zero,-24(fp)
  802dcc:	00000106 	br	802dd4 <xStreamBufferNextMessageLengthBytes+0x90>
		}
	}
	else
	{
		xReturn = 0;
  802dd0:	e03ffa15 	stw	zero,-24(fp)
	}

	return xReturn;
  802dd4:	e0bffa17 	ldw	r2,-24(fp)
}
  802dd8:	e037883a 	mov	sp,fp
  802ddc:	dfc00117 	ldw	ra,4(sp)
  802de0:	df000017 	ldw	fp,0(sp)
  802de4:	dec00204 	addi	sp,sp,8
  802de8:	f800283a 	ret

00802dec <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
									void *pvRxData,
									size_t xBufferLengthBytes,
									BaseType_t * const pxHigherPriorityTaskWoken )
{
  802dec:	defff404 	addi	sp,sp,-48
  802df0:	dfc00b15 	stw	ra,44(sp)
  802df4:	df000a15 	stw	fp,40(sp)
  802df8:	df000a04 	addi	fp,sp,40
  802dfc:	e13ffc15 	stw	r4,-16(fp)
  802e00:	e17ffd15 	stw	r5,-12(fp)
  802e04:	e1bffe15 	stw	r6,-8(fp)
  802e08:	e1ffff15 	stw	r7,-4(fp)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
  802e0c:	e0bffc17 	ldw	r2,-16(fp)
  802e10:	e0bff915 	stw	r2,-28(fp)
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
  802e14:	e03ff715 	stw	zero,-36(fp)
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
  802e18:	e0bff917 	ldw	r2,-28(fp)
  802e1c:	10800703 	ldbu	r2,28(r2)
  802e20:	10803fcc 	andi	r2,r2,255
  802e24:	1080004c 	andi	r2,r2,1
  802e28:	10000326 	beq	r2,zero,802e38 <xStreamBufferReceiveFromISR+0x4c>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
  802e2c:	00800104 	movi	r2,4
  802e30:	e0bff815 	stw	r2,-32(fp)
  802e34:	00000106 	br	802e3c <xStreamBufferReceiveFromISR+0x50>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
  802e38:	e03ff815 	stw	zero,-32(fp)
	}

	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
  802e3c:	e13ff917 	ldw	r4,-28(fp)
  802e40:	08033700 	call	803370 <prvBytesInBuffer>
  802e44:	e0bffa15 	stw	r2,-24(fp)
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
  802e48:	e0bffa17 	ldw	r2,-24(fp)
  802e4c:	e0fff817 	ldw	r3,-32(fp)
  802e50:	1880192e 	bgeu	r3,r2,802eb8 <xStreamBufferReceiveFromISR+0xcc>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
  802e54:	e0bff817 	ldw	r2,-32(fp)
  802e58:	d8800015 	stw	r2,0(sp)
  802e5c:	e1fffa17 	ldw	r7,-24(fp)
  802e60:	e1bffe17 	ldw	r6,-8(fp)
  802e64:	e17ffd17 	ldw	r5,-12(fp)
  802e68:	e13ff917 	ldw	r4,-28(fp)
  802e6c:	0802ed00 	call	802ed0 <prvReadMessageFromBuffer>
  802e70:	e0bff715 	stw	r2,-36(fp)

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
  802e74:	e0bff717 	ldw	r2,-36(fp)
  802e78:	10000f26 	beq	r2,zero,802eb8 <xStreamBufferReceiveFromISR+0xcc>
		{
			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
  802e7c:	e03ffb15 	stw	zero,-20(fp)
  802e80:	e0bff917 	ldw	r2,-28(fp)
  802e84:	10800517 	ldw	r2,20(r2)
  802e88:	10000b26 	beq	r2,zero,802eb8 <xStreamBufferReceiveFromISR+0xcc>
  802e8c:	e0bff917 	ldw	r2,-28(fp)
  802e90:	10c00517 	ldw	r3,20(r2)
  802e94:	e0bfff17 	ldw	r2,-4(fp)
  802e98:	d8800015 	stw	r2,0(sp)
  802e9c:	000f883a 	mov	r7,zero
  802ea0:	000d883a 	mov	r6,zero
  802ea4:	000b883a 	mov	r5,zero
  802ea8:	1809883a 	mov	r4,r3
  802eac:	08054740 	call	805474 <xTaskGenericNotifyFromISR>
  802eb0:	e0bff917 	ldw	r2,-28(fp)
  802eb4:	10000515 	stw	zero,20(r2)
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

	return xReceivedLength;
  802eb8:	e0bff717 	ldw	r2,-36(fp)
}
  802ebc:	e037883a 	mov	sp,fp
  802ec0:	dfc00117 	ldw	ra,4(sp)
  802ec4:	df000017 	ldw	fp,0(sp)
  802ec8:	dec00204 	addi	sp,sp,8
  802ecc:	f800283a 	ret

00802ed0 <prvReadMessageFromBuffer>:
static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
										void *pvRxData,
										size_t xBufferLengthBytes,
										size_t xBytesAvailable,
										size_t xBytesToStoreMessageLength )
{
  802ed0:	defff604 	addi	sp,sp,-40
  802ed4:	dfc00915 	stw	ra,36(sp)
  802ed8:	df000815 	stw	fp,32(sp)
  802edc:	df000804 	addi	fp,sp,32
  802ee0:	e13ffc15 	stw	r4,-16(fp)
  802ee4:	e17ffd15 	stw	r5,-12(fp)
  802ee8:	e1bffe15 	stw	r6,-8(fp)
  802eec:	e1ffff15 	stw	r7,-4(fp)
size_t xOriginalTail, xReceivedLength, xNextMessageLength;
configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;

	if( xBytesToStoreMessageLength != ( size_t ) 0 )
  802ef0:	e0800217 	ldw	r2,8(fp)
  802ef4:	10001726 	beq	r2,zero,802f54 <prvReadMessageFromBuffer+0x84>
	{
		/* A discrete message is being received.  First receive the length
		of the message.  A copy of the tail is stored so the buffer can be
		returned to its prior state if the length of the message is too
		large for the provided buffer. */
		xOriginalTail = pxStreamBuffer->xTail;
  802ef8:	e0bffc17 	ldw	r2,-16(fp)
  802efc:	10800017 	ldw	r2,0(r2)
  802f00:	e0bff915 	stw	r2,-28(fp)
		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
  802f04:	e0bffb04 	addi	r2,fp,-20
  802f08:	e1ffff17 	ldw	r7,-4(fp)
  802f0c:	e1800217 	ldw	r6,8(fp)
  802f10:	100b883a 	mov	r5,r2
  802f14:	e13ffc17 	ldw	r4,-16(fp)
  802f18:	080325c0 	call	80325c <prvReadBytesFromBuffer>
		xNextMessageLength = ( size_t ) xTempNextMessageLength;
  802f1c:	e0bffb17 	ldw	r2,-20(fp)
  802f20:	e0bff815 	stw	r2,-32(fp)

		/* Reduce the number of bytes available by the number of bytes just
		read out. */
		xBytesAvailable -= xBytesToStoreMessageLength;
  802f24:	e0ffff17 	ldw	r3,-4(fp)
  802f28:	e0800217 	ldw	r2,8(fp)
  802f2c:	1885c83a 	sub	r2,r3,r2
  802f30:	e0bfff15 	stw	r2,-4(fp)

		/* Check there is enough space in the buffer provided by the
		user. */
		if( xNextMessageLength > xBufferLengthBytes )
  802f34:	e0bff817 	ldw	r2,-32(fp)
  802f38:	e0fffe17 	ldw	r3,-8(fp)
  802f3c:	1880072e 	bgeu	r3,r2,802f5c <prvReadMessageFromBuffer+0x8c>
		{
			/* The user has provided insufficient space to read the message
			so return the buffer to its previous state (so the length of
			the message is in the buffer again). */
			pxStreamBuffer->xTail = xOriginalTail;
  802f40:	e0bffc17 	ldw	r2,-16(fp)
  802f44:	e0fff917 	ldw	r3,-28(fp)
  802f48:	10c00015 	stw	r3,0(r2)
			xNextMessageLength = 0;
  802f4c:	e03ff815 	stw	zero,-32(fp)
  802f50:	00000206 	br	802f5c <prvReadMessageFromBuffer+0x8c>
	}
	else
	{
		/* A stream of bytes is being received (as opposed to a discrete
		message), so read as many bytes as possible. */
		xNextMessageLength = xBufferLengthBytes;
  802f54:	e0bffe17 	ldw	r2,-8(fp)
  802f58:	e0bff815 	stw	r2,-32(fp)
	}

	/* Read the actual data. */
	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
  802f5c:	e1ffff17 	ldw	r7,-4(fp)
  802f60:	e1bff817 	ldw	r6,-32(fp)
  802f64:	e17ffd17 	ldw	r5,-12(fp)
  802f68:	e13ffc17 	ldw	r4,-16(fp)
  802f6c:	080325c0 	call	80325c <prvReadBytesFromBuffer>
  802f70:	e0bffa15 	stw	r2,-24(fp)

	return xReceivedLength;
  802f74:	e0bffa17 	ldw	r2,-24(fp)
}
  802f78:	e037883a 	mov	sp,fp
  802f7c:	dfc00117 	ldw	ra,4(sp)
  802f80:	df000017 	ldw	fp,0(sp)
  802f84:	dec00204 	addi	sp,sp,8
  802f88:	f800283a 	ret

00802f8c <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
  802f8c:	defffb04 	addi	sp,sp,-20
  802f90:	df000415 	stw	fp,16(sp)
  802f94:	df000404 	addi	fp,sp,16
  802f98:	e13fff15 	stw	r4,-4(fp)
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
  802f9c:	e0bfff17 	ldw	r2,-4(fp)
  802fa0:	e0bffd15 	stw	r2,-12(fp)
size_t xTail;

	configASSERT( pxStreamBuffer );

	/* True if no bytes are available. */
	xTail = pxStreamBuffer->xTail;
  802fa4:	e0bffd17 	ldw	r2,-12(fp)
  802fa8:	10800017 	ldw	r2,0(r2)
  802fac:	e0bffe15 	stw	r2,-8(fp)
	if( pxStreamBuffer->xHead == xTail )
  802fb0:	e0bffd17 	ldw	r2,-12(fp)
  802fb4:	10c00117 	ldw	r3,4(r2)
  802fb8:	e0bffe17 	ldw	r2,-8(fp)
  802fbc:	1880031e 	bne	r3,r2,802fcc <xStreamBufferIsEmpty+0x40>
	{
		xReturn = pdTRUE;
  802fc0:	00800044 	movi	r2,1
  802fc4:	e0bffc15 	stw	r2,-16(fp)
  802fc8:	00000106 	br	802fd0 <xStreamBufferIsEmpty+0x44>
	}
	else
	{
		xReturn = pdFALSE;
  802fcc:	e03ffc15 	stw	zero,-16(fp)
	}

	return xReturn;
  802fd0:	e0bffc17 	ldw	r2,-16(fp)
}
  802fd4:	e037883a 	mov	sp,fp
  802fd8:	df000017 	ldw	fp,0(sp)
  802fdc:	dec00104 	addi	sp,sp,4
  802fe0:	f800283a 	ret

00802fe4 <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
  802fe4:	defffa04 	addi	sp,sp,-24
  802fe8:	dfc00515 	stw	ra,20(sp)
  802fec:	df000415 	stw	fp,16(sp)
  802ff0:	df000404 	addi	fp,sp,16
  802ff4:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;
size_t xBytesToStoreMessageLength;
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
  802ff8:	e0bfff17 	ldw	r2,-4(fp)
  802ffc:	e0bffe15 	stw	r2,-8(fp)

	/* This generic version of the receive function is used by both message
	buffers, which store discrete messages, and stream buffers, which store a
	continuous stream of bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
  803000:	e0bffe17 	ldw	r2,-8(fp)
  803004:	10800703 	ldbu	r2,28(r2)
  803008:	10803fcc 	andi	r2,r2,255
  80300c:	1080004c 	andi	r2,r2,1
  803010:	10000326 	beq	r2,zero,803020 <xStreamBufferIsFull+0x3c>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
  803014:	00800104 	movi	r2,4
  803018:	e0bffd15 	stw	r2,-12(fp)
  80301c:	00000106 	br	803024 <xStreamBufferIsFull+0x40>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
  803020:	e03ffd15 	stw	zero,-12(fp)
	}

	/* True if the available space equals zero. */
	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
  803024:	e13fff17 	ldw	r4,-4(fp)
  803028:	08027d80 	call	8027d8 <xStreamBufferSpacesAvailable>
  80302c:	1007883a 	mov	r3,r2
  803030:	e0bffd17 	ldw	r2,-12(fp)
  803034:	10c00336 	bltu	r2,r3,803044 <xStreamBufferIsFull+0x60>
	{
		xReturn = pdTRUE;
  803038:	00800044 	movi	r2,1
  80303c:	e0bffc15 	stw	r2,-16(fp)
  803040:	00000106 	br	803048 <xStreamBufferIsFull+0x64>
	}
	else
	{
		xReturn = pdFALSE;
  803044:	e03ffc15 	stw	zero,-16(fp)
	}

	return xReturn;
  803048:	e0bffc17 	ldw	r2,-16(fp)
}
  80304c:	e037883a 	mov	sp,fp
  803050:	dfc00117 	ldw	ra,4(sp)
  803054:	df000017 	ldw	fp,0(sp)
  803058:	dec00204 	addi	sp,sp,8
  80305c:	f800283a 	ret

00803060 <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
  803060:	defff804 	addi	sp,sp,-32
  803064:	dfc00715 	stw	ra,28(sp)
  803068:	df000615 	stw	fp,24(sp)
  80306c:	df000604 	addi	fp,sp,24
  803070:	e13ffe15 	stw	r4,-8(fp)
  803074:	e17fff15 	stw	r5,-4(fp)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
  803078:	e0bffe17 	ldw	r2,-8(fp)
  80307c:	e0bffc15 	stw	r2,-16(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
  803080:	e03ffd15 	stw	zero,-12(fp)
	{
		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
  803084:	e0bffc17 	ldw	r2,-16(fp)
  803088:	10800417 	ldw	r2,16(r2)
  80308c:	10000e26 	beq	r2,zero,8030c8 <xStreamBufferSendCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
  803090:	e0bffc17 	ldw	r2,-16(fp)
  803094:	10c00417 	ldw	r3,16(r2)
  803098:	e0bfff17 	ldw	r2,-4(fp)
  80309c:	d8800015 	stw	r2,0(sp)
  8030a0:	000f883a 	mov	r7,zero
  8030a4:	000d883a 	mov	r6,zero
  8030a8:	000b883a 	mov	r5,zero
  8030ac:	1809883a 	mov	r4,r3
  8030b0:	08054740 	call	805474 <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
  8030b4:	e0bffc17 	ldw	r2,-16(fp)
  8030b8:	10000415 	stw	zero,16(r2)
			xReturn = pdTRUE;
  8030bc:	00800044 	movi	r2,1
  8030c0:	e0bffb15 	stw	r2,-20(fp)
  8030c4:	00000106 	br	8030cc <xStreamBufferSendCompletedFromISR+0x6c>
		}
		else
		{
			xReturn = pdFALSE;
  8030c8:	e03ffb15 	stw	zero,-20(fp)
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
  8030cc:	e0bffb17 	ldw	r2,-20(fp)
}
  8030d0:	e037883a 	mov	sp,fp
  8030d4:	dfc00117 	ldw	ra,4(sp)
  8030d8:	df000017 	ldw	fp,0(sp)
  8030dc:	dec00204 	addi	sp,sp,8
  8030e0:	f800283a 	ret

008030e4 <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
  8030e4:	defff804 	addi	sp,sp,-32
  8030e8:	dfc00715 	stw	ra,28(sp)
  8030ec:	df000615 	stw	fp,24(sp)
  8030f0:	df000604 	addi	fp,sp,24
  8030f4:	e13ffe15 	stw	r4,-8(fp)
  8030f8:	e17fff15 	stw	r5,-4(fp)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
  8030fc:	e0bffe17 	ldw	r2,-8(fp)
  803100:	e0bffc15 	stw	r2,-16(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
  803104:	e03ffd15 	stw	zero,-12(fp)
	{
		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
  803108:	e0bffc17 	ldw	r2,-16(fp)
  80310c:	10800517 	ldw	r2,20(r2)
  803110:	10000e26 	beq	r2,zero,80314c <xStreamBufferReceiveCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
  803114:	e0bffc17 	ldw	r2,-16(fp)
  803118:	10c00517 	ldw	r3,20(r2)
  80311c:	e0bfff17 	ldw	r2,-4(fp)
  803120:	d8800015 	stw	r2,0(sp)
  803124:	000f883a 	mov	r7,zero
  803128:	000d883a 	mov	r6,zero
  80312c:	000b883a 	mov	r5,zero
  803130:	1809883a 	mov	r4,r3
  803134:	08054740 	call	805474 <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
  803138:	e0bffc17 	ldw	r2,-16(fp)
  80313c:	10000515 	stw	zero,20(r2)
			xReturn = pdTRUE;
  803140:	00800044 	movi	r2,1
  803144:	e0bffb15 	stw	r2,-20(fp)
  803148:	00000106 	br	803150 <xStreamBufferReceiveCompletedFromISR+0x6c>
		}
		else
		{
			xReturn = pdFALSE;
  80314c:	e03ffb15 	stw	zero,-20(fp)
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
  803150:	e0bffb17 	ldw	r2,-20(fp)
}
  803154:	e037883a 	mov	sp,fp
  803158:	dfc00117 	ldw	ra,4(sp)
  80315c:	df000017 	ldw	fp,0(sp)
  803160:	dec00204 	addi	sp,sp,8
  803164:	f800283a 	ret

00803168 <prvWriteBytesToBuffer>:
/*-----------------------------------------------------------*/

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
{
  803168:	defff904 	addi	sp,sp,-28
  80316c:	dfc00615 	stw	ra,24(sp)
  803170:	df000515 	stw	fp,20(sp)
  803174:	df000504 	addi	fp,sp,20
  803178:	e13ffd15 	stw	r4,-12(fp)
  80317c:	e17ffe15 	stw	r5,-8(fp)
  803180:	e1bfff15 	stw	r6,-4(fp)
size_t xNextHead, xFirstLength;

	configASSERT( xCount > ( size_t ) 0 );

	xNextHead = pxStreamBuffer->xHead;
  803184:	e0bffd17 	ldw	r2,-12(fp)
  803188:	10800117 	ldw	r2,4(r2)
  80318c:	e0bffb15 	stw	r2,-20(fp)

	/* Calculate the number of bytes that can be added in the first write -
	which may be less than the total number of bytes that need to be added if
	the buffer will wrap back to the beginning. */
	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
  803190:	e0bffd17 	ldw	r2,-12(fp)
  803194:	10c00217 	ldw	r3,8(r2)
  803198:	e0bffb17 	ldw	r2,-20(fp)
  80319c:	1885c83a 	sub	r2,r3,r2
  8031a0:	e0ffff17 	ldw	r3,-4(fp)
  8031a4:	1880012e 	bgeu	r3,r2,8031ac <prvWriteBytesToBuffer+0x44>
  8031a8:	1805883a 	mov	r2,r3
  8031ac:	e0bffc15 	stw	r2,-16(fp)

	/* Write as many bytes as can be written in the first write. */
	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
	( void ) memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
  8031b0:	e0bffd17 	ldw	r2,-12(fp)
  8031b4:	10c00617 	ldw	r3,24(r2)
  8031b8:	e0bffb17 	ldw	r2,-20(fp)
  8031bc:	1885883a 	add	r2,r3,r2
  8031c0:	e1bffc17 	ldw	r6,-16(fp)
  8031c4:	e17ffe17 	ldw	r5,-8(fp)
  8031c8:	1009883a 	mov	r4,r2
  8031cc:	08065900 	call	806590 <memcpy>

	/* If the number of bytes written was less than the number that could be
	written in the first write... */
	if( xCount > xFirstLength )
  8031d0:	e0bfff17 	ldw	r2,-4(fp)
  8031d4:	e0fffc17 	ldw	r3,-16(fp)
  8031d8:	18800a2e 	bgeu	r3,r2,803204 <prvWriteBytesToBuffer+0x9c>
	{
		/* ...then write the remaining bytes to the start of the buffer. */
		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
  8031dc:	e0bffd17 	ldw	r2,-12(fp)
  8031e0:	11000617 	ldw	r4,24(r2)
  8031e4:	e0fffe17 	ldw	r3,-8(fp)
  8031e8:	e0bffc17 	ldw	r2,-16(fp)
  8031ec:	188b883a 	add	r5,r3,r2
  8031f0:	e0ffff17 	ldw	r3,-4(fp)
  8031f4:	e0bffc17 	ldw	r2,-16(fp)
  8031f8:	1885c83a 	sub	r2,r3,r2
  8031fc:	100d883a 	mov	r6,r2
  803200:	08065900 	call	806590 <memcpy>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xNextHead += xCount;
  803204:	e0fffb17 	ldw	r3,-20(fp)
  803208:	e0bfff17 	ldw	r2,-4(fp)
  80320c:	1885883a 	add	r2,r3,r2
  803210:	e0bffb15 	stw	r2,-20(fp)
	if( xNextHead >= pxStreamBuffer->xLength )
  803214:	e0bffd17 	ldw	r2,-12(fp)
  803218:	10800217 	ldw	r2,8(r2)
  80321c:	e0fffb17 	ldw	r3,-20(fp)
  803220:	18800536 	bltu	r3,r2,803238 <prvWriteBytesToBuffer+0xd0>
	{
		xNextHead -= pxStreamBuffer->xLength;
  803224:	e0bffd17 	ldw	r2,-12(fp)
  803228:	10800217 	ldw	r2,8(r2)
  80322c:	e0fffb17 	ldw	r3,-20(fp)
  803230:	1885c83a 	sub	r2,r3,r2
  803234:	e0bffb15 	stw	r2,-20(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxStreamBuffer->xHead = xNextHead;
  803238:	e0bffd17 	ldw	r2,-12(fp)
  80323c:	e0fffb17 	ldw	r3,-20(fp)
  803240:	10c00115 	stw	r3,4(r2)

	return xCount;
  803244:	e0bfff17 	ldw	r2,-4(fp)
}
  803248:	e037883a 	mov	sp,fp
  80324c:	dfc00117 	ldw	ra,4(sp)
  803250:	df000017 	ldw	fp,0(sp)
  803254:	dec00204 	addi	sp,sp,8
  803258:	f800283a 	ret

0080325c <prvReadBytesFromBuffer>:
/*-----------------------------------------------------------*/

static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
{
  80325c:	defff704 	addi	sp,sp,-36
  803260:	dfc00815 	stw	ra,32(sp)
  803264:	df000715 	stw	fp,28(sp)
  803268:	df000704 	addi	fp,sp,28
  80326c:	e13ffc15 	stw	r4,-16(fp)
  803270:	e17ffd15 	stw	r5,-12(fp)
  803274:	e1bffe15 	stw	r6,-8(fp)
  803278:	e1ffff15 	stw	r7,-4(fp)
size_t xCount, xFirstLength, xNextTail;

	/* Use the minimum of the wanted bytes and the available bytes. */
	xCount = configMIN( xBytesAvailable, xMaxCount );
  80327c:	e0ffff17 	ldw	r3,-4(fp)
  803280:	e0bffe17 	ldw	r2,-8(fp)
  803284:	1880012e 	bgeu	r3,r2,80328c <prvReadBytesFromBuffer+0x30>
  803288:	1805883a 	mov	r2,r3
  80328c:	e0bffa15 	stw	r2,-24(fp)

	if( xCount > ( size_t ) 0 )
  803290:	e0bffa17 	ldw	r2,-24(fp)
  803294:	10003026 	beq	r2,zero,803358 <prvReadBytesFromBuffer+0xfc>
	{
		xNextTail = pxStreamBuffer->xTail;
  803298:	e0bffc17 	ldw	r2,-16(fp)
  80329c:	10800017 	ldw	r2,0(r2)
  8032a0:	e0bff915 	stw	r2,-28(fp)

		/* Calculate the number of bytes that can be read - which may be
		less than the number wanted if the data wraps around to the start of
		the buffer. */
		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
  8032a4:	e0bffc17 	ldw	r2,-16(fp)
  8032a8:	10c00217 	ldw	r3,8(r2)
  8032ac:	e0bff917 	ldw	r2,-28(fp)
  8032b0:	1885c83a 	sub	r2,r3,r2
  8032b4:	e0fffa17 	ldw	r3,-24(fp)
  8032b8:	1880012e 	bgeu	r3,r2,8032c0 <prvReadBytesFromBuffer+0x64>
  8032bc:	1805883a 	mov	r2,r3
  8032c0:	e0bffb15 	stw	r2,-20(fp)

		/* Obtain the number of bytes it is possible to obtain in the first
		read.  Asserts check bounds of read and write. */
		configASSERT( xFirstLength <= xMaxCount );
		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
  8032c4:	e0bffc17 	ldw	r2,-16(fp)
  8032c8:	10c00617 	ldw	r3,24(r2)
  8032cc:	e0bff917 	ldw	r2,-28(fp)
  8032d0:	1885883a 	add	r2,r3,r2
  8032d4:	e1bffb17 	ldw	r6,-20(fp)
  8032d8:	100b883a 	mov	r5,r2
  8032dc:	e13ffd17 	ldw	r4,-12(fp)
  8032e0:	08065900 	call	806590 <memcpy>

		/* If the total number of wanted bytes is greater than the number
		that could be read in the first read... */
		if( xCount > xFirstLength )
  8032e4:	e0bffa17 	ldw	r2,-24(fp)
  8032e8:	e0fffb17 	ldw	r3,-20(fp)
  8032ec:	18800a2e 	bgeu	r3,r2,803318 <prvReadBytesFromBuffer+0xbc>
		{
			/*...then read the remaining bytes from the start of the buffer. */
			configASSERT( xCount <= xMaxCount );
			( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
  8032f0:	e0fffd17 	ldw	r3,-12(fp)
  8032f4:	e0bffb17 	ldw	r2,-20(fp)
  8032f8:	1889883a 	add	r4,r3,r2
  8032fc:	e0bffc17 	ldw	r2,-16(fp)
  803300:	11400617 	ldw	r5,24(r2)
  803304:	e0fffa17 	ldw	r3,-24(fp)
  803308:	e0bffb17 	ldw	r2,-20(fp)
  80330c:	1885c83a 	sub	r2,r3,r2
  803310:	100d883a 	mov	r6,r2
  803314:	08065900 	call	806590 <memcpy>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Move the tail pointer to effectively remove the data read from
		the buffer. */
		xNextTail += xCount;
  803318:	e0fff917 	ldw	r3,-28(fp)
  80331c:	e0bffa17 	ldw	r2,-24(fp)
  803320:	1885883a 	add	r2,r3,r2
  803324:	e0bff915 	stw	r2,-28(fp)

		if( xNextTail >= pxStreamBuffer->xLength )
  803328:	e0bffc17 	ldw	r2,-16(fp)
  80332c:	10800217 	ldw	r2,8(r2)
  803330:	e0fff917 	ldw	r3,-28(fp)
  803334:	18800536 	bltu	r3,r2,80334c <prvReadBytesFromBuffer+0xf0>
		{
			xNextTail -= pxStreamBuffer->xLength;
  803338:	e0bffc17 	ldw	r2,-16(fp)
  80333c:	10800217 	ldw	r2,8(r2)
  803340:	e0fff917 	ldw	r3,-28(fp)
  803344:	1885c83a 	sub	r2,r3,r2
  803348:	e0bff915 	stw	r2,-28(fp)
		}

		pxStreamBuffer->xTail = xNextTail;
  80334c:	e0bffc17 	ldw	r2,-16(fp)
  803350:	e0fff917 	ldw	r3,-28(fp)
  803354:	10c00015 	stw	r3,0(r2)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
  803358:	e0bffa17 	ldw	r2,-24(fp)
}
  80335c:	e037883a 	mov	sp,fp
  803360:	dfc00117 	ldw	ra,4(sp)
  803364:	df000017 	ldw	fp,0(sp)
  803368:	dec00204 	addi	sp,sp,8
  80336c:	f800283a 	ret

00803370 <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
  803370:	defffd04 	addi	sp,sp,-12
  803374:	df000215 	stw	fp,8(sp)
  803378:	df000204 	addi	fp,sp,8
  80337c:	e13fff15 	stw	r4,-4(fp)
/* Returns the distance between xTail and xHead. */
size_t xCount;

	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
  803380:	e0bfff17 	ldw	r2,-4(fp)
  803384:	10c00217 	ldw	r3,8(r2)
  803388:	e0bfff17 	ldw	r2,-4(fp)
  80338c:	10800117 	ldw	r2,4(r2)
  803390:	1885883a 	add	r2,r3,r2
  803394:	e0bffe15 	stw	r2,-8(fp)
	xCount -= pxStreamBuffer->xTail;
  803398:	e0bfff17 	ldw	r2,-4(fp)
  80339c:	10800017 	ldw	r2,0(r2)
  8033a0:	e0fffe17 	ldw	r3,-8(fp)
  8033a4:	1885c83a 	sub	r2,r3,r2
  8033a8:	e0bffe15 	stw	r2,-8(fp)
	if ( xCount >= pxStreamBuffer->xLength )
  8033ac:	e0bfff17 	ldw	r2,-4(fp)
  8033b0:	10800217 	ldw	r2,8(r2)
  8033b4:	e0fffe17 	ldw	r3,-8(fp)
  8033b8:	18800536 	bltu	r3,r2,8033d0 <prvBytesInBuffer+0x60>
	{
		xCount -= pxStreamBuffer->xLength;
  8033bc:	e0bfff17 	ldw	r2,-4(fp)
  8033c0:	10800217 	ldw	r2,8(r2)
  8033c4:	e0fffe17 	ldw	r3,-8(fp)
  8033c8:	1885c83a 	sub	r2,r3,r2
  8033cc:	e0bffe15 	stw	r2,-8(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
  8033d0:	e0bffe17 	ldw	r2,-8(fp)
}
  8033d4:	e037883a 	mov	sp,fp
  8033d8:	df000017 	ldw	fp,0(sp)
  8033dc:	dec00104 	addi	sp,sp,4
  8033e0:	f800283a 	ret

008033e4 <prvInitialiseNewStreamBuffer>:
static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
										  uint8_t * const pucBuffer,
										  size_t xBufferSizeBytes,
										  size_t xTriggerLevelBytes,
										  uint8_t ucFlags )
{
  8033e4:	defff904 	addi	sp,sp,-28
  8033e8:	dfc00615 	stw	ra,24(sp)
  8033ec:	df000515 	stw	fp,20(sp)
  8033f0:	df000504 	addi	fp,sp,20
  8033f4:	e13ffb15 	stw	r4,-20(fp)
  8033f8:	e17ffc15 	stw	r5,-16(fp)
  8033fc:	e1bffd15 	stw	r6,-12(fp)
  803400:	e1fffe15 	stw	r7,-8(fp)
  803404:	e0800217 	ldw	r2,8(fp)
  803408:	e0bfff05 	stb	r2,-4(fp)
		const BaseType_t xWriteValue = 0x55;
		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
	} /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
	#endif

	( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
  80340c:	01800804 	movi	r6,32
  803410:	000b883a 	mov	r5,zero
  803414:	e13ffb17 	ldw	r4,-20(fp)
  803418:	08065b80 	call	8065b8 <memset>
	pxStreamBuffer->pucBuffer = pucBuffer;
  80341c:	e0bffb17 	ldw	r2,-20(fp)
  803420:	e0fffc17 	ldw	r3,-16(fp)
  803424:	10c00615 	stw	r3,24(r2)
	pxStreamBuffer->xLength = xBufferSizeBytes;
  803428:	e0bffb17 	ldw	r2,-20(fp)
  80342c:	e0fffd17 	ldw	r3,-12(fp)
  803430:	10c00215 	stw	r3,8(r2)
	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
  803434:	e0bffb17 	ldw	r2,-20(fp)
  803438:	e0fffe17 	ldw	r3,-8(fp)
  80343c:	10c00315 	stw	r3,12(r2)
	pxStreamBuffer->ucFlags = ucFlags;
  803440:	e0bffb17 	ldw	r2,-20(fp)
  803444:	e0ffff03 	ldbu	r3,-4(fp)
  803448:	10c00705 	stb	r3,28(r2)
}
  80344c:	0001883a 	nop
  803450:	e037883a 	mov	sp,fp
  803454:	dfc00117 	ldw	ra,4(sp)
  803458:	df000017 	ldw	fp,0(sp)
  80345c:	dec00204 	addi	sp,sp,8
  803460:	f800283a 	ret

00803464 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
  803464:	defff304 	addi	sp,sp,-52
  803468:	dfc00c15 	stw	ra,48(sp)
  80346c:	df000b15 	stw	fp,44(sp)
  803470:	df000b04 	addi	fp,sp,44
  803474:	e13ffc15 	stw	r4,-16(fp)
  803478:	e17ffd15 	stw	r5,-12(fp)
  80347c:	3005883a 	mov	r2,r6
  803480:	e1ffff15 	stw	r7,-4(fp)
  803484:	e0bffe0d 	sth	r2,-8(fp)
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
  803488:	e0bffe0b 	ldhu	r2,-8(fp)
  80348c:	1085883a 	add	r2,r2,r2
  803490:	1085883a 	add	r2,r2,r2
  803494:	1009883a 	mov	r4,r2
  803498:	080101c0 	call	80101c <pvPortMalloc>
  80349c:	e0bffb15 	stw	r2,-20(fp)

			if( pxStack != NULL )
  8034a0:	e0bffb17 	ldw	r2,-20(fp)
  8034a4:	10000c26 	beq	r2,zero,8034d8 <xTaskCreate+0x74>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
  8034a8:	01001404 	movi	r4,80
  8034ac:	080101c0 	call	80101c <pvPortMalloc>
  8034b0:	e0bff915 	stw	r2,-28(fp)

				if( pxNewTCB != NULL )
  8034b4:	e0bff917 	ldw	r2,-28(fp)
  8034b8:	10000426 	beq	r2,zero,8034cc <xTaskCreate+0x68>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
  8034bc:	e0bff917 	ldw	r2,-28(fp)
  8034c0:	e0fffb17 	ldw	r3,-20(fp)
  8034c4:	10c00c15 	stw	r3,48(r2)
  8034c8:	00000406 	br	8034dc <xTaskCreate+0x78>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
  8034cc:	e13ffb17 	ldw	r4,-20(fp)
  8034d0:	08010dc0 	call	8010dc <vPortFree>
  8034d4:	00000106 	br	8034dc <xTaskCreate+0x78>
				}
			}
			else
			{
				pxNewTCB = NULL;
  8034d8:	e03ff915 	stw	zero,-28(fp)
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
  8034dc:	e0bff917 	ldw	r2,-28(fp)
  8034e0:	10001226 	beq	r2,zero,80352c <xTaskCreate+0xc8>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
  8034e4:	e0fffe0b 	ldhu	r3,-8(fp)
  8034e8:	d8000315 	stw	zero,12(sp)
  8034ec:	e0bff917 	ldw	r2,-28(fp)
  8034f0:	d8800215 	stw	r2,8(sp)
  8034f4:	e0800317 	ldw	r2,12(fp)
  8034f8:	d8800115 	stw	r2,4(sp)
  8034fc:	e0800217 	ldw	r2,8(fp)
  803500:	d8800015 	stw	r2,0(sp)
  803504:	e1ffff17 	ldw	r7,-4(fp)
  803508:	180d883a 	mov	r6,r3
  80350c:	e17ffd17 	ldw	r5,-12(fp)
  803510:	e13ffc17 	ldw	r4,-16(fp)
  803514:	080354c0 	call	80354c <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
  803518:	e13ff917 	ldw	r4,-28(fp)
  80351c:	08037300 	call	803730 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
  803520:	00800044 	movi	r2,1
  803524:	e0bffa15 	stw	r2,-24(fp)
  803528:	00000206 	br	803534 <xTaskCreate+0xd0>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
  80352c:	00bfffc4 	movi	r2,-1
  803530:	e0bffa15 	stw	r2,-24(fp)
		}

		return xReturn;
  803534:	e0bffa17 	ldw	r2,-24(fp)
	}
  803538:	e037883a 	mov	sp,fp
  80353c:	dfc00117 	ldw	ra,4(sp)
  803540:	df000017 	ldw	fp,0(sp)
  803544:	dec00204 	addi	sp,sp,8
  803548:	f800283a 	ret

0080354c <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
  80354c:	defff804 	addi	sp,sp,-32
  803550:	dfc00715 	stw	ra,28(sp)
  803554:	df000615 	stw	fp,24(sp)
  803558:	df000604 	addi	fp,sp,24
  80355c:	e13ffc15 	stw	r4,-16(fp)
  803560:	e17ffd15 	stw	r5,-12(fp)
  803564:	e1bffe15 	stw	r6,-8(fp)
  803568:	e1ffff15 	stw	r7,-4(fp)

	/* Avoid dependency on memset() if it is not required. */
	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
	{
		/* Fill the stack with a known value to assist debugging. */
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
  80356c:	e0800417 	ldw	r2,16(fp)
  803570:	10c00c17 	ldw	r3,48(r2)
  803574:	e0bffe17 	ldw	r2,-8(fp)
  803578:	1085883a 	add	r2,r2,r2
  80357c:	1085883a 	add	r2,r2,r2
  803580:	100d883a 	mov	r6,r2
  803584:	01402944 	movi	r5,165
  803588:	1809883a 	mov	r4,r3
  80358c:	08065b80 	call	8065b8 <memset>
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
  803590:	e0800417 	ldw	r2,16(fp)
  803594:	10c00c17 	ldw	r3,48(r2)
  803598:	e13ffe17 	ldw	r4,-8(fp)
  80359c:	00900034 	movhi	r2,16384
  8035a0:	10bfffc4 	addi	r2,r2,-1
  8035a4:	2085883a 	add	r2,r4,r2
  8035a8:	1085883a 	add	r2,r2,r2
  8035ac:	1085883a 	add	r2,r2,r2
  8035b0:	1885883a 	add	r2,r3,r2
  8035b4:	e0bffb15 	stw	r2,-20(fp)
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
  8035b8:	e0fffb17 	ldw	r3,-20(fp)
  8035bc:	00bfff04 	movi	r2,-4
  8035c0:	1884703a 	and	r2,r3,r2
  8035c4:	e0bffb15 	stw	r2,-20(fp)
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
  8035c8:	e0bffd17 	ldw	r2,-12(fp)
  8035cc:	10001e26 	beq	r2,zero,803648 <prvInitialiseNewTask+0xfc>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
  8035d0:	e03ffa15 	stw	zero,-24(fp)
  8035d4:	00001406 	br	803628 <prvInitialiseNewTask+0xdc>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
  8035d8:	e0fffd17 	ldw	r3,-12(fp)
  8035dc:	e0bffa17 	ldw	r2,-24(fp)
  8035e0:	1885883a 	add	r2,r3,r2
  8035e4:	10c00003 	ldbu	r3,0(r2)
  8035e8:	e1000417 	ldw	r4,16(fp)
  8035ec:	e0bffa17 	ldw	r2,-24(fp)
  8035f0:	2085883a 	add	r2,r4,r2
  8035f4:	10800d04 	addi	r2,r2,52
  8035f8:	10c00005 	stb	r3,0(r2)

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
  8035fc:	e0fffd17 	ldw	r3,-12(fp)
  803600:	e0bffa17 	ldw	r2,-24(fp)
  803604:	1885883a 	add	r2,r3,r2
  803608:	10800003 	ldbu	r2,0(r2)
  80360c:	10803fcc 	andi	r2,r2,255
  803610:	1080201c 	xori	r2,r2,128
  803614:	10bfe004 	addi	r2,r2,-128
  803618:	10000726 	beq	r2,zero,803638 <prvInitialiseNewTask+0xec>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
  80361c:	e0bffa17 	ldw	r2,-24(fp)
  803620:	10800044 	addi	r2,r2,1
  803624:	e0bffa15 	stw	r2,-24(fp)
  803628:	e0bffa17 	ldw	r2,-24(fp)
  80362c:	10800230 	cmpltui	r2,r2,8
  803630:	103fe91e 	bne	r2,zero,8035d8 <__alt_mem_onchip_memory2_0+0xff7835d8>
  803634:	00000106 	br	80363c <prvInitialiseNewTask+0xf0>
			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
			{
				break;
  803638:	0001883a 	nop
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
  80363c:	e0800417 	ldw	r2,16(fp)
  803640:	10000ec5 	stb	zero,59(r2)
  803644:	00000206 	br	803650 <prvInitialiseNewTask+0x104>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
  803648:	e0800417 	ldw	r2,16(fp)
  80364c:	10000d05 	stb	zero,52(r2)
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
  803650:	e0800217 	ldw	r2,8(fp)
  803654:	10800170 	cmpltui	r2,r2,5
  803658:	1000021e 	bne	r2,zero,803664 <prvInitialiseNewTask+0x118>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
  80365c:	00800104 	movi	r2,4
  803660:	e0800215 	stw	r2,8(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
  803664:	e0800417 	ldw	r2,16(fp)
  803668:	e0c00217 	ldw	r3,8(fp)
  80366c:	10c00b15 	stw	r3,44(r2)
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
  803670:	e0800417 	ldw	r2,16(fp)
  803674:	e0c00217 	ldw	r3,8(fp)
  803678:	10c01015 	stw	r3,64(r2)
		pxNewTCB->uxMutexesHeld = 0;
  80367c:	e0800417 	ldw	r2,16(fp)
  803680:	10001115 	stw	zero,68(r2)
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
  803684:	e0800417 	ldw	r2,16(fp)
  803688:	10800104 	addi	r2,r2,4
  80368c:	1009883a 	mov	r4,r2
  803690:	0800a080 	call	800a08 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
  803694:	e0800417 	ldw	r2,16(fp)
  803698:	10800604 	addi	r2,r2,24
  80369c:	1009883a 	mov	r4,r2
  8036a0:	0800a080 	call	800a08 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
  8036a4:	e0800417 	ldw	r2,16(fp)
  8036a8:	e0c00417 	ldw	r3,16(fp)
  8036ac:	10c00415 	stw	r3,16(r2)

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  8036b0:	00c00144 	movi	r3,5
  8036b4:	e0800217 	ldw	r2,8(fp)
  8036b8:	1887c83a 	sub	r3,r3,r2
  8036bc:	e0800417 	ldw	r2,16(fp)
  8036c0:	10c00615 	stw	r3,24(r2)
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
  8036c4:	e0800417 	ldw	r2,16(fp)
  8036c8:	e0c00417 	ldw	r3,16(fp)
  8036cc:	10c00915 	stw	r3,36(r2)

	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
	{
		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
  8036d0:	e0800417 	ldw	r2,16(fp)
  8036d4:	10000f15 	stw	zero,60(r2)
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
  8036d8:	e0800417 	ldw	r2,16(fp)
  8036dc:	10001215 	stw	zero,72(r2)
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
  8036e0:	e0800417 	ldw	r2,16(fp)
  8036e4:	10001305 	stb	zero,76(r2)
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
  8036e8:	e1bfff17 	ldw	r6,-4(fp)
  8036ec:	e17ffc17 	ldw	r5,-16(fp)
  8036f0:	e13ffb17 	ldw	r4,-20(fp)
  8036f4:	0800c5c0 	call	800c5c <pxPortInitialiseStack>
  8036f8:	1007883a 	mov	r3,r2
  8036fc:	e0800417 	ldw	r2,16(fp)
  803700:	10c00015 	stw	r3,0(r2)
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
  803704:	e0800317 	ldw	r2,12(fp)
  803708:	10000326 	beq	r2,zero,803718 <prvInitialiseNewTask+0x1cc>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
  80370c:	e0800317 	ldw	r2,12(fp)
  803710:	e0c00417 	ldw	r3,16(fp)
  803714:	10c00015 	stw	r3,0(r2)
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
  803718:	0001883a 	nop
  80371c:	e037883a 	mov	sp,fp
  803720:	dfc00117 	ldw	ra,4(sp)
  803724:	df000017 	ldw	fp,0(sp)
  803728:	dec00204 	addi	sp,sp,8
  80372c:	f800283a 	ret

00803730 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
  803730:	defffd04 	addi	sp,sp,-12
  803734:	dfc00215 	stw	ra,8(sp)
  803738:	df000115 	stw	fp,4(sp)
  80373c:	df000104 	addi	fp,sp,4
  803740:	e13fff15 	stw	r4,-4(fp)
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
  803744:	0804ff40 	call	804ff4 <vTaskEnterCritical>
	{
		uxCurrentNumberOfTasks++;
  803748:	d0a4d617 	ldw	r2,-27816(gp)
  80374c:	10800044 	addi	r2,r2,1
  803750:	d0a4d615 	stw	r2,-27816(gp)
		if( pxCurrentTCB == NULL )
  803754:	d0a4d217 	ldw	r2,-27832(gp)
  803758:	1000071e 	bne	r2,zero,803778 <prvAddNewTaskToReadyList+0x48>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
  80375c:	e0bfff17 	ldw	r2,-4(fp)
  803760:	d0a4d215 	stw	r2,-27832(gp)

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
  803764:	d0a4d617 	ldw	r2,-27816(gp)
  803768:	10800058 	cmpnei	r2,r2,1
  80376c:	10000b1e 	bne	r2,zero,80379c <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
  803770:	08049bc0 	call	8049bc <prvInitialiseTaskLists>
  803774:	00000906 	br	80379c <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
  803778:	d0a4d917 	ldw	r2,-27804(gp)
  80377c:	1000071e 	bne	r2,zero,80379c <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
  803780:	d0a4d217 	ldw	r2,-27832(gp)
  803784:	10800b17 	ldw	r2,44(r2)
  803788:	e0ffff17 	ldw	r3,-4(fp)
  80378c:	18c00b17 	ldw	r3,44(r3)
  803790:	18800236 	bltu	r3,r2,80379c <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
  803794:	e0bfff17 	ldw	r2,-4(fp)
  803798:	d0a4d215 	stw	r2,-27832(gp)
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
  80379c:	d0a4dd17 	ldw	r2,-27788(gp)
  8037a0:	10800044 	addi	r2,r2,1
  8037a4:	d0a4dd15 	stw	r2,-27788(gp)
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
  8037a8:	e0bfff17 	ldw	r2,-4(fp)
  8037ac:	10800b17 	ldw	r2,44(r2)
  8037b0:	d0e4d817 	ldw	r3,-27808(gp)
  8037b4:	1880032e 	bgeu	r3,r2,8037c4 <prvAddNewTaskToReadyList+0x94>
  8037b8:	e0bfff17 	ldw	r2,-4(fp)
  8037bc:	10800b17 	ldw	r2,44(r2)
  8037c0:	d0a4d815 	stw	r2,-27808(gp)
  8037c4:	e0bfff17 	ldw	r2,-4(fp)
  8037c8:	10800b17 	ldw	r2,44(r2)
  8037cc:	10c00524 	muli	r3,r2,20
  8037d0:	00802174 	movhi	r2,133
  8037d4:	10a18c04 	addi	r2,r2,-31184
  8037d8:	1887883a 	add	r3,r3,r2
  8037dc:	e0bfff17 	ldw	r2,-4(fp)
  8037e0:	10800104 	addi	r2,r2,4
  8037e4:	100b883a 	mov	r5,r2
  8037e8:	1809883a 	mov	r4,r3
  8037ec:	0800a340 	call	800a34 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
  8037f0:	08050480 	call	805048 <vTaskExitCritical>

	if( xSchedulerRunning != pdFALSE )
  8037f4:	d0a4d917 	ldw	r2,-27804(gp)
  8037f8:	10000626 	beq	r2,zero,803814 <prvAddNewTaskToReadyList+0xe4>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
  8037fc:	d0a4d217 	ldw	r2,-27832(gp)
  803800:	10c00b17 	ldw	r3,44(r2)
  803804:	e0bfff17 	ldw	r2,-4(fp)
  803808:	10800b17 	ldw	r2,44(r2)
  80380c:	1880012e 	bgeu	r3,r2,803814 <prvAddNewTaskToReadyList+0xe4>
		{
			taskYIELD_IF_USING_PREEMPTION();
  803810:	003b683a 	trap	0
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
  803814:	0001883a 	nop
  803818:	e037883a 	mov	sp,fp
  80381c:	dfc00117 	ldw	ra,4(sp)
  803820:	df000017 	ldw	fp,0(sp)
  803824:	dec00204 	addi	sp,sp,8
  803828:	f800283a 	ret

0080382c <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
  80382c:	defffc04 	addi	sp,sp,-16
  803830:	dfc00315 	stw	ra,12(sp)
  803834:	df000215 	stw	fp,8(sp)
  803838:	df000204 	addi	fp,sp,8
  80383c:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
  803840:	0804ff40 	call	804ff4 <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
  803844:	e0bfff17 	ldw	r2,-4(fp)
  803848:	1000021e 	bne	r2,zero,803854 <vTaskDelete+0x28>
  80384c:	d0a4d217 	ldw	r2,-27832(gp)
  803850:	00000106 	br	803858 <vTaskDelete+0x2c>
  803854:	e0bfff17 	ldw	r2,-4(fp)
  803858:	e0bffe15 	stw	r2,-8(fp)

			/* Remove task from the ready/delayed list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  80385c:	e0bffe17 	ldw	r2,-8(fp)
  803860:	10800104 	addi	r2,r2,4
  803864:	1009883a 	mov	r4,r2
  803868:	0800b980 	call	800b98 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
  80386c:	e0bffe17 	ldw	r2,-8(fp)
  803870:	10800a17 	ldw	r2,40(r2)
  803874:	10000426 	beq	r2,zero,803888 <vTaskDelete+0x5c>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  803878:	e0bffe17 	ldw	r2,-8(fp)
  80387c:	10800604 	addi	r2,r2,24
  803880:	1009883a 	mov	r4,r2
  803884:	0800b980 	call	800b98 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
  803888:	d0a4dd17 	ldw	r2,-27788(gp)
  80388c:	10800044 	addi	r2,r2,1
  803890:	d0a4dd15 	stw	r2,-27788(gp)

			if( pxTCB == pxCurrentTCB )
  803894:	d0a4d217 	ldw	r2,-27832(gp)
  803898:	e0fffe17 	ldw	r3,-8(fp)
  80389c:	18800a1e 	bne	r3,r2,8038c8 <vTaskDelete+0x9c>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
  8038a0:	e0bffe17 	ldw	r2,-8(fp)
  8038a4:	10800104 	addi	r2,r2,4
  8038a8:	100b883a 	mov	r5,r2
  8038ac:	01002174 	movhi	r4,133
  8038b0:	2121b404 	addi	r4,r4,-31024
  8038b4:	0800a340 	call	800a34 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
  8038b8:	d0a4d517 	ldw	r2,-27820(gp)
  8038bc:	10800044 	addi	r2,r2,1
  8038c0:	d0a4d515 	stw	r2,-27820(gp)
  8038c4:	00000606 	br	8038e0 <vTaskDelete+0xb4>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
  8038c8:	d0a4d617 	ldw	r2,-27816(gp)
  8038cc:	10bfffc4 	addi	r2,r2,-1
  8038d0:	d0a4d615 	stw	r2,-27816(gp)
				traceTASK_DELETE( pxTCB );
				prvDeleteTCB( pxTCB );
  8038d4:	e13ffe17 	ldw	r4,-8(fp)
  8038d8:	0804bb80 	call	804bb8 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
  8038dc:	0804bfc0 	call	804bfc <prvResetNextTaskUnblockTime>
			}
		}
		taskEXIT_CRITICAL();
  8038e0:	08050480 	call	805048 <vTaskExitCritical>

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
  8038e4:	d0a4d917 	ldw	r2,-27804(gp)
  8038e8:	10000426 	beq	r2,zero,8038fc <vTaskDelete+0xd0>
		{
			if( pxTCB == pxCurrentTCB )
  8038ec:	d0a4d217 	ldw	r2,-27832(gp)
  8038f0:	e0fffe17 	ldw	r3,-8(fp)
  8038f4:	1880011e 	bne	r3,r2,8038fc <vTaskDelete+0xd0>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
  8038f8:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
  8038fc:	0001883a 	nop
  803900:	e037883a 	mov	sp,fp
  803904:	dfc00117 	ldw	ra,4(sp)
  803908:	df000017 	ldw	fp,0(sp)
  80390c:	dec00204 	addi	sp,sp,8
  803910:	f800283a 	ret

00803914 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
  803914:	defff804 	addi	sp,sp,-32
  803918:	dfc00715 	stw	ra,28(sp)
  80391c:	df000615 	stw	fp,24(sp)
  803920:	df000604 	addi	fp,sp,24
  803924:	e13ffe15 	stw	r4,-8(fp)
  803928:	e17fff15 	stw	r5,-4(fp)
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
  80392c:	e03ffa15 	stw	zero,-24(fp)

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
  803930:	08040940 	call	804094 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
  803934:	d0a4d717 	ldw	r2,-27812(gp)
  803938:	e0bffb15 	stw	r2,-20(fp)

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
  80393c:	e0bffe17 	ldw	r2,-8(fp)
  803940:	10c00017 	ldw	r3,0(r2)
  803944:	e0bfff17 	ldw	r2,-4(fp)
  803948:	1885883a 	add	r2,r3,r2
  80394c:	e0bffc15 	stw	r2,-16(fp)

			if( xConstTickCount < *pxPreviousWakeTime )
  803950:	e0bffe17 	ldw	r2,-8(fp)
  803954:	10800017 	ldw	r2,0(r2)
  803958:	e0fffb17 	ldw	r3,-20(fp)
  80395c:	18800a2e 	bgeu	r3,r2,803988 <vTaskDelayUntil+0x74>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
  803960:	e0bffe17 	ldw	r2,-8(fp)
  803964:	10800017 	ldw	r2,0(r2)
  803968:	e0fffc17 	ldw	r3,-16(fp)
  80396c:	18800f2e 	bgeu	r3,r2,8039ac <vTaskDelayUntil+0x98>
  803970:	e0bffc17 	ldw	r2,-16(fp)
  803974:	e0fffb17 	ldw	r3,-20(fp)
  803978:	18800c2e 	bgeu	r3,r2,8039ac <vTaskDelayUntil+0x98>
				{
					xShouldDelay = pdTRUE;
  80397c:	00800044 	movi	r2,1
  803980:	e0bffa15 	stw	r2,-24(fp)
  803984:	00000906 	br	8039ac <vTaskDelayUntil+0x98>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
  803988:	e0bffe17 	ldw	r2,-8(fp)
  80398c:	10800017 	ldw	r2,0(r2)
  803990:	e0fffc17 	ldw	r3,-16(fp)
  803994:	18800336 	bltu	r3,r2,8039a4 <vTaskDelayUntil+0x90>
  803998:	e0bffc17 	ldw	r2,-16(fp)
  80399c:	e0fffb17 	ldw	r3,-20(fp)
  8039a0:	1880022e 	bgeu	r3,r2,8039ac <vTaskDelayUntil+0x98>
				{
					xShouldDelay = pdTRUE;
  8039a4:	00800044 	movi	r2,1
  8039a8:	e0bffa15 	stw	r2,-24(fp)
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
  8039ac:	e0bffe17 	ldw	r2,-8(fp)
  8039b0:	e0fffc17 	ldw	r3,-16(fp)
  8039b4:	10c00015 	stw	r3,0(r2)

			if( xShouldDelay != pdFALSE )
  8039b8:	e0bffa17 	ldw	r2,-24(fp)
  8039bc:	10000626 	beq	r2,zero,8039d8 <vTaskDelayUntil+0xc4>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
  8039c0:	e0fffc17 	ldw	r3,-16(fp)
  8039c4:	e0bffb17 	ldw	r2,-20(fp)
  8039c8:	1885c83a 	sub	r2,r3,r2
  8039cc:	000b883a 	mov	r5,zero
  8039d0:	1009883a 	mov	r4,r2
  8039d4:	08058680 	call	805868 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
  8039d8:	08040c00 	call	8040c0 <xTaskResumeAll>
  8039dc:	e0bffd15 	stw	r2,-12(fp)

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
  8039e0:	e0bffd17 	ldw	r2,-12(fp)
  8039e4:	1000011e 	bne	r2,zero,8039ec <vTaskDelayUntil+0xd8>
		{
			portYIELD_WITHIN_API();
  8039e8:	003b683a 	trap	0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  8039ec:	0001883a 	nop
  8039f0:	e037883a 	mov	sp,fp
  8039f4:	dfc00117 	ldw	ra,4(sp)
  8039f8:	df000017 	ldw	fp,0(sp)
  8039fc:	dec00204 	addi	sp,sp,8
  803a00:	f800283a 	ret

00803a04 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
  803a04:	defffc04 	addi	sp,sp,-16
  803a08:	dfc00315 	stw	ra,12(sp)
  803a0c:	df000215 	stw	fp,8(sp)
  803a10:	df000204 	addi	fp,sp,8
  803a14:	e13fff15 	stw	r4,-4(fp)
	BaseType_t xAlreadyYielded = pdFALSE;
  803a18:	e03ffe15 	stw	zero,-8(fp)

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
  803a1c:	e0bfff17 	ldw	r2,-4(fp)
  803a20:	10000626 	beq	r2,zero,803a3c <vTaskDelay+0x38>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
  803a24:	08040940 	call	804094 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
  803a28:	000b883a 	mov	r5,zero
  803a2c:	e13fff17 	ldw	r4,-4(fp)
  803a30:	08058680 	call	805868 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
  803a34:	08040c00 	call	8040c0 <xTaskResumeAll>
  803a38:	e0bffe15 	stw	r2,-8(fp)
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
  803a3c:	e0bffe17 	ldw	r2,-8(fp)
  803a40:	1000011e 	bne	r2,zero,803a48 <vTaskDelay+0x44>
		{
			portYIELD_WITHIN_API();
  803a44:	003b683a 	trap	0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  803a48:	0001883a 	nop
  803a4c:	e037883a 	mov	sp,fp
  803a50:	dfc00117 	ldw	ra,4(sp)
  803a54:	df000017 	ldw	fp,0(sp)
  803a58:	dec00204 	addi	sp,sp,8
  803a5c:	f800283a 	ret

00803a60 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
	{
  803a60:	defffb04 	addi	sp,sp,-20
  803a64:	dfc00415 	stw	ra,16(sp)
  803a68:	df000315 	stw	fp,12(sp)
  803a6c:	df000304 	addi	fp,sp,12
  803a70:	e13fff15 	stw	r4,-4(fp)
	TCB_t const *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
  803a74:	0804ff40 	call	804ff4 <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the priority of the task
			that called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
  803a78:	e0bfff17 	ldw	r2,-4(fp)
  803a7c:	1000021e 	bne	r2,zero,803a88 <uxTaskPriorityGet+0x28>
  803a80:	d0a4d217 	ldw	r2,-27832(gp)
  803a84:	00000106 	br	803a8c <uxTaskPriorityGet+0x2c>
  803a88:	e0bfff17 	ldw	r2,-4(fp)
  803a8c:	e0bffd15 	stw	r2,-12(fp)
			uxReturn = pxTCB->uxPriority;
  803a90:	e0bffd17 	ldw	r2,-12(fp)
  803a94:	10800b17 	ldw	r2,44(r2)
  803a98:	e0bffe15 	stw	r2,-8(fp)
		}
		taskEXIT_CRITICAL();
  803a9c:	08050480 	call	805048 <vTaskExitCritical>

		return uxReturn;
  803aa0:	e0bffe17 	ldw	r2,-8(fp)
	}
  803aa4:	e037883a 	mov	sp,fp
  803aa8:	dfc00117 	ldw	ra,4(sp)
  803aac:	df000017 	ldw	fp,0(sp)
  803ab0:	dec00204 	addi	sp,sp,8
  803ab4:	f800283a 	ret

00803ab8 <uxTaskPriorityGetFromISR>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
	{
  803ab8:	defffb04 	addi	sp,sp,-20
  803abc:	df000415 	stw	fp,16(sp)
  803ac0:	df000404 	addi	fp,sp,16
  803ac4:	e13fff15 	stw	r4,-4(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
  803ac8:	e03ffc15 	stw	zero,-16(fp)
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
  803acc:	e0bfff17 	ldw	r2,-4(fp)
  803ad0:	1000021e 	bne	r2,zero,803adc <uxTaskPriorityGetFromISR+0x24>
  803ad4:	d0a4d217 	ldw	r2,-27832(gp)
  803ad8:	00000106 	br	803ae0 <uxTaskPriorityGetFromISR+0x28>
  803adc:	e0bfff17 	ldw	r2,-4(fp)
  803ae0:	e0bffd15 	stw	r2,-12(fp)
			uxReturn = pxTCB->uxPriority;
  803ae4:	e0bffd17 	ldw	r2,-12(fp)
  803ae8:	10800b17 	ldw	r2,44(r2)
  803aec:	e0bffe15 	stw	r2,-8(fp)
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

		return uxReturn;
  803af0:	e0bffe17 	ldw	r2,-8(fp)
	}
  803af4:	e037883a 	mov	sp,fp
  803af8:	df000017 	ldw	fp,0(sp)
  803afc:	dec00104 	addi	sp,sp,4
  803b00:	f800283a 	ret

00803b04 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
  803b04:	defff804 	addi	sp,sp,-32
  803b08:	dfc00715 	stw	ra,28(sp)
  803b0c:	df000615 	stw	fp,24(sp)
  803b10:	df000604 	addi	fp,sp,24
  803b14:	e13ffe15 	stw	r4,-8(fp)
  803b18:	e17fff15 	stw	r5,-4(fp)
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
  803b1c:	e03ffa15 	stw	zero,-24(fp)

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
  803b20:	e0bfff17 	ldw	r2,-4(fp)
  803b24:	10800170 	cmpltui	r2,r2,5
  803b28:	1000021e 	bne	r2,zero,803b34 <vTaskPrioritySet+0x30>
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
  803b2c:	00800104 	movi	r2,4
  803b30:	e0bfff15 	stw	r2,-4(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
  803b34:	0804ff40 	call	804ff4 <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
  803b38:	e0bffe17 	ldw	r2,-8(fp)
  803b3c:	1000021e 	bne	r2,zero,803b48 <vTaskPrioritySet+0x44>
  803b40:	d0a4d217 	ldw	r2,-27832(gp)
  803b44:	00000106 	br	803b4c <vTaskPrioritySet+0x48>
  803b48:	e0bffe17 	ldw	r2,-8(fp)
  803b4c:	e0bffb15 	stw	r2,-20(fp)

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
  803b50:	e0bffb17 	ldw	r2,-20(fp)
  803b54:	10801017 	ldw	r2,64(r2)
  803b58:	e0bffc15 	stw	r2,-16(fp)
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
  803b5c:	e0fffc17 	ldw	r3,-16(fp)
  803b60:	e0bfff17 	ldw	r2,-4(fp)
  803b64:	18804926 	beq	r3,r2,803c8c <vTaskPrioritySet+0x188>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
  803b68:	e0bfff17 	ldw	r2,-4(fp)
  803b6c:	e0fffc17 	ldw	r3,-16(fp)
  803b70:	18800a2e 	bgeu	r3,r2,803b9c <vTaskPrioritySet+0x98>
				{
					if( pxTCB != pxCurrentTCB )
  803b74:	d0a4d217 	ldw	r2,-27832(gp)
  803b78:	e0fffb17 	ldw	r3,-20(fp)
  803b7c:	18800c26 	beq	r3,r2,803bb0 <vTaskPrioritySet+0xac>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
  803b80:	d0a4d217 	ldw	r2,-27832(gp)
  803b84:	10800b17 	ldw	r2,44(r2)
  803b88:	e0ffff17 	ldw	r3,-4(fp)
  803b8c:	18800836 	bltu	r3,r2,803bb0 <vTaskPrioritySet+0xac>
						{
							xYieldRequired = pdTRUE;
  803b90:	00800044 	movi	r2,1
  803b94:	e0bffa15 	stw	r2,-24(fp)
  803b98:	00000506 	br	803bb0 <vTaskPrioritySet+0xac>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
  803b9c:	d0a4d217 	ldw	r2,-27832(gp)
  803ba0:	e0fffb17 	ldw	r3,-20(fp)
  803ba4:	1880021e 	bne	r3,r2,803bb0 <vTaskPrioritySet+0xac>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
  803ba8:	00800044 	movi	r2,1
  803bac:	e0bffa15 	stw	r2,-24(fp)
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
  803bb0:	e0bffb17 	ldw	r2,-20(fp)
  803bb4:	10800b17 	ldw	r2,44(r2)
  803bb8:	e0bffd15 	stw	r2,-12(fp)

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
  803bbc:	e0bffb17 	ldw	r2,-20(fp)
  803bc0:	10c01017 	ldw	r3,64(r2)
  803bc4:	e0bffb17 	ldw	r2,-20(fp)
  803bc8:	10800b17 	ldw	r2,44(r2)
  803bcc:	1880031e 	bne	r3,r2,803bdc <vTaskPrioritySet+0xd8>
					{
						pxTCB->uxPriority = uxNewPriority;
  803bd0:	e0bffb17 	ldw	r2,-20(fp)
  803bd4:	e0ffff17 	ldw	r3,-4(fp)
  803bd8:	10c00b15 	stw	r3,44(r2)
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
  803bdc:	e0bffb17 	ldw	r2,-20(fp)
  803be0:	e0ffff17 	ldw	r3,-4(fp)
  803be4:	10c01015 	stw	r3,64(r2)
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
  803be8:	e0bffb17 	ldw	r2,-20(fp)
  803bec:	10800617 	ldw	r2,24(r2)
  803bf0:	10000516 	blt	r2,zero,803c08 <vTaskPrioritySet+0x104>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  803bf4:	00c00144 	movi	r3,5
  803bf8:	e0bfff17 	ldw	r2,-4(fp)
  803bfc:	1887c83a 	sub	r3,r3,r2
  803c00:	e0bffb17 	ldw	r2,-20(fp)
  803c04:	10c00615 	stw	r3,24(r2)

				/* If the task is in the blocked or suspended list we need do
				nothing more than change its priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
  803c08:	e0bffb17 	ldw	r2,-20(fp)
  803c0c:	10c00517 	ldw	r3,20(r2)
  803c10:	e0bffd17 	ldw	r2,-12(fp)
  803c14:	11000524 	muli	r4,r2,20
  803c18:	00802174 	movhi	r2,133
  803c1c:	10a18c04 	addi	r2,r2,-31184
  803c20:	2085883a 	add	r2,r4,r2
  803c24:	1880161e 	bne	r3,r2,803c80 <vTaskPrioritySet+0x17c>
				{
					/* The task is currently in its ready list - remove before
					adding it to it's new ready list.  As we are in a critical
					section we can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  803c28:	e0bffb17 	ldw	r2,-20(fp)
  803c2c:	10800104 	addi	r2,r2,4
  803c30:	1009883a 	mov	r4,r2
  803c34:	0800b980 	call	800b98 <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
  803c38:	e0bffb17 	ldw	r2,-20(fp)
  803c3c:	10800b17 	ldw	r2,44(r2)
  803c40:	d0e4d817 	ldw	r3,-27808(gp)
  803c44:	1880032e 	bgeu	r3,r2,803c54 <vTaskPrioritySet+0x150>
  803c48:	e0bffb17 	ldw	r2,-20(fp)
  803c4c:	10800b17 	ldw	r2,44(r2)
  803c50:	d0a4d815 	stw	r2,-27808(gp)
  803c54:	e0bffb17 	ldw	r2,-20(fp)
  803c58:	10800b17 	ldw	r2,44(r2)
  803c5c:	10c00524 	muli	r3,r2,20
  803c60:	00802174 	movhi	r2,133
  803c64:	10a18c04 	addi	r2,r2,-31184
  803c68:	1887883a 	add	r3,r3,r2
  803c6c:	e0bffb17 	ldw	r2,-20(fp)
  803c70:	10800104 	addi	r2,r2,4
  803c74:	100b883a 	mov	r5,r2
  803c78:	1809883a 	mov	r4,r3
  803c7c:	0800a340 	call	800a34 <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired != pdFALSE )
  803c80:	e0bffa17 	ldw	r2,-24(fp)
  803c84:	10000126 	beq	r2,zero,803c8c <vTaskPrioritySet+0x188>
				{
					taskYIELD_IF_USING_PREEMPTION();
  803c88:	003b683a 	trap	0
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
  803c8c:	08050480 	call	805048 <vTaskExitCritical>
	}
  803c90:	0001883a 	nop
  803c94:	e037883a 	mov	sp,fp
  803c98:	dfc00117 	ldw	ra,4(sp)
  803c9c:	df000017 	ldw	fp,0(sp)
  803ca0:	dec00204 	addi	sp,sp,8
  803ca4:	f800283a 	ret

00803ca8 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
  803ca8:	defffc04 	addi	sp,sp,-16
  803cac:	dfc00315 	stw	ra,12(sp)
  803cb0:	df000215 	stw	fp,8(sp)
  803cb4:	df000204 	addi	fp,sp,8
  803cb8:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
  803cbc:	0804ff40 	call	804ff4 <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
  803cc0:	e0bfff17 	ldw	r2,-4(fp)
  803cc4:	1000021e 	bne	r2,zero,803cd0 <vTaskSuspend+0x28>
  803cc8:	d0a4d217 	ldw	r2,-27832(gp)
  803ccc:	00000106 	br	803cd4 <vTaskSuspend+0x2c>
  803cd0:	e0bfff17 	ldw	r2,-4(fp)
  803cd4:	e0bffe15 	stw	r2,-8(fp)

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  803cd8:	e0bffe17 	ldw	r2,-8(fp)
  803cdc:	10800104 	addi	r2,r2,4
  803ce0:	1009883a 	mov	r4,r2
  803ce4:	0800b980 	call	800b98 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
  803ce8:	e0bffe17 	ldw	r2,-8(fp)
  803cec:	10800a17 	ldw	r2,40(r2)
  803cf0:	10000426 	beq	r2,zero,803d04 <vTaskSuspend+0x5c>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  803cf4:	e0bffe17 	ldw	r2,-8(fp)
  803cf8:	10800604 	addi	r2,r2,24
  803cfc:	1009883a 	mov	r4,r2
  803d00:	0800b980 	call	800b98 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
  803d04:	e0bffe17 	ldw	r2,-8(fp)
  803d08:	10800104 	addi	r2,r2,4
  803d0c:	100b883a 	mov	r5,r2
  803d10:	01002174 	movhi	r4,133
  803d14:	2121b904 	addi	r4,r4,-31004
  803d18:	0800a340 	call	800a34 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
  803d1c:	e0bffe17 	ldw	r2,-8(fp)
  803d20:	10801303 	ldbu	r2,76(r2)
  803d24:	10803fcc 	andi	r2,r2,255
  803d28:	10800058 	cmpnei	r2,r2,1
  803d2c:	1000021e 	bne	r2,zero,803d38 <vTaskSuspend+0x90>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
  803d30:	e0bffe17 	ldw	r2,-8(fp)
  803d34:	10001305 	stb	zero,76(r2)
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
  803d38:	08050480 	call	805048 <vTaskExitCritical>

		if( xSchedulerRunning != pdFALSE )
  803d3c:	d0a4d917 	ldw	r2,-27804(gp)
  803d40:	10000326 	beq	r2,zero,803d50 <vTaskSuspend+0xa8>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
  803d44:	0804ff40 	call	804ff4 <vTaskEnterCritical>
			{
				prvResetNextTaskUnblockTime();
  803d48:	0804bfc0 	call	804bfc <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
  803d4c:	08050480 	call	805048 <vTaskExitCritical>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
  803d50:	d0a4d217 	ldw	r2,-27832(gp)
  803d54:	e0fffe17 	ldw	r3,-8(fp)
  803d58:	18800c1e 	bne	r3,r2,803d8c <vTaskSuspend+0xe4>
		{
			if( xSchedulerRunning != pdFALSE )
  803d5c:	d0a4d917 	ldw	r2,-27804(gp)
  803d60:	10000226 	beq	r2,zero,803d6c <vTaskSuspend+0xc4>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
  803d64:	003b683a 	trap	0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  803d68:	00000806 	br	803d8c <vTaskSuspend+0xe4>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
  803d6c:	00802174 	movhi	r2,133
  803d70:	10a1b904 	addi	r2,r2,-31004
  803d74:	10c00017 	ldw	r3,0(r2)
  803d78:	d0a4d617 	ldw	r2,-27816(gp)
  803d7c:	1880021e 	bne	r3,r2,803d88 <vTaskSuspend+0xe0>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
  803d80:	d024d215 	stw	zero,-27832(gp)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  803d84:	00000106 	br	803d8c <vTaskSuspend+0xe4>
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
  803d88:	08044c80 	call	8044c8 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  803d8c:	0001883a 	nop
  803d90:	e037883a 	mov	sp,fp
  803d94:	dfc00117 	ldw	ra,4(sp)
  803d98:	df000017 	ldw	fp,0(sp)
  803d9c:	dec00204 	addi	sp,sp,8
  803da0:	f800283a 	ret

00803da4 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
  803da4:	defffc04 	addi	sp,sp,-16
  803da8:	df000315 	stw	fp,12(sp)
  803dac:	df000304 	addi	fp,sp,12
  803db0:	e13fff15 	stw	r4,-4(fp)
	BaseType_t xReturn = pdFALSE;
  803db4:	e03ffd15 	stw	zero,-12(fp)
	const TCB_t * const pxTCB = xTask;
  803db8:	e0bfff17 	ldw	r2,-4(fp)
  803dbc:	e0bffe15 	stw	r2,-8(fp)

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
  803dc0:	e0bffe17 	ldw	r2,-8(fp)
  803dc4:	10c00517 	ldw	r3,20(r2)
  803dc8:	00802174 	movhi	r2,133
  803dcc:	10a1b904 	addi	r2,r2,-31004
  803dd0:	18800a1e 	bne	r3,r2,803dfc <prvTaskIsTaskSuspended+0x58>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
  803dd4:	e0bffe17 	ldw	r2,-8(fp)
  803dd8:	10c00a17 	ldw	r3,40(r2)
  803ddc:	00802174 	movhi	r2,133
  803de0:	10a1af04 	addi	r2,r2,-31044
  803de4:	18800526 	beq	r3,r2,803dfc <prvTaskIsTaskSuspended+0x58>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
  803de8:	e0bffe17 	ldw	r2,-8(fp)
  803dec:	10800a17 	ldw	r2,40(r2)
  803df0:	1000021e 	bne	r2,zero,803dfc <prvTaskIsTaskSuspended+0x58>
				{
					xReturn = pdTRUE;
  803df4:	00800044 	movi	r2,1
  803df8:	e0bffd15 	stw	r2,-12(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
  803dfc:	e0bffd17 	ldw	r2,-12(fp)
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
  803e00:	e037883a 	mov	sp,fp
  803e04:	df000017 	ldw	fp,0(sp)
  803e08:	dec00104 	addi	sp,sp,4
  803e0c:	f800283a 	ret

00803e10 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
  803e10:	defffc04 	addi	sp,sp,-16
  803e14:	dfc00315 	stw	ra,12(sp)
  803e18:	df000215 	stw	fp,8(sp)
  803e1c:	df000204 	addi	fp,sp,8
  803e20:	e13fff15 	stw	r4,-4(fp)
	TCB_t * const pxTCB = xTaskToResume;
  803e24:	e0bfff17 	ldw	r2,-4(fp)
  803e28:	e0bffe15 	stw	r2,-8(fp)
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
  803e2c:	d0a4d217 	ldw	r2,-27832(gp)
  803e30:	e0fffe17 	ldw	r3,-8(fp)
  803e34:	18802326 	beq	r3,r2,803ec4 <vTaskResume+0xb4>
  803e38:	e0bffe17 	ldw	r2,-8(fp)
  803e3c:	10002126 	beq	r2,zero,803ec4 <vTaskResume+0xb4>
		{
			taskENTER_CRITICAL();
  803e40:	0804ff40 	call	804ff4 <vTaskEnterCritical>
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
  803e44:	e13ffe17 	ldw	r4,-8(fp)
  803e48:	0803da40 	call	803da4 <prvTaskIsTaskSuspended>
  803e4c:	10001c26 	beq	r2,zero,803ec0 <vTaskResume+0xb0>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
  803e50:	e0bffe17 	ldw	r2,-8(fp)
  803e54:	10800104 	addi	r2,r2,4
  803e58:	1009883a 	mov	r4,r2
  803e5c:	0800b980 	call	800b98 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
  803e60:	e0bffe17 	ldw	r2,-8(fp)
  803e64:	10800b17 	ldw	r2,44(r2)
  803e68:	d0e4d817 	ldw	r3,-27808(gp)
  803e6c:	1880032e 	bgeu	r3,r2,803e7c <vTaskResume+0x6c>
  803e70:	e0bffe17 	ldw	r2,-8(fp)
  803e74:	10800b17 	ldw	r2,44(r2)
  803e78:	d0a4d815 	stw	r2,-27808(gp)
  803e7c:	e0bffe17 	ldw	r2,-8(fp)
  803e80:	10800b17 	ldw	r2,44(r2)
  803e84:	10c00524 	muli	r3,r2,20
  803e88:	00802174 	movhi	r2,133
  803e8c:	10a18c04 	addi	r2,r2,-31184
  803e90:	1887883a 	add	r3,r3,r2
  803e94:	e0bffe17 	ldw	r2,-8(fp)
  803e98:	10800104 	addi	r2,r2,4
  803e9c:	100b883a 	mov	r5,r2
  803ea0:	1809883a 	mov	r4,r3
  803ea4:	0800a340 	call	800a34 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  803ea8:	e0bffe17 	ldw	r2,-8(fp)
  803eac:	10c00b17 	ldw	r3,44(r2)
  803eb0:	d0a4d217 	ldw	r2,-27832(gp)
  803eb4:	10800b17 	ldw	r2,44(r2)
  803eb8:	18800136 	bltu	r3,r2,803ec0 <vTaskResume+0xb0>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
  803ebc:	003b683a 	trap	0
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
  803ec0:	08050480 	call	805048 <vTaskExitCritical>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  803ec4:	0001883a 	nop
  803ec8:	e037883a 	mov	sp,fp
  803ecc:	dfc00117 	ldw	ra,4(sp)
  803ed0:	df000017 	ldw	fp,0(sp)
  803ed4:	dec00204 	addi	sp,sp,8
  803ed8:	f800283a 	ret

00803edc <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
  803edc:	defffa04 	addi	sp,sp,-24
  803ee0:	dfc00515 	stw	ra,20(sp)
  803ee4:	df000415 	stw	fp,16(sp)
  803ee8:	df000404 	addi	fp,sp,16
  803eec:	e13fff15 	stw	r4,-4(fp)
	BaseType_t xYieldRequired = pdFALSE;
  803ef0:	e03ffc15 	stw	zero,-16(fp)
	TCB_t * const pxTCB = xTaskToResume;
  803ef4:	e0bfff17 	ldw	r2,-4(fp)
  803ef8:	e0bffd15 	stw	r2,-12(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  803efc:	e03ffe15 	stw	zero,-8(fp)
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
  803f00:	e13ffd17 	ldw	r4,-12(fp)
  803f04:	0803da40 	call	803da4 <prvTaskIsTaskSuspended>
  803f08:	10002626 	beq	r2,zero,803fa4 <xTaskResumeFromISR+0xc8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  803f0c:	d0a4e017 	ldw	r2,-27776(gp)
  803f10:	10001e1e 	bne	r2,zero,803f8c <xTaskResumeFromISR+0xb0>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  803f14:	e0bffd17 	ldw	r2,-12(fp)
  803f18:	10c00b17 	ldw	r3,44(r2)
  803f1c:	d0a4d217 	ldw	r2,-27832(gp)
  803f20:	10800b17 	ldw	r2,44(r2)
  803f24:	18800236 	bltu	r3,r2,803f30 <xTaskResumeFromISR+0x54>
					{
						xYieldRequired = pdTRUE;
  803f28:	00800044 	movi	r2,1
  803f2c:	e0bffc15 	stw	r2,-16(fp)
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  803f30:	e0bffd17 	ldw	r2,-12(fp)
  803f34:	10800104 	addi	r2,r2,4
  803f38:	1009883a 	mov	r4,r2
  803f3c:	0800b980 	call	800b98 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
  803f40:	e0bffd17 	ldw	r2,-12(fp)
  803f44:	10800b17 	ldw	r2,44(r2)
  803f48:	d0e4d817 	ldw	r3,-27808(gp)
  803f4c:	1880032e 	bgeu	r3,r2,803f5c <xTaskResumeFromISR+0x80>
  803f50:	e0bffd17 	ldw	r2,-12(fp)
  803f54:	10800b17 	ldw	r2,44(r2)
  803f58:	d0a4d815 	stw	r2,-27808(gp)
  803f5c:	e0bffd17 	ldw	r2,-12(fp)
  803f60:	10800b17 	ldw	r2,44(r2)
  803f64:	10c00524 	muli	r3,r2,20
  803f68:	00802174 	movhi	r2,133
  803f6c:	10a18c04 	addi	r2,r2,-31184
  803f70:	1887883a 	add	r3,r3,r2
  803f74:	e0bffd17 	ldw	r2,-12(fp)
  803f78:	10800104 	addi	r2,r2,4
  803f7c:	100b883a 	mov	r5,r2
  803f80:	1809883a 	mov	r4,r3
  803f84:	0800a340 	call	800a34 <vListInsertEnd>
  803f88:	00000606 	br	803fa4 <xTaskResumeFromISR+0xc8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
  803f8c:	e0bffd17 	ldw	r2,-12(fp)
  803f90:	10800604 	addi	r2,r2,24
  803f94:	100b883a 	mov	r5,r2
  803f98:	01002174 	movhi	r4,133
  803f9c:	2121af04 	addi	r4,r4,-31044
  803fa0:	0800a340 	call	800a34 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
  803fa4:	e0bffc17 	ldw	r2,-16(fp)
	}
  803fa8:	e037883a 	mov	sp,fp
  803fac:	dfc00117 	ldw	ra,4(sp)
  803fb0:	df000017 	ldw	fp,0(sp)
  803fb4:	dec00204 	addi	sp,sp,8
  803fb8:	f800283a 	ret

00803fbc <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
  803fbc:	defffa04 	addi	sp,sp,-24
  803fc0:	dfc00515 	stw	ra,20(sp)
  803fc4:	df000415 	stw	fp,16(sp)
  803fc8:	df000404 	addi	fp,sp,16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
  803fcc:	d0a4df04 	addi	r2,gp,-27780
  803fd0:	d8800115 	stw	r2,4(sp)
  803fd4:	d8000015 	stw	zero,0(sp)
  803fd8:	000f883a 	mov	r7,zero
  803fdc:	01810004 	movi	r6,1024
  803fe0:	01402074 	movhi	r5,129
  803fe4:	29636e04 	addi	r5,r5,-29256
  803fe8:	01002034 	movhi	r4,128
  803fec:	21126804 	addi	r4,r4,18848
  803ff0:	08034640 	call	803464 <xTaskCreate>
  803ff4:	e0bffe15 	stw	r2,-8(fp)
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
  803ff8:	e0bffe17 	ldw	r2,-8(fp)
  803ffc:	10800058 	cmpnei	r2,r2,1
  804000:	10000c1e 	bne	r2,zero,804034 <vTaskStartScheduler+0x78>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  804004:	0005303a 	rdctl	r2,status
  804008:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  80400c:	e0ffff17 	ldw	r3,-4(fp)
  804010:	00bfff84 	movi	r2,-2
  804014:	1884703a 	and	r2,r3,r2
  804018:	1001703a 	wrctl	status,r2
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
  80401c:	00bfffc4 	movi	r2,-1
  804020:	d0a4de15 	stw	r2,-27784(gp)
		xSchedulerRunning = pdTRUE;
  804024:	00800044 	movi	r2,1
  804028:	d0a4d915 	stw	r2,-27804(gp)
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  80402c:	d024d715 	stw	zero,-27812(gp)

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
  804030:	0800d3c0 	call	800d3c <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
  804034:	0001883a 	nop
  804038:	e037883a 	mov	sp,fp
  80403c:	dfc00117 	ldw	ra,4(sp)
  804040:	df000017 	ldw	fp,0(sp)
  804044:	dec00204 	addi	sp,sp,8
  804048:	f800283a 	ret

0080404c <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
  80404c:	defffd04 	addi	sp,sp,-12
  804050:	dfc00215 	stw	ra,8(sp)
  804054:	df000115 	stw	fp,4(sp)
  804058:	df000104 	addi	fp,sp,4
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  80405c:	0005303a 	rdctl	r2,status
  804060:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  804064:	e0ffff17 	ldw	r3,-4(fp)
  804068:	00bfff84 	movi	r2,-2
  80406c:	1884703a 	and	r2,r3,r2
  804070:	1001703a 	wrctl	status,r2
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
	xSchedulerRunning = pdFALSE;
  804074:	d024d915 	stw	zero,-27804(gp)
	vPortEndScheduler();
  804078:	0800d740 	call	800d74 <vPortEndScheduler>
}
  80407c:	0001883a 	nop
  804080:	e037883a 	mov	sp,fp
  804084:	dfc00117 	ldw	ra,4(sp)
  804088:	df000017 	ldw	fp,0(sp)
  80408c:	dec00204 	addi	sp,sp,8
  804090:	f800283a 	ret

00804094 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
  804094:	deffff04 	addi	sp,sp,-4
  804098:	df000015 	stw	fp,0(sp)
  80409c:	d839883a 	mov	fp,sp
	do not otherwise exhibit real time behaviour. */
	portSOFTWARE_BARRIER();

	/* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
	is used to allow calls to vTaskSuspendAll() to nest. */
	++uxSchedulerSuspended;
  8040a0:	d0a4e017 	ldw	r2,-27776(gp)
  8040a4:	10800044 	addi	r2,r2,1
  8040a8:	d0a4e015 	stw	r2,-27776(gp)

	/* Enforces ordering for ports and optimised compilers that may otherwise place
	the above increment elsewhere. */
	portMEMORY_BARRIER();
}
  8040ac:	0001883a 	nop
  8040b0:	e037883a 	mov	sp,fp
  8040b4:	df000017 	ldw	fp,0(sp)
  8040b8:	dec00104 	addi	sp,sp,4
  8040bc:	f800283a 	ret

008040c0 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
  8040c0:	defffb04 	addi	sp,sp,-20
  8040c4:	dfc00415 	stw	ra,16(sp)
  8040c8:	df000315 	stw	fp,12(sp)
  8040cc:	df000304 	addi	fp,sp,12
TCB_t *pxTCB = NULL;
  8040d0:	e03ffd15 	stw	zero,-12(fp)
BaseType_t xAlreadyYielded = pdFALSE;
  8040d4:	e03ffe15 	stw	zero,-8(fp)
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
  8040d8:	0804ff40 	call	804ff4 <vTaskEnterCritical>
	{
		--uxSchedulerSuspended;
  8040dc:	d0a4e017 	ldw	r2,-27776(gp)
  8040e0:	10bfffc4 	addi	r2,r2,-1
  8040e4:	d0a4e015 	stw	r2,-27776(gp)

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  8040e8:	d0a4e017 	ldw	r2,-27776(gp)
  8040ec:	1000431e 	bne	r2,zero,8041fc <xTaskResumeAll+0x13c>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
  8040f0:	d0a4d617 	ldw	r2,-27816(gp)
  8040f4:	10004126 	beq	r2,zero,8041fc <xTaskResumeAll+0x13c>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
  8040f8:	00002606 	br	804194 <xTaskResumeAll+0xd4>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  8040fc:	00802174 	movhi	r2,133
  804100:	10a1af04 	addi	r2,r2,-31044
  804104:	10800317 	ldw	r2,12(r2)
  804108:	10800317 	ldw	r2,12(r2)
  80410c:	e0bffd15 	stw	r2,-12(fp)
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  804110:	e0bffd17 	ldw	r2,-12(fp)
  804114:	10800604 	addi	r2,r2,24
  804118:	1009883a 	mov	r4,r2
  80411c:	0800b980 	call	800b98 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  804120:	e0bffd17 	ldw	r2,-12(fp)
  804124:	10800104 	addi	r2,r2,4
  804128:	1009883a 	mov	r4,r2
  80412c:	0800b980 	call	800b98 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
  804130:	e0bffd17 	ldw	r2,-12(fp)
  804134:	10800b17 	ldw	r2,44(r2)
  804138:	d0e4d817 	ldw	r3,-27808(gp)
  80413c:	1880032e 	bgeu	r3,r2,80414c <xTaskResumeAll+0x8c>
  804140:	e0bffd17 	ldw	r2,-12(fp)
  804144:	10800b17 	ldw	r2,44(r2)
  804148:	d0a4d815 	stw	r2,-27808(gp)
  80414c:	e0bffd17 	ldw	r2,-12(fp)
  804150:	10800b17 	ldw	r2,44(r2)
  804154:	10c00524 	muli	r3,r2,20
  804158:	00802174 	movhi	r2,133
  80415c:	10a18c04 	addi	r2,r2,-31184
  804160:	1887883a 	add	r3,r3,r2
  804164:	e0bffd17 	ldw	r2,-12(fp)
  804168:	10800104 	addi	r2,r2,4
  80416c:	100b883a 	mov	r5,r2
  804170:	1809883a 	mov	r4,r3
  804174:	0800a340 	call	800a34 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  804178:	e0bffd17 	ldw	r2,-12(fp)
  80417c:	10c00b17 	ldw	r3,44(r2)
  804180:	d0a4d217 	ldw	r2,-27832(gp)
  804184:	10800b17 	ldw	r2,44(r2)
  804188:	18800236 	bltu	r3,r2,804194 <xTaskResumeAll+0xd4>
					{
						xYieldPending = pdTRUE;
  80418c:	00800044 	movi	r2,1
  804190:	d0a4db15 	stw	r2,-27796(gp)
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
  804194:	00802174 	movhi	r2,133
  804198:	10a1af04 	addi	r2,r2,-31044
  80419c:	10800017 	ldw	r2,0(r2)
  8041a0:	103fd61e 	bne	r2,zero,8040fc <__alt_mem_onchip_memory2_0+0xff7840fc>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
  8041a4:	e0bffd17 	ldw	r2,-12(fp)
  8041a8:	10000126 	beq	r2,zero,8041b0 <xTaskResumeAll+0xf0>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
  8041ac:	0804bfc0 	call	804bfc <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
  8041b0:	d0a4da17 	ldw	r2,-27800(gp)
  8041b4:	e0bfff15 	stw	r2,-4(fp)

					if( xPendedCounts > ( TickType_t ) 0U )
  8041b8:	e0bfff17 	ldw	r2,-4(fp)
  8041bc:	10000a26 	beq	r2,zero,8041e8 <xTaskResumeAll+0x128>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
  8041c0:	08043180 	call	804318 <xTaskIncrementTick>
  8041c4:	10000226 	beq	r2,zero,8041d0 <xTaskResumeAll+0x110>
							{
								xYieldPending = pdTRUE;
  8041c8:	00800044 	movi	r2,1
  8041cc:	d0a4db15 	stw	r2,-27796(gp)
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--xPendedCounts;
  8041d0:	e0bfff17 	ldw	r2,-4(fp)
  8041d4:	10bfffc4 	addi	r2,r2,-1
  8041d8:	e0bfff15 	stw	r2,-4(fp)
						} while( xPendedCounts > ( TickType_t ) 0U );
  8041dc:	e0bfff17 	ldw	r2,-4(fp)
  8041e0:	103ff71e 	bne	r2,zero,8041c0 <__alt_mem_onchip_memory2_0+0xff7841c0>

						xPendedTicks = 0;
  8041e4:	d024da15 	stw	zero,-27800(gp)
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
  8041e8:	d0a4db17 	ldw	r2,-27796(gp)
  8041ec:	10000326 	beq	r2,zero,8041fc <xTaskResumeAll+0x13c>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
  8041f0:	00800044 	movi	r2,1
  8041f4:	e0bffe15 	stw	r2,-8(fp)
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
  8041f8:	003b683a 	trap	0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
  8041fc:	08050480 	call	805048 <vTaskExitCritical>

	return xAlreadyYielded;
  804200:	e0bffe17 	ldw	r2,-8(fp)
}
  804204:	e037883a 	mov	sp,fp
  804208:	dfc00117 	ldw	ra,4(sp)
  80420c:	df000017 	ldw	fp,0(sp)
  804210:	dec00204 	addi	sp,sp,8
  804214:	f800283a 	ret

00804218 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
  804218:	defffe04 	addi	sp,sp,-8
  80421c:	df000115 	stw	fp,4(sp)
  804220:	df000104 	addi	fp,sp,4
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
	{
		xTicks = xTickCount;
  804224:	d0a4d717 	ldw	r2,-27812(gp)
  804228:	e0bfff15 	stw	r2,-4(fp)
	}
	portTICK_TYPE_EXIT_CRITICAL();

	return xTicks;
  80422c:	e0bfff17 	ldw	r2,-4(fp)
}
  804230:	e037883a 	mov	sp,fp
  804234:	df000017 	ldw	fp,0(sp)
  804238:	dec00104 	addi	sp,sp,4
  80423c:	f800283a 	ret

00804240 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
  804240:	defffd04 	addi	sp,sp,-12
  804244:	df000215 	stw	fp,8(sp)
  804248:	df000204 	addi	fp,sp,8
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
  80424c:	e03ffe15 	stw	zero,-8(fp)
	{
		xReturn = xTickCount;
  804250:	d0a4d717 	ldw	r2,-27812(gp)
  804254:	e0bfff15 	stw	r2,-4(fp)
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
  804258:	e0bfff17 	ldw	r2,-4(fp)
}
  80425c:	e037883a 	mov	sp,fp
  804260:	df000017 	ldw	fp,0(sp)
  804264:	dec00104 	addi	sp,sp,4
  804268:	f800283a 	ret

0080426c <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
  80426c:	deffff04 	addi	sp,sp,-4
  804270:	df000015 	stw	fp,0(sp)
  804274:	d839883a 	mov	fp,sp
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
  804278:	d0a4d617 	ldw	r2,-27816(gp)
}
  80427c:	e037883a 	mov	sp,fp
  804280:	df000017 	ldw	fp,0(sp)
  804284:	dec00104 	addi	sp,sp,4
  804288:	f800283a 	ret

0080428c <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
  80428c:	defffd04 	addi	sp,sp,-12
  804290:	df000215 	stw	fp,8(sp)
  804294:	df000204 	addi	fp,sp,8
  804298:	e13fff15 	stw	r4,-4(fp)
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
  80429c:	e0bfff17 	ldw	r2,-4(fp)
  8042a0:	1000021e 	bne	r2,zero,8042ac <pcTaskGetName+0x20>
  8042a4:	d0a4d217 	ldw	r2,-27832(gp)
  8042a8:	00000106 	br	8042b0 <pcTaskGetName+0x24>
  8042ac:	e0bfff17 	ldw	r2,-4(fp)
  8042b0:	e0bffe15 	stw	r2,-8(fp)
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
  8042b4:	e0bffe17 	ldw	r2,-8(fp)
  8042b8:	10800d04 	addi	r2,r2,52
}
  8042bc:	e037883a 	mov	sp,fp
  8042c0:	df000017 	ldw	fp,0(sp)
  8042c4:	dec00104 	addi	sp,sp,4
  8042c8:	f800283a 	ret

008042cc <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
  8042cc:	defffc04 	addi	sp,sp,-16
  8042d0:	dfc00315 	stw	ra,12(sp)
  8042d4:	df000215 	stw	fp,8(sp)
  8042d8:	df000204 	addi	fp,sp,8
  8042dc:	e13fff15 	stw	r4,-4(fp)
BaseType_t xYieldRequired = pdFALSE;
  8042e0:	e03ffe15 	stw	zero,-8(fp)
	relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
	configASSERT( uxSchedulerSuspended == 0 );

	/* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
	the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
	vTaskSuspendAll();
  8042e4:	08040940 	call	804094 <vTaskSuspendAll>
	xPendedTicks += xTicksToCatchUp;
  8042e8:	d0e4da17 	ldw	r3,-27800(gp)
  8042ec:	e0bfff17 	ldw	r2,-4(fp)
  8042f0:	1885883a 	add	r2,r3,r2
  8042f4:	d0a4da15 	stw	r2,-27800(gp)
	xYieldRequired = xTaskResumeAll();
  8042f8:	08040c00 	call	8040c0 <xTaskResumeAll>
  8042fc:	e0bffe15 	stw	r2,-8(fp)

	return xYieldRequired;
  804300:	e0bffe17 	ldw	r2,-8(fp)
}
  804304:	e037883a 	mov	sp,fp
  804308:	dfc00117 	ldw	ra,4(sp)
  80430c:	df000017 	ldw	fp,0(sp)
  804310:	dec00204 	addi	sp,sp,8
  804314:	f800283a 	ret

00804318 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
  804318:	defff904 	addi	sp,sp,-28
  80431c:	dfc00615 	stw	ra,24(sp)
  804320:	df000515 	stw	fp,20(sp)
  804324:	df000504 	addi	fp,sp,20
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
  804328:	e03ffb15 	stw	zero,-20(fp)

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  80432c:	d0a4e017 	ldw	r2,-27776(gp)
  804330:	10005c1e 	bne	r2,zero,8044a4 <xTaskIncrementTick+0x18c>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
  804334:	d0a4d717 	ldw	r2,-27812(gp)
  804338:	10800044 	addi	r2,r2,1
  80433c:	e0bffc15 	stw	r2,-16(fp)

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
  804340:	e0bffc17 	ldw	r2,-16(fp)
  804344:	d0a4d715 	stw	r2,-27812(gp)

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
  804348:	e0bffc17 	ldw	r2,-16(fp)
  80434c:	10000a1e 	bne	r2,zero,804378 <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
  804350:	d0a4d317 	ldw	r2,-27828(gp)
  804354:	e0bffd15 	stw	r2,-12(fp)
  804358:	d0a4d417 	ldw	r2,-27824(gp)
  80435c:	d0a4d315 	stw	r2,-27828(gp)
  804360:	e0bffd17 	ldw	r2,-12(fp)
  804364:	d0a4d415 	stw	r2,-27824(gp)
  804368:	d0a4dc17 	ldw	r2,-27792(gp)
  80436c:	10800044 	addi	r2,r2,1
  804370:	d0a4dc15 	stw	r2,-27792(gp)
  804374:	0804bfc0 	call	804bfc <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
  804378:	d0a4de17 	ldw	r2,-27784(gp)
  80437c:	e0fffc17 	ldw	r3,-16(fp)
  804380:	18803836 	bltu	r3,r2,804464 <xTaskIncrementTick+0x14c>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  804384:	d0a4d317 	ldw	r2,-27828(gp)
  804388:	10800017 	ldw	r2,0(r2)
  80438c:	1000031e 	bne	r2,zero,80439c <xTaskIncrementTick+0x84>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  804390:	00bfffc4 	movi	r2,-1
  804394:	d0a4de15 	stw	r2,-27784(gp)
					break;
  804398:	00003206 	br	804464 <xTaskIncrementTick+0x14c>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  80439c:	d0a4d317 	ldw	r2,-27828(gp)
  8043a0:	10800317 	ldw	r2,12(r2)
  8043a4:	10800317 	ldw	r2,12(r2)
  8043a8:	e0bffe15 	stw	r2,-8(fp)
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
  8043ac:	e0bffe17 	ldw	r2,-8(fp)
  8043b0:	10800117 	ldw	r2,4(r2)
  8043b4:	e0bfff15 	stw	r2,-4(fp)

					if( xConstTickCount < xItemValue )
  8043b8:	e0fffc17 	ldw	r3,-16(fp)
  8043bc:	e0bfff17 	ldw	r2,-4(fp)
  8043c0:	1880032e 	bgeu	r3,r2,8043d0 <xTaskIncrementTick+0xb8>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
  8043c4:	e0bfff17 	ldw	r2,-4(fp)
  8043c8:	d0a4de15 	stw	r2,-27784(gp)
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
  8043cc:	00002506 	br	804464 <xTaskIncrementTick+0x14c>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  8043d0:	e0bffe17 	ldw	r2,-8(fp)
  8043d4:	10800104 	addi	r2,r2,4
  8043d8:	1009883a 	mov	r4,r2
  8043dc:	0800b980 	call	800b98 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
  8043e0:	e0bffe17 	ldw	r2,-8(fp)
  8043e4:	10800a17 	ldw	r2,40(r2)
  8043e8:	10000426 	beq	r2,zero,8043fc <xTaskIncrementTick+0xe4>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  8043ec:	e0bffe17 	ldw	r2,-8(fp)
  8043f0:	10800604 	addi	r2,r2,24
  8043f4:	1009883a 	mov	r4,r2
  8043f8:	0800b980 	call	800b98 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
  8043fc:	e0bffe17 	ldw	r2,-8(fp)
  804400:	10800b17 	ldw	r2,44(r2)
  804404:	d0e4d817 	ldw	r3,-27808(gp)
  804408:	1880032e 	bgeu	r3,r2,804418 <xTaskIncrementTick+0x100>
  80440c:	e0bffe17 	ldw	r2,-8(fp)
  804410:	10800b17 	ldw	r2,44(r2)
  804414:	d0a4d815 	stw	r2,-27808(gp)
  804418:	e0bffe17 	ldw	r2,-8(fp)
  80441c:	10800b17 	ldw	r2,44(r2)
  804420:	10c00524 	muli	r3,r2,20
  804424:	00802174 	movhi	r2,133
  804428:	10a18c04 	addi	r2,r2,-31184
  80442c:	1887883a 	add	r3,r3,r2
  804430:	e0bffe17 	ldw	r2,-8(fp)
  804434:	10800104 	addi	r2,r2,4
  804438:	100b883a 	mov	r5,r2
  80443c:	1809883a 	mov	r4,r3
  804440:	0800a340 	call	800a34 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  804444:	e0bffe17 	ldw	r2,-8(fp)
  804448:	10c00b17 	ldw	r3,44(r2)
  80444c:	d0a4d217 	ldw	r2,-27832(gp)
  804450:	10800b17 	ldw	r2,44(r2)
  804454:	18bfcb36 	bltu	r3,r2,804384 <__alt_mem_onchip_memory2_0+0xff784384>
						{
							xSwitchRequired = pdTRUE;
  804458:	00800044 	movi	r2,1
  80445c:	e0bffb15 	stw	r2,-20(fp)
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_PREEMPTION */
				}
			}
  804460:	003fc806 	br	804384 <__alt_mem_onchip_memory2_0+0xff784384>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
  804464:	d0a4d217 	ldw	r2,-27832(gp)
  804468:	10c00b17 	ldw	r3,44(r2)
  80446c:	00802174 	movhi	r2,133
  804470:	10a18c04 	addi	r2,r2,-31184
  804474:	18c00524 	muli	r3,r3,20
  804478:	10c5883a 	add	r2,r2,r3
  80447c:	10800017 	ldw	r2,0(r2)
  804480:	108000b0 	cmpltui	r2,r2,2
  804484:	1000021e 	bne	r2,zero,804490 <xTaskIncrementTick+0x178>
			{
				xSwitchRequired = pdTRUE;
  804488:	00800044 	movi	r2,1
  80448c:	e0bffb15 	stw	r2,-20(fp)
		}
		#endif /* configUSE_TICK_HOOK */

		#if ( configUSE_PREEMPTION == 1 )
		{
			if( xYieldPending != pdFALSE )
  804490:	d0a4db17 	ldw	r2,-27796(gp)
  804494:	10000626 	beq	r2,zero,8044b0 <xTaskIncrementTick+0x198>
			{
				xSwitchRequired = pdTRUE;
  804498:	00800044 	movi	r2,1
  80449c:	e0bffb15 	stw	r2,-20(fp)
  8044a0:	00000306 	br	8044b0 <xTaskIncrementTick+0x198>
		}
		#endif /* configUSE_PREEMPTION */
	}
	else
	{
		++xPendedTicks;
  8044a4:	d0a4da17 	ldw	r2,-27800(gp)
  8044a8:	10800044 	addi	r2,r2,1
  8044ac:	d0a4da15 	stw	r2,-27800(gp)
			vApplicationTickHook();
		}
		#endif
	}

	return xSwitchRequired;
  8044b0:	e0bffb17 	ldw	r2,-20(fp)
}
  8044b4:	e037883a 	mov	sp,fp
  8044b8:	dfc00117 	ldw	ra,4(sp)
  8044bc:	df000017 	ldw	fp,0(sp)
  8044c0:	dec00204 	addi	sp,sp,8
  8044c4:	f800283a 	ret

008044c8 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
  8044c8:	defffd04 	addi	sp,sp,-12
  8044cc:	df000215 	stw	fp,8(sp)
  8044d0:	df000204 	addi	fp,sp,8
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
  8044d4:	d0a4e017 	ldw	r2,-27776(gp)
  8044d8:	10000326 	beq	r2,zero,8044e8 <vTaskSwitchContext+0x20>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
  8044dc:	00800044 	movi	r2,1
  8044e0:	d0a4db15 	stw	r2,-27796(gp)
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
  8044e4:	00002906 	br	80458c <vTaskSwitchContext+0xc4>
		switch. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xYieldPending = pdFALSE;
  8044e8:	d024db15 	stw	zero,-27796(gp)
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  8044ec:	d0a4d817 	ldw	r2,-27808(gp)
  8044f0:	e0bffe15 	stw	r2,-8(fp)
  8044f4:	00000306 	br	804504 <vTaskSwitchContext+0x3c>
  8044f8:	e0bffe17 	ldw	r2,-8(fp)
  8044fc:	10bfffc4 	addi	r2,r2,-1
  804500:	e0bffe15 	stw	r2,-8(fp)
  804504:	00802174 	movhi	r2,133
  804508:	10a18c04 	addi	r2,r2,-31184
  80450c:	e0fffe17 	ldw	r3,-8(fp)
  804510:	18c00524 	muli	r3,r3,20
  804514:	10c5883a 	add	r2,r2,r3
  804518:	10800017 	ldw	r2,0(r2)
  80451c:	103ff626 	beq	r2,zero,8044f8 <__alt_mem_onchip_memory2_0+0xff7844f8>
  804520:	e0bffe17 	ldw	r2,-8(fp)
  804524:	10c00524 	muli	r3,r2,20
  804528:	00802174 	movhi	r2,133
  80452c:	10a18c04 	addi	r2,r2,-31184
  804530:	1885883a 	add	r2,r3,r2
  804534:	e0bfff15 	stw	r2,-4(fp)
  804538:	e0bfff17 	ldw	r2,-4(fp)
  80453c:	10800117 	ldw	r2,4(r2)
  804540:	10c00117 	ldw	r3,4(r2)
  804544:	e0bfff17 	ldw	r2,-4(fp)
  804548:	10c00115 	stw	r3,4(r2)
  80454c:	e0bfff17 	ldw	r2,-4(fp)
  804550:	10c00117 	ldw	r3,4(r2)
  804554:	e0bfff17 	ldw	r2,-4(fp)
  804558:	10800204 	addi	r2,r2,8
  80455c:	1880051e 	bne	r3,r2,804574 <vTaskSwitchContext+0xac>
  804560:	e0bfff17 	ldw	r2,-4(fp)
  804564:	10800117 	ldw	r2,4(r2)
  804568:	10c00117 	ldw	r3,4(r2)
  80456c:	e0bfff17 	ldw	r2,-4(fp)
  804570:	10c00115 	stw	r3,4(r2)
  804574:	e0bfff17 	ldw	r2,-4(fp)
  804578:	10800117 	ldw	r2,4(r2)
  80457c:	10800317 	ldw	r2,12(r2)
  804580:	d0a4d215 	stw	r2,-27832(gp)
  804584:	e0bffe17 	ldw	r2,-8(fp)
  804588:	d0a4d815 	stw	r2,-27808(gp)
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
  80458c:	0001883a 	nop
  804590:	e037883a 	mov	sp,fp
  804594:	df000017 	ldw	fp,0(sp)
  804598:	dec00104 	addi	sp,sp,4
  80459c:	f800283a 	ret

008045a0 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
  8045a0:	defffc04 	addi	sp,sp,-16
  8045a4:	dfc00315 	stw	ra,12(sp)
  8045a8:	df000215 	stw	fp,8(sp)
  8045ac:	df000204 	addi	fp,sp,8
  8045b0:	e13ffe15 	stw	r4,-8(fp)
  8045b4:	e17fff15 	stw	r5,-4(fp)

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
  8045b8:	d0a4d217 	ldw	r2,-27832(gp)
  8045bc:	10800604 	addi	r2,r2,24
  8045c0:	100b883a 	mov	r5,r2
  8045c4:	e13ffe17 	ldw	r4,-8(fp)
  8045c8:	0800ac00 	call	800ac0 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
  8045cc:	01400044 	movi	r5,1
  8045d0:	e13fff17 	ldw	r4,-4(fp)
  8045d4:	08058680 	call	805868 <prvAddCurrentTaskToDelayedList>
}
  8045d8:	0001883a 	nop
  8045dc:	e037883a 	mov	sp,fp
  8045e0:	dfc00117 	ldw	ra,4(sp)
  8045e4:	df000017 	ldw	fp,0(sp)
  8045e8:	dec00204 	addi	sp,sp,8
  8045ec:	f800283a 	ret

008045f0 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
  8045f0:	defffb04 	addi	sp,sp,-20
  8045f4:	dfc00415 	stw	ra,16(sp)
  8045f8:	df000315 	stw	fp,12(sp)
  8045fc:	df000304 	addi	fp,sp,12
  804600:	e13ffd15 	stw	r4,-12(fp)
  804604:	e17ffe15 	stw	r5,-8(fp)
  804608:	e1bfff15 	stw	r6,-4(fp)
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
  80460c:	d0a4d217 	ldw	r2,-27832(gp)
  804610:	e0fffe17 	ldw	r3,-8(fp)
  804614:	18e00034 	orhi	r3,r3,32768
  804618:	10c00615 	stw	r3,24(r2)
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
  80461c:	d0a4d217 	ldw	r2,-27832(gp)
  804620:	10800604 	addi	r2,r2,24
  804624:	100b883a 	mov	r5,r2
  804628:	e13ffd17 	ldw	r4,-12(fp)
  80462c:	0800a340 	call	800a34 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
  804630:	01400044 	movi	r5,1
  804634:	e13fff17 	ldw	r4,-4(fp)
  804638:	08058680 	call	805868 <prvAddCurrentTaskToDelayedList>
}
  80463c:	0001883a 	nop
  804640:	e037883a 	mov	sp,fp
  804644:	dfc00117 	ldw	ra,4(sp)
  804648:	df000017 	ldw	fp,0(sp)
  80464c:	dec00204 	addi	sp,sp,8
  804650:	f800283a 	ret

00804654 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
  804654:	defffb04 	addi	sp,sp,-20
  804658:	dfc00415 	stw	ra,16(sp)
  80465c:	df000315 	stw	fp,12(sp)
  804660:	df000304 	addi	fp,sp,12
  804664:	e13fff15 	stw	r4,-4(fp)
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  804668:	e0bfff17 	ldw	r2,-4(fp)
  80466c:	10800317 	ldw	r2,12(r2)
  804670:	10800317 	ldw	r2,12(r2)
  804674:	e0bffe15 	stw	r2,-8(fp)
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
  804678:	e0bffe17 	ldw	r2,-8(fp)
  80467c:	10800604 	addi	r2,r2,24
  804680:	1009883a 	mov	r4,r2
  804684:	0800b980 	call	800b98 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  804688:	d0a4e017 	ldw	r2,-27776(gp)
  80468c:	1000171e 	bne	r2,zero,8046ec <xTaskRemoveFromEventList+0x98>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
  804690:	e0bffe17 	ldw	r2,-8(fp)
  804694:	10800104 	addi	r2,r2,4
  804698:	1009883a 	mov	r4,r2
  80469c:	0800b980 	call	800b98 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
  8046a0:	e0bffe17 	ldw	r2,-8(fp)
  8046a4:	10800b17 	ldw	r2,44(r2)
  8046a8:	d0e4d817 	ldw	r3,-27808(gp)
  8046ac:	1880032e 	bgeu	r3,r2,8046bc <xTaskRemoveFromEventList+0x68>
  8046b0:	e0bffe17 	ldw	r2,-8(fp)
  8046b4:	10800b17 	ldw	r2,44(r2)
  8046b8:	d0a4d815 	stw	r2,-27808(gp)
  8046bc:	e0bffe17 	ldw	r2,-8(fp)
  8046c0:	10800b17 	ldw	r2,44(r2)
  8046c4:	10c00524 	muli	r3,r2,20
  8046c8:	00802174 	movhi	r2,133
  8046cc:	10a18c04 	addi	r2,r2,-31184
  8046d0:	1887883a 	add	r3,r3,r2
  8046d4:	e0bffe17 	ldw	r2,-8(fp)
  8046d8:	10800104 	addi	r2,r2,4
  8046dc:	100b883a 	mov	r5,r2
  8046e0:	1809883a 	mov	r4,r3
  8046e4:	0800a340 	call	800a34 <vListInsertEnd>
  8046e8:	00000606 	br	804704 <xTaskRemoveFromEventList+0xb0>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
  8046ec:	e0bffe17 	ldw	r2,-8(fp)
  8046f0:	10800604 	addi	r2,r2,24
  8046f4:	100b883a 	mov	r5,r2
  8046f8:	01002174 	movhi	r4,133
  8046fc:	2121af04 	addi	r4,r4,-31044
  804700:	0800a340 	call	800a34 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
  804704:	e0bffe17 	ldw	r2,-8(fp)
  804708:	10800b17 	ldw	r2,44(r2)
  80470c:	d0e4d217 	ldw	r3,-27832(gp)
  804710:	18c00b17 	ldw	r3,44(r3)
  804714:	1880052e 	bgeu	r3,r2,80472c <xTaskRemoveFromEventList+0xd8>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
  804718:	00800044 	movi	r2,1
  80471c:	e0bffd15 	stw	r2,-12(fp)

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
  804720:	00800044 	movi	r2,1
  804724:	d0a4db15 	stw	r2,-27796(gp)
  804728:	00000106 	br	804730 <xTaskRemoveFromEventList+0xdc>
	}
	else
	{
		xReturn = pdFALSE;
  80472c:	e03ffd15 	stw	zero,-12(fp)
	}

	return xReturn;
  804730:	e0bffd17 	ldw	r2,-12(fp)
}
  804734:	e037883a 	mov	sp,fp
  804738:	dfc00117 	ldw	ra,4(sp)
  80473c:	df000017 	ldw	fp,0(sp)
  804740:	dec00204 	addi	sp,sp,8
  804744:	f800283a 	ret

00804748 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
  804748:	defffb04 	addi	sp,sp,-20
  80474c:	dfc00415 	stw	ra,16(sp)
  804750:	df000315 	stw	fp,12(sp)
  804754:	df000304 	addi	fp,sp,12
  804758:	e13ffe15 	stw	r4,-8(fp)
  80475c:	e17fff15 	stw	r5,-4(fp)
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
  804760:	e0bfff17 	ldw	r2,-4(fp)
  804764:	10e00034 	orhi	r3,r2,32768
  804768:	e0bffe17 	ldw	r2,-8(fp)
  80476c:	10c00015 	stw	r3,0(r2)

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  804770:	e0bffe17 	ldw	r2,-8(fp)
  804774:	10800317 	ldw	r2,12(r2)
  804778:	e0bffd15 	stw	r2,-12(fp)
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
  80477c:	e13ffe17 	ldw	r4,-8(fp)
  804780:	0800b980 	call	800b98 <uxListRemove>
	#endif

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
  804784:	e0bffd17 	ldw	r2,-12(fp)
  804788:	10800104 	addi	r2,r2,4
  80478c:	1009883a 	mov	r4,r2
  804790:	0800b980 	call	800b98 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
  804794:	e0bffd17 	ldw	r2,-12(fp)
  804798:	10800b17 	ldw	r2,44(r2)
  80479c:	d0e4d817 	ldw	r3,-27808(gp)
  8047a0:	1880032e 	bgeu	r3,r2,8047b0 <vTaskRemoveFromUnorderedEventList+0x68>
  8047a4:	e0bffd17 	ldw	r2,-12(fp)
  8047a8:	10800b17 	ldw	r2,44(r2)
  8047ac:	d0a4d815 	stw	r2,-27808(gp)
  8047b0:	e0bffd17 	ldw	r2,-12(fp)
  8047b4:	10800b17 	ldw	r2,44(r2)
  8047b8:	10c00524 	muli	r3,r2,20
  8047bc:	00802174 	movhi	r2,133
  8047c0:	10a18c04 	addi	r2,r2,-31184
  8047c4:	1887883a 	add	r3,r3,r2
  8047c8:	e0bffd17 	ldw	r2,-12(fp)
  8047cc:	10800104 	addi	r2,r2,4
  8047d0:	100b883a 	mov	r5,r2
  8047d4:	1809883a 	mov	r4,r3
  8047d8:	0800a340 	call	800a34 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
  8047dc:	e0bffd17 	ldw	r2,-12(fp)
  8047e0:	10800b17 	ldw	r2,44(r2)
  8047e4:	d0e4d217 	ldw	r3,-27832(gp)
  8047e8:	18c00b17 	ldw	r3,44(r3)
  8047ec:	1880022e 	bgeu	r3,r2,8047f8 <vTaskRemoveFromUnorderedEventList+0xb0>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
  8047f0:	00800044 	movi	r2,1
  8047f4:	d0a4db15 	stw	r2,-27796(gp)
	}
}
  8047f8:	0001883a 	nop
  8047fc:	e037883a 	mov	sp,fp
  804800:	dfc00117 	ldw	ra,4(sp)
  804804:	df000017 	ldw	fp,0(sp)
  804808:	dec00204 	addi	sp,sp,8
  80480c:	f800283a 	ret

00804810 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
  804810:	defffd04 	addi	sp,sp,-12
  804814:	dfc00215 	stw	ra,8(sp)
  804818:	df000115 	stw	fp,4(sp)
  80481c:	df000104 	addi	fp,sp,4
  804820:	e13fff15 	stw	r4,-4(fp)
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
  804824:	0804ff40 	call	804ff4 <vTaskEnterCritical>
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
  804828:	d0e4dc17 	ldw	r3,-27792(gp)
  80482c:	e0bfff17 	ldw	r2,-4(fp)
  804830:	10c00015 	stw	r3,0(r2)
		pxTimeOut->xTimeOnEntering = xTickCount;
  804834:	d0e4d717 	ldw	r3,-27812(gp)
  804838:	e0bfff17 	ldw	r2,-4(fp)
  80483c:	10c00115 	stw	r3,4(r2)
	}
	taskEXIT_CRITICAL();
  804840:	08050480 	call	805048 <vTaskExitCritical>
}
  804844:	0001883a 	nop
  804848:	e037883a 	mov	sp,fp
  80484c:	dfc00117 	ldw	ra,4(sp)
  804850:	df000017 	ldw	fp,0(sp)
  804854:	dec00204 	addi	sp,sp,8
  804858:	f800283a 	ret

0080485c <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
  80485c:	defffe04 	addi	sp,sp,-8
  804860:	df000115 	stw	fp,4(sp)
  804864:	df000104 	addi	fp,sp,4
  804868:	e13fff15 	stw	r4,-4(fp)
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
  80486c:	d0e4dc17 	ldw	r3,-27792(gp)
  804870:	e0bfff17 	ldw	r2,-4(fp)
  804874:	10c00015 	stw	r3,0(r2)
	pxTimeOut->xTimeOnEntering = xTickCount;
  804878:	d0e4d717 	ldw	r3,-27812(gp)
  80487c:	e0bfff17 	ldw	r2,-4(fp)
  804880:	10c00115 	stw	r3,4(r2)
}
  804884:	0001883a 	nop
  804888:	e037883a 	mov	sp,fp
  80488c:	df000017 	ldw	fp,0(sp)
  804890:	dec00104 	addi	sp,sp,4
  804894:	f800283a 	ret

00804898 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
  804898:	defff904 	addi	sp,sp,-28
  80489c:	dfc00615 	stw	ra,24(sp)
  8048a0:	df000515 	stw	fp,20(sp)
  8048a4:	df000504 	addi	fp,sp,20
  8048a8:	e13ffe15 	stw	r4,-8(fp)
  8048ac:	e17fff15 	stw	r5,-4(fp)
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
  8048b0:	0804ff40 	call	804ff4 <vTaskEnterCritical>
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
  8048b4:	d0a4d717 	ldw	r2,-27812(gp)
  8048b8:	e0bffc15 	stw	r2,-16(fp)
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
  8048bc:	e0bffe17 	ldw	r2,-8(fp)
  8048c0:	10800117 	ldw	r2,4(r2)
  8048c4:	e0fffc17 	ldw	r3,-16(fp)
  8048c8:	1885c83a 	sub	r2,r3,r2
  8048cc:	e0bffd15 	stw	r2,-12(fp)
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
  8048d0:	e0bfff17 	ldw	r2,-4(fp)
  8048d4:	10800017 	ldw	r2,0(r2)
  8048d8:	10bfffd8 	cmpnei	r2,r2,-1
  8048dc:	1000021e 	bne	r2,zero,8048e8 <xTaskCheckForTimeOut+0x50>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
  8048e0:	e03ffb15 	stw	zero,-20(fp)
  8048e4:	00001d06 	br	80495c <xTaskCheckForTimeOut+0xc4>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
  8048e8:	e0bffe17 	ldw	r2,-8(fp)
  8048ec:	10c00017 	ldw	r3,0(r2)
  8048f0:	d0a4dc17 	ldw	r2,-27792(gp)
  8048f4:	18800726 	beq	r3,r2,804914 <xTaskCheckForTimeOut+0x7c>
  8048f8:	e0bffe17 	ldw	r2,-8(fp)
  8048fc:	10800117 	ldw	r2,4(r2)
  804900:	e0fffc17 	ldw	r3,-16(fp)
  804904:	18800336 	bltu	r3,r2,804914 <xTaskCheckForTimeOut+0x7c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
  804908:	00800044 	movi	r2,1
  80490c:	e0bffb15 	stw	r2,-20(fp)
  804910:	00001206 	br	80495c <xTaskCheckForTimeOut+0xc4>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
  804914:	e0bfff17 	ldw	r2,-4(fp)
  804918:	10800017 	ldw	r2,0(r2)
  80491c:	e0fffd17 	ldw	r3,-12(fp)
  804920:	18800a2e 	bgeu	r3,r2,80494c <xTaskCheckForTimeOut+0xb4>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
  804924:	e0bfff17 	ldw	r2,-4(fp)
  804928:	10c00017 	ldw	r3,0(r2)
  80492c:	e0bffd17 	ldw	r2,-12(fp)
  804930:	1887c83a 	sub	r3,r3,r2
  804934:	e0bfff17 	ldw	r2,-4(fp)
  804938:	10c00015 	stw	r3,0(r2)
			vTaskInternalSetTimeOutState( pxTimeOut );
  80493c:	e13ffe17 	ldw	r4,-8(fp)
  804940:	080485c0 	call	80485c <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
  804944:	e03ffb15 	stw	zero,-20(fp)
  804948:	00000406 	br	80495c <xTaskCheckForTimeOut+0xc4>
		}
		else
		{
			*pxTicksToWait = 0;
  80494c:	e0bfff17 	ldw	r2,-4(fp)
  804950:	10000015 	stw	zero,0(r2)
			xReturn = pdTRUE;
  804954:	00800044 	movi	r2,1
  804958:	e0bffb15 	stw	r2,-20(fp)
		}
	}
	taskEXIT_CRITICAL();
  80495c:	08050480 	call	805048 <vTaskExitCritical>

	return xReturn;
  804960:	e0bffb17 	ldw	r2,-20(fp)
}
  804964:	e037883a 	mov	sp,fp
  804968:	dfc00117 	ldw	ra,4(sp)
  80496c:	df000017 	ldw	fp,0(sp)
  804970:	dec00204 	addi	sp,sp,8
  804974:	f800283a 	ret

00804978 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
  804978:	deffff04 	addi	sp,sp,-4
  80497c:	df000015 	stw	fp,0(sp)
  804980:	d839883a 	mov	fp,sp
	xYieldPending = pdTRUE;
  804984:	00800044 	movi	r2,1
  804988:	d0a4db15 	stw	r2,-27796(gp)
}
  80498c:	0001883a 	nop
  804990:	e037883a 	mov	sp,fp
  804994:	df000017 	ldw	fp,0(sp)
  804998:	dec00104 	addi	sp,sp,4
  80499c:	f800283a 	ret

008049a0 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
  8049a0:	defffd04 	addi	sp,sp,-12
  8049a4:	dfc00215 	stw	ra,8(sp)
  8049a8:	df000115 	stw	fp,4(sp)
  8049ac:	df000104 	addi	fp,sp,4
  8049b0:	e13fff15 	stw	r4,-4(fp)

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
  8049b4:	0804a740 	call	804a74 <prvCheckTasksWaitingTermination>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
  8049b8:	003ffe06 	br	8049b4 <__alt_mem_onchip_memory2_0+0xff7849b4>

008049bc <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
  8049bc:	defffd04 	addi	sp,sp,-12
  8049c0:	dfc00215 	stw	ra,8(sp)
  8049c4:	df000115 	stw	fp,4(sp)
  8049c8:	df000104 	addi	fp,sp,4
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
  8049cc:	e03fff15 	stw	zero,-4(fp)
  8049d0:	00000a06 	br	8049fc <prvInitialiseTaskLists+0x40>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
  8049d4:	e0bfff17 	ldw	r2,-4(fp)
  8049d8:	10c00524 	muli	r3,r2,20
  8049dc:	00802174 	movhi	r2,133
  8049e0:	10a18c04 	addi	r2,r2,-31184
  8049e4:	1885883a 	add	r2,r3,r2
  8049e8:	1009883a 	mov	r4,r2
  8049ec:	08009a00 	call	8009a0 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
  8049f0:	e0bfff17 	ldw	r2,-4(fp)
  8049f4:	10800044 	addi	r2,r2,1
  8049f8:	e0bfff15 	stw	r2,-4(fp)
  8049fc:	e0bfff17 	ldw	r2,-4(fp)
  804a00:	10800170 	cmpltui	r2,r2,5
  804a04:	103ff31e 	bne	r2,zero,8049d4 <__alt_mem_onchip_memory2_0+0xff7849d4>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
  804a08:	01002174 	movhi	r4,133
  804a0c:	2121a504 	addi	r4,r4,-31084
  804a10:	08009a00 	call	8009a0 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
  804a14:	01002174 	movhi	r4,133
  804a18:	2121aa04 	addi	r4,r4,-31064
  804a1c:	08009a00 	call	8009a0 <vListInitialise>
	vListInitialise( &xPendingReadyList );
  804a20:	01002174 	movhi	r4,133
  804a24:	2121af04 	addi	r4,r4,-31044
  804a28:	08009a00 	call	8009a0 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
  804a2c:	01002174 	movhi	r4,133
  804a30:	2121b404 	addi	r4,r4,-31024
  804a34:	08009a00 	call	8009a0 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
  804a38:	01002174 	movhi	r4,133
  804a3c:	2121b904 	addi	r4,r4,-31004
  804a40:	08009a00 	call	8009a0 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
  804a44:	00802174 	movhi	r2,133
  804a48:	10a1a504 	addi	r2,r2,-31084
  804a4c:	d0a4d315 	stw	r2,-27828(gp)
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
  804a50:	00802174 	movhi	r2,133
  804a54:	10a1aa04 	addi	r2,r2,-31064
  804a58:	d0a4d415 	stw	r2,-27824(gp)
}
  804a5c:	0001883a 	nop
  804a60:	e037883a 	mov	sp,fp
  804a64:	dfc00117 	ldw	ra,4(sp)
  804a68:	df000017 	ldw	fp,0(sp)
  804a6c:	dec00204 	addi	sp,sp,8
  804a70:	f800283a 	ret

00804a74 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
  804a74:	defffd04 	addi	sp,sp,-12
  804a78:	dfc00215 	stw	ra,8(sp)
  804a7c:	df000115 	stw	fp,4(sp)
  804a80:	df000104 	addi	fp,sp,4
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
  804a84:	00001306 	br	804ad4 <prvCheckTasksWaitingTermination+0x60>
		{
			taskENTER_CRITICAL();
  804a88:	0804ff40 	call	804ff4 <vTaskEnterCritical>
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  804a8c:	00802174 	movhi	r2,133
  804a90:	10a1b404 	addi	r2,r2,-31024
  804a94:	10800317 	ldw	r2,12(r2)
  804a98:	10800317 	ldw	r2,12(r2)
  804a9c:	e0bfff15 	stw	r2,-4(fp)
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  804aa0:	e0bfff17 	ldw	r2,-4(fp)
  804aa4:	10800104 	addi	r2,r2,4
  804aa8:	1009883a 	mov	r4,r2
  804aac:	0800b980 	call	800b98 <uxListRemove>
				--uxCurrentNumberOfTasks;
  804ab0:	d0a4d617 	ldw	r2,-27816(gp)
  804ab4:	10bfffc4 	addi	r2,r2,-1
  804ab8:	d0a4d615 	stw	r2,-27816(gp)
				--uxDeletedTasksWaitingCleanUp;
  804abc:	d0a4d517 	ldw	r2,-27820(gp)
  804ac0:	10bfffc4 	addi	r2,r2,-1
  804ac4:	d0a4d515 	stw	r2,-27820(gp)
			}
			taskEXIT_CRITICAL();
  804ac8:	08050480 	call	805048 <vTaskExitCritical>

			prvDeleteTCB( pxTCB );
  804acc:	e13fff17 	ldw	r4,-4(fp)
  804ad0:	0804bb80 	call	804bb8 <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
  804ad4:	d0a4d517 	ldw	r2,-27820(gp)
  804ad8:	103feb1e 	bne	r2,zero,804a88 <__alt_mem_onchip_memory2_0+0xff784a88>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
  804adc:	0001883a 	nop
  804ae0:	e037883a 	mov	sp,fp
  804ae4:	dfc00117 	ldw	ra,4(sp)
  804ae8:	df000017 	ldw	fp,0(sp)
  804aec:	dec00204 	addi	sp,sp,8
  804af0:	f800283a 	ret

00804af4 <prvTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )

	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
  804af4:	defffd04 	addi	sp,sp,-12
  804af8:	df000215 	stw	fp,8(sp)
  804afc:	df000204 	addi	fp,sp,8
  804b00:	e13fff15 	stw	r4,-4(fp)
	uint32_t ulCount = 0U;
  804b04:	e03ffe15 	stw	zero,-8(fp)

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
  804b08:	00000606 	br	804b24 <prvTaskCheckFreeStackSpace+0x30>
		{
			pucStackByte -= portSTACK_GROWTH;
  804b0c:	e0bfff17 	ldw	r2,-4(fp)
  804b10:	10800044 	addi	r2,r2,1
  804b14:	e0bfff15 	stw	r2,-4(fp)
			ulCount++;
  804b18:	e0bffe17 	ldw	r2,-8(fp)
  804b1c:	10800044 	addi	r2,r2,1
  804b20:	e0bffe15 	stw	r2,-8(fp)

	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
	uint32_t ulCount = 0U;

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
  804b24:	e0bfff17 	ldw	r2,-4(fp)
  804b28:	10800003 	ldbu	r2,0(r2)
  804b2c:	10803fcc 	andi	r2,r2,255
  804b30:	10802960 	cmpeqi	r2,r2,165
  804b34:	103ff51e 	bne	r2,zero,804b0c <__alt_mem_onchip_memory2_0+0xff784b0c>
		{
			pucStackByte -= portSTACK_GROWTH;
			ulCount++;
		}

		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
  804b38:	e0bffe17 	ldw	r2,-8(fp)
  804b3c:	1004d0ba 	srli	r2,r2,2
  804b40:	e0bffe15 	stw	r2,-8(fp)

		return ( configSTACK_DEPTH_TYPE ) ulCount;
  804b44:	e0bffe17 	ldw	r2,-8(fp)
	}
  804b48:	e037883a 	mov	sp,fp
  804b4c:	df000017 	ldw	fp,0(sp)
  804b50:	dec00104 	addi	sp,sp,4
  804b54:	f800283a 	ret

00804b58 <uxTaskGetStackHighWaterMark>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
	{
  804b58:	defffa04 	addi	sp,sp,-24
  804b5c:	dfc00515 	stw	ra,20(sp)
  804b60:	df000415 	stw	fp,16(sp)
  804b64:	df000404 	addi	fp,sp,16
  804b68:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;
	uint8_t *pucEndOfStack;
	UBaseType_t uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
  804b6c:	e0bfff17 	ldw	r2,-4(fp)
  804b70:	1000021e 	bne	r2,zero,804b7c <uxTaskGetStackHighWaterMark+0x24>
  804b74:	d0a4d217 	ldw	r2,-27832(gp)
  804b78:	00000106 	br	804b80 <uxTaskGetStackHighWaterMark+0x28>
  804b7c:	e0bfff17 	ldw	r2,-4(fp)
  804b80:	e0bffc15 	stw	r2,-16(fp)

		#if portSTACK_GROWTH < 0
		{
			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
  804b84:	e0bffc17 	ldw	r2,-16(fp)
  804b88:	10800c17 	ldw	r2,48(r2)
  804b8c:	e0bffd15 	stw	r2,-12(fp)
		{
			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
		}
		#endif

		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
  804b90:	e13ffd17 	ldw	r4,-12(fp)
  804b94:	0804af40 	call	804af4 <prvTaskCheckFreeStackSpace>
  804b98:	10bfffcc 	andi	r2,r2,65535
  804b9c:	e0bffe15 	stw	r2,-8(fp)

		return uxReturn;
  804ba0:	e0bffe17 	ldw	r2,-8(fp)
	}
  804ba4:	e037883a 	mov	sp,fp
  804ba8:	dfc00117 	ldw	ra,4(sp)
  804bac:	df000017 	ldw	fp,0(sp)
  804bb0:	dec00204 	addi	sp,sp,8
  804bb4:	f800283a 	ret

00804bb8 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
  804bb8:	defffd04 	addi	sp,sp,-12
  804bbc:	dfc00215 	stw	ra,8(sp)
  804bc0:	df000115 	stw	fp,4(sp)
  804bc4:	df000104 	addi	fp,sp,4
  804bc8:	e13fff15 	stw	r4,-4(fp)

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
  804bcc:	e0bfff17 	ldw	r2,-4(fp)
  804bd0:	10800c17 	ldw	r2,48(r2)
  804bd4:	1009883a 	mov	r4,r2
  804bd8:	08010dc0 	call	8010dc <vPortFree>
			vPortFree( pxTCB );
  804bdc:	e13fff17 	ldw	r4,-4(fp)
  804be0:	08010dc0 	call	8010dc <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
  804be4:	0001883a 	nop
  804be8:	e037883a 	mov	sp,fp
  804bec:	dfc00117 	ldw	ra,4(sp)
  804bf0:	df000017 	ldw	fp,0(sp)
  804bf4:	dec00204 	addi	sp,sp,8
  804bf8:	f800283a 	ret

00804bfc <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
  804bfc:	defffe04 	addi	sp,sp,-8
  804c00:	df000115 	stw	fp,4(sp)
  804c04:	df000104 	addi	fp,sp,4
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  804c08:	d0a4d317 	ldw	r2,-27828(gp)
  804c0c:	10800017 	ldw	r2,0(r2)
  804c10:	1000031e 	bne	r2,zero,804c20 <prvResetNextTaskUnblockTime+0x24>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
  804c14:	00bfffc4 	movi	r2,-1
  804c18:	d0a4de15 	stw	r2,-27784(gp)
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
  804c1c:	00000706 	br	804c3c <prvResetNextTaskUnblockTime+0x40>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  804c20:	d0a4d317 	ldw	r2,-27828(gp)
  804c24:	10800317 	ldw	r2,12(r2)
  804c28:	10800317 	ldw	r2,12(r2)
  804c2c:	e0bfff15 	stw	r2,-4(fp)
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
  804c30:	e0bfff17 	ldw	r2,-4(fp)
  804c34:	10800117 	ldw	r2,4(r2)
  804c38:	d0a4de15 	stw	r2,-27784(gp)
	}
}
  804c3c:	0001883a 	nop
  804c40:	e037883a 	mov	sp,fp
  804c44:	df000017 	ldw	fp,0(sp)
  804c48:	dec00104 	addi	sp,sp,4
  804c4c:	f800283a 	ret

00804c50 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
  804c50:	defffe04 	addi	sp,sp,-8
  804c54:	df000115 	stw	fp,4(sp)
  804c58:	df000104 	addi	fp,sp,4
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
  804c5c:	d0a4d217 	ldw	r2,-27832(gp)
  804c60:	e0bfff15 	stw	r2,-4(fp)

		return xReturn;
  804c64:	e0bfff17 	ldw	r2,-4(fp)
	}
  804c68:	e037883a 	mov	sp,fp
  804c6c:	df000017 	ldw	fp,0(sp)
  804c70:	dec00104 	addi	sp,sp,4
  804c74:	f800283a 	ret

00804c78 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
  804c78:	defffb04 	addi	sp,sp,-20
  804c7c:	dfc00415 	stw	ra,16(sp)
  804c80:	df000315 	stw	fp,12(sp)
  804c84:	df000304 	addi	fp,sp,12
  804c88:	e13fff15 	stw	r4,-4(fp)
	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
  804c8c:	e0bfff17 	ldw	r2,-4(fp)
  804c90:	e0bffe15 	stw	r2,-8(fp)
	BaseType_t xReturn = pdFALSE;
  804c94:	e03ffd15 	stw	zero,-12(fp)

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
  804c98:	e0bfff17 	ldw	r2,-4(fp)
  804c9c:	10004026 	beq	r2,zero,804da0 <xTaskPriorityInherit+0x128>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
  804ca0:	e0bffe17 	ldw	r2,-8(fp)
  804ca4:	10c00b17 	ldw	r3,44(r2)
  804ca8:	d0a4d217 	ldw	r2,-27832(gp)
  804cac:	10800b17 	ldw	r2,44(r2)
  804cb0:	1880342e 	bgeu	r3,r2,804d84 <xTaskPriorityInherit+0x10c>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
  804cb4:	e0bffe17 	ldw	r2,-8(fp)
  804cb8:	10800617 	ldw	r2,24(r2)
  804cbc:	10000616 	blt	r2,zero,804cd8 <xTaskPriorityInherit+0x60>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  804cc0:	d0a4d217 	ldw	r2,-27832(gp)
  804cc4:	10800b17 	ldw	r2,44(r2)
  804cc8:	00c00144 	movi	r3,5
  804ccc:	1887c83a 	sub	r3,r3,r2
  804cd0:	e0bffe17 	ldw	r2,-8(fp)
  804cd4:	10c00615 	stw	r3,24(r2)
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
  804cd8:	e0bffe17 	ldw	r2,-8(fp)
  804cdc:	10c00517 	ldw	r3,20(r2)
  804ce0:	e0bffe17 	ldw	r2,-8(fp)
  804ce4:	10800b17 	ldw	r2,44(r2)
  804ce8:	11000524 	muli	r4,r2,20
  804cec:	00802174 	movhi	r2,133
  804cf0:	10a18c04 	addi	r2,r2,-31184
  804cf4:	2085883a 	add	r2,r4,r2
  804cf8:	18801b1e 	bne	r3,r2,804d68 <xTaskPriorityInherit+0xf0>
				{
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  804cfc:	e0bffe17 	ldw	r2,-8(fp)
  804d00:	10800104 	addi	r2,r2,4
  804d04:	1009883a 	mov	r4,r2
  804d08:	0800b980 	call	800b98 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
  804d0c:	d0a4d217 	ldw	r2,-27832(gp)
  804d10:	10c00b17 	ldw	r3,44(r2)
  804d14:	e0bffe17 	ldw	r2,-8(fp)
  804d18:	10c00b15 	stw	r3,44(r2)
					prvAddTaskToReadyList( pxMutexHolderTCB );
  804d1c:	e0bffe17 	ldw	r2,-8(fp)
  804d20:	10800b17 	ldw	r2,44(r2)
  804d24:	d0e4d817 	ldw	r3,-27808(gp)
  804d28:	1880032e 	bgeu	r3,r2,804d38 <xTaskPriorityInherit+0xc0>
  804d2c:	e0bffe17 	ldw	r2,-8(fp)
  804d30:	10800b17 	ldw	r2,44(r2)
  804d34:	d0a4d815 	stw	r2,-27808(gp)
  804d38:	e0bffe17 	ldw	r2,-8(fp)
  804d3c:	10800b17 	ldw	r2,44(r2)
  804d40:	10c00524 	muli	r3,r2,20
  804d44:	00802174 	movhi	r2,133
  804d48:	10a18c04 	addi	r2,r2,-31184
  804d4c:	1887883a 	add	r3,r3,r2
  804d50:	e0bffe17 	ldw	r2,-8(fp)
  804d54:	10800104 	addi	r2,r2,4
  804d58:	100b883a 	mov	r5,r2
  804d5c:	1809883a 	mov	r4,r3
  804d60:	0800a340 	call	800a34 <vListInsertEnd>
  804d64:	00000406 	br	804d78 <xTaskPriorityInherit+0x100>
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
  804d68:	d0a4d217 	ldw	r2,-27832(gp)
  804d6c:	10c00b17 	ldw	r3,44(r2)
  804d70:	e0bffe17 	ldw	r2,-8(fp)
  804d74:	10c00b15 	stw	r3,44(r2)
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
  804d78:	00800044 	movi	r2,1
  804d7c:	e0bffd15 	stw	r2,-12(fp)
  804d80:	00000706 	br	804da0 <xTaskPriorityInherit+0x128>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
  804d84:	e0bffe17 	ldw	r2,-8(fp)
  804d88:	10c01017 	ldw	r3,64(r2)
  804d8c:	d0a4d217 	ldw	r2,-27832(gp)
  804d90:	10800b17 	ldw	r2,44(r2)
  804d94:	1880022e 	bgeu	r3,r2,804da0 <xTaskPriorityInherit+0x128>
					current priority of the mutex holder is not lower than the
					priority of the task attempting to take the mutex.
					Therefore the mutex holder must have already inherited a
					priority, but inheritance would have occurred if that had
					not been the case. */
					xReturn = pdTRUE;
  804d98:	00800044 	movi	r2,1
  804d9c:	e0bffd15 	stw	r2,-12(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
  804da0:	e0bffd17 	ldw	r2,-12(fp)
	}
  804da4:	e037883a 	mov	sp,fp
  804da8:	dfc00117 	ldw	ra,4(sp)
  804dac:	df000017 	ldw	fp,0(sp)
  804db0:	dec00204 	addi	sp,sp,8
  804db4:	f800283a 	ret

00804db8 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
  804db8:	defffb04 	addi	sp,sp,-20
  804dbc:	dfc00415 	stw	ra,16(sp)
  804dc0:	df000315 	stw	fp,12(sp)
  804dc4:	df000304 	addi	fp,sp,12
  804dc8:	e13fff15 	stw	r4,-4(fp)
	TCB_t * const pxTCB = pxMutexHolder;
  804dcc:	e0bfff17 	ldw	r2,-4(fp)
  804dd0:	e0bffe15 	stw	r2,-8(fp)
	BaseType_t xReturn = pdFALSE;
  804dd4:	e03ffd15 	stw	zero,-12(fp)

		if( pxMutexHolder != NULL )
  804dd8:	e0bfff17 	ldw	r2,-4(fp)
  804ddc:	10002f26 	beq	r2,zero,804e9c <xTaskPriorityDisinherit+0xe4>
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
  804de0:	e0bffe17 	ldw	r2,-8(fp)
  804de4:	10801117 	ldw	r2,68(r2)
  804de8:	10ffffc4 	addi	r3,r2,-1
  804dec:	e0bffe17 	ldw	r2,-8(fp)
  804df0:	10c01115 	stw	r3,68(r2)

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
  804df4:	e0bffe17 	ldw	r2,-8(fp)
  804df8:	10c00b17 	ldw	r3,44(r2)
  804dfc:	e0bffe17 	ldw	r2,-8(fp)
  804e00:	10801017 	ldw	r2,64(r2)
  804e04:	18802526 	beq	r3,r2,804e9c <xTaskPriorityDisinherit+0xe4>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
  804e08:	e0bffe17 	ldw	r2,-8(fp)
  804e0c:	10801117 	ldw	r2,68(r2)
  804e10:	1000221e 	bne	r2,zero,804e9c <xTaskPriorityDisinherit+0xe4>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready/delayed list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  804e14:	e0bffe17 	ldw	r2,-8(fp)
  804e18:	10800104 	addi	r2,r2,4
  804e1c:	1009883a 	mov	r4,r2
  804e20:	0800b980 	call	800b98 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
  804e24:	e0bffe17 	ldw	r2,-8(fp)
  804e28:	10c01017 	ldw	r3,64(r2)
  804e2c:	e0bffe17 	ldw	r2,-8(fp)
  804e30:	10c00b15 	stw	r3,44(r2)

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  804e34:	e0bffe17 	ldw	r2,-8(fp)
  804e38:	10800b17 	ldw	r2,44(r2)
  804e3c:	00c00144 	movi	r3,5
  804e40:	1887c83a 	sub	r3,r3,r2
  804e44:	e0bffe17 	ldw	r2,-8(fp)
  804e48:	10c00615 	stw	r3,24(r2)
					prvAddTaskToReadyList( pxTCB );
  804e4c:	e0bffe17 	ldw	r2,-8(fp)
  804e50:	10800b17 	ldw	r2,44(r2)
  804e54:	d0e4d817 	ldw	r3,-27808(gp)
  804e58:	1880032e 	bgeu	r3,r2,804e68 <xTaskPriorityDisinherit+0xb0>
  804e5c:	e0bffe17 	ldw	r2,-8(fp)
  804e60:	10800b17 	ldw	r2,44(r2)
  804e64:	d0a4d815 	stw	r2,-27808(gp)
  804e68:	e0bffe17 	ldw	r2,-8(fp)
  804e6c:	10800b17 	ldw	r2,44(r2)
  804e70:	10c00524 	muli	r3,r2,20
  804e74:	00802174 	movhi	r2,133
  804e78:	10a18c04 	addi	r2,r2,-31184
  804e7c:	1887883a 	add	r3,r3,r2
  804e80:	e0bffe17 	ldw	r2,-8(fp)
  804e84:	10800104 	addi	r2,r2,4
  804e88:	100b883a 	mov	r5,r2
  804e8c:	1809883a 	mov	r4,r3
  804e90:	0800a340 	call	800a34 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
  804e94:	00800044 	movi	r2,1
  804e98:	e0bffd15 	stw	r2,-12(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
  804e9c:	e0bffd17 	ldw	r2,-12(fp)
	}
  804ea0:	e037883a 	mov	sp,fp
  804ea4:	dfc00117 	ldw	ra,4(sp)
  804ea8:	df000017 	ldw	fp,0(sp)
  804eac:	dec00204 	addi	sp,sp,8
  804eb0:	f800283a 	ret

00804eb4 <vTaskPriorityDisinheritAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
	{
  804eb4:	defff804 	addi	sp,sp,-32
  804eb8:	dfc00715 	stw	ra,28(sp)
  804ebc:	df000615 	stw	fp,24(sp)
  804ec0:	df000604 	addi	fp,sp,24
  804ec4:	e13ffe15 	stw	r4,-8(fp)
  804ec8:	e17fff15 	stw	r5,-4(fp)
	TCB_t * const pxTCB = pxMutexHolder;
  804ecc:	e0bffe17 	ldw	r2,-8(fp)
  804ed0:	e0bffb15 	stw	r2,-20(fp)
	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
  804ed4:	00800044 	movi	r2,1
  804ed8:	e0bffc15 	stw	r2,-16(fp)

		if( pxMutexHolder != NULL )
  804edc:	e0bffe17 	ldw	r2,-8(fp)
  804ee0:	10003e26 	beq	r2,zero,804fdc <vTaskPriorityDisinheritAfterTimeout+0x128>

			/* Determine the priority to which the priority of the task that
			holds the mutex should be set.  This will be the greater of the
			holding task's base priority and the priority of the highest
			priority task that is waiting to obtain the mutex. */
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
  804ee4:	e0bffb17 	ldw	r2,-20(fp)
  804ee8:	10c01017 	ldw	r3,64(r2)
  804eec:	e0bfff17 	ldw	r2,-4(fp)
  804ef0:	1880032e 	bgeu	r3,r2,804f00 <vTaskPriorityDisinheritAfterTimeout+0x4c>
			{
				uxPriorityToUse = uxHighestPriorityWaitingTask;
  804ef4:	e0bfff17 	ldw	r2,-4(fp)
  804ef8:	e0bffa15 	stw	r2,-24(fp)
  804efc:	00000306 	br	804f0c <vTaskPriorityDisinheritAfterTimeout+0x58>
			}
			else
			{
				uxPriorityToUse = pxTCB->uxBasePriority;
  804f00:	e0bffb17 	ldw	r2,-20(fp)
  804f04:	10801017 	ldw	r2,64(r2)
  804f08:	e0bffa15 	stw	r2,-24(fp)
			}

			/* Does the priority need to change? */
			if( pxTCB->uxPriority != uxPriorityToUse )
  804f0c:	e0bffb17 	ldw	r2,-20(fp)
  804f10:	10c00b17 	ldw	r3,44(r2)
  804f14:	e0bffa17 	ldw	r2,-24(fp)
  804f18:	18803026 	beq	r3,r2,804fdc <vTaskPriorityDisinheritAfterTimeout+0x128>
			{
				/* Only disinherit if no other mutexes are held.  This is a
				simplification in the priority inheritance implementation.  If
				the task that holds the mutex is also holding other mutexes then
				the other mutexes may have caused the priority inheritance. */
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
  804f1c:	e0bffb17 	ldw	r2,-20(fp)
  804f20:	10c01117 	ldw	r3,68(r2)
  804f24:	e0bffc17 	ldw	r2,-16(fp)
  804f28:	18802c1e 	bne	r3,r2,804fdc <vTaskPriorityDisinheritAfterTimeout+0x128>

					/* Disinherit the priority, remembering the previous
					priority to facilitate determining the subject task's
					state. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
  804f2c:	e0bffb17 	ldw	r2,-20(fp)
  804f30:	10800b17 	ldw	r2,44(r2)
  804f34:	e0bffd15 	stw	r2,-12(fp)
					pxTCB->uxPriority = uxPriorityToUse;
  804f38:	e0bffb17 	ldw	r2,-20(fp)
  804f3c:	e0fffa17 	ldw	r3,-24(fp)
  804f40:	10c00b15 	stw	r3,44(r2)

					/* Only reset the event list item value if the value is not
					being used for anything else. */
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
  804f44:	e0bffb17 	ldw	r2,-20(fp)
  804f48:	10800617 	ldw	r2,24(r2)
  804f4c:	10000516 	blt	r2,zero,804f64 <vTaskPriorityDisinheritAfterTimeout+0xb0>
					{
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  804f50:	00c00144 	movi	r3,5
  804f54:	e0bffa17 	ldw	r2,-24(fp)
  804f58:	1887c83a 	sub	r3,r3,r2
  804f5c:	e0bffb17 	ldw	r2,-20(fp)
  804f60:	10c00615 	stw	r3,24(r2)
					then the task that holds the mutex could be in either the
					Ready, Blocked or Suspended states.  Only remove the task
					from its current state list if it is in the Ready state as
					the task's priority is going to change and there is one
					Ready list per priority. */
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
  804f64:	e0bffb17 	ldw	r2,-20(fp)
  804f68:	10c00517 	ldw	r3,20(r2)
  804f6c:	e0bffd17 	ldw	r2,-12(fp)
  804f70:	11000524 	muli	r4,r2,20
  804f74:	00802174 	movhi	r2,133
  804f78:	10a18c04 	addi	r2,r2,-31184
  804f7c:	2085883a 	add	r2,r4,r2
  804f80:	1880161e 	bne	r3,r2,804fdc <vTaskPriorityDisinheritAfterTimeout+0x128>
					{
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  804f84:	e0bffb17 	ldw	r2,-20(fp)
  804f88:	10800104 	addi	r2,r2,4
  804f8c:	1009883a 	mov	r4,r2
  804f90:	0800b980 	call	800b98 <uxListRemove>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
  804f94:	e0bffb17 	ldw	r2,-20(fp)
  804f98:	10800b17 	ldw	r2,44(r2)
  804f9c:	d0e4d817 	ldw	r3,-27808(gp)
  804fa0:	1880032e 	bgeu	r3,r2,804fb0 <vTaskPriorityDisinheritAfterTimeout+0xfc>
  804fa4:	e0bffb17 	ldw	r2,-20(fp)
  804fa8:	10800b17 	ldw	r2,44(r2)
  804fac:	d0a4d815 	stw	r2,-27808(gp)
  804fb0:	e0bffb17 	ldw	r2,-20(fp)
  804fb4:	10800b17 	ldw	r2,44(r2)
  804fb8:	10c00524 	muli	r3,r2,20
  804fbc:	00802174 	movhi	r2,133
  804fc0:	10a18c04 	addi	r2,r2,-31184
  804fc4:	1887883a 	add	r3,r3,r2
  804fc8:	e0bffb17 	ldw	r2,-20(fp)
  804fcc:	10800104 	addi	r2,r2,4
  804fd0:	100b883a 	mov	r5,r2
  804fd4:	1809883a 	mov	r4,r3
  804fd8:	0800a340 	call	800a34 <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  804fdc:	0001883a 	nop
  804fe0:	e037883a 	mov	sp,fp
  804fe4:	dfc00117 	ldw	ra,4(sp)
  804fe8:	df000017 	ldw	fp,0(sp)
  804fec:	dec00204 	addi	sp,sp,8
  804ff0:	f800283a 	ret

00804ff4 <vTaskEnterCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskEnterCritical( void )
	{
  804ff4:	defffe04 	addi	sp,sp,-8
  804ff8:	df000115 	stw	fp,4(sp)
  804ffc:	df000104 	addi	fp,sp,4
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  805000:	0005303a 	rdctl	r2,status
  805004:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  805008:	e0ffff17 	ldw	r3,-4(fp)
  80500c:	00bfff84 	movi	r2,-2
  805010:	1884703a 	and	r2,r3,r2
  805014:	1001703a 	wrctl	status,r2
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
  805018:	d0a4d917 	ldw	r2,-27804(gp)
  80501c:	10000526 	beq	r2,zero,805034 <vTaskEnterCritical+0x40>
		{
			( pxCurrentTCB->uxCriticalNesting )++;
  805020:	d0a4d217 	ldw	r2,-27832(gp)
  805024:	10c00f17 	ldw	r3,60(r2)
  805028:	18c00044 	addi	r3,r3,1
  80502c:	10c00f15 	stw	r3,60(r2)
			function so	assert() if it is being called from an interrupt
			context.  Only API functions that end in "FromISR" can be used in an
			interrupt.  Only assert if the critical nesting count is 1 to
			protect against recursive calls if the assert function also uses a
			critical section. */
			if( pxCurrentTCB->uxCriticalNesting == 1 )
  805030:	d0a4d217 	ldw	r2,-27832(gp)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  805034:	0001883a 	nop
  805038:	e037883a 	mov	sp,fp
  80503c:	df000017 	ldw	fp,0(sp)
  805040:	dec00104 	addi	sp,sp,4
  805044:	f800283a 	ret

00805048 <vTaskExitCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
  805048:	defffe04 	addi	sp,sp,-8
  80504c:	df000115 	stw	fp,4(sp)
  805050:	df000104 	addi	fp,sp,4
		if( xSchedulerRunning != pdFALSE )
  805054:	d0a4d917 	ldw	r2,-27804(gp)
  805058:	10000e26 	beq	r2,zero,805094 <vTaskExitCritical+0x4c>
		{
			if( pxCurrentTCB->uxCriticalNesting > 0U )
  80505c:	d0a4d217 	ldw	r2,-27832(gp)
  805060:	10800f17 	ldw	r2,60(r2)
  805064:	10000b26 	beq	r2,zero,805094 <vTaskExitCritical+0x4c>
			{
				( pxCurrentTCB->uxCriticalNesting )--;
  805068:	d0a4d217 	ldw	r2,-27832(gp)
  80506c:	10c00f17 	ldw	r3,60(r2)
  805070:	18ffffc4 	addi	r3,r3,-1
  805074:	10c00f15 	stw	r3,60(r2)

				if( pxCurrentTCB->uxCriticalNesting == 0U )
  805078:	d0a4d217 	ldw	r2,-27832(gp)
  80507c:	10800f17 	ldw	r2,60(r2)
  805080:	1000041e 	bne	r2,zero,805094 <vTaskExitCritical+0x4c>
  805084:	00800044 	movi	r2,1
  805088:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  80508c:	e0bfff17 	ldw	r2,-4(fp)
  805090:	1001703a 	wrctl	status,r2
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  805094:	0001883a 	nop
  805098:	e037883a 	mov	sp,fp
  80509c:	df000017 	ldw	fp,0(sp)
  8050a0:	dec00104 	addi	sp,sp,4
  8050a4:	f800283a 	ret

008050a8 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
  8050a8:	defffe04 	addi	sp,sp,-8
  8050ac:	df000115 	stw	fp,4(sp)
  8050b0:	df000104 	addi	fp,sp,4
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
  8050b4:	d0a4d217 	ldw	r2,-27832(gp)
  8050b8:	10800617 	ldw	r2,24(r2)
  8050bc:	e0bfff15 	stw	r2,-4(fp)

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  8050c0:	d0a4d217 	ldw	r2,-27832(gp)
  8050c4:	d0e4d217 	ldw	r3,-27832(gp)
  8050c8:	18c00b17 	ldw	r3,44(r3)
  8050cc:	01000144 	movi	r4,5
  8050d0:	20c7c83a 	sub	r3,r4,r3
  8050d4:	10c00615 	stw	r3,24(r2)

	return uxReturn;
  8050d8:	e0bfff17 	ldw	r2,-4(fp)
}
  8050dc:	e037883a 	mov	sp,fp
  8050e0:	df000017 	ldw	fp,0(sp)
  8050e4:	dec00104 	addi	sp,sp,4
  8050e8:	f800283a 	ret

008050ec <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
	{
  8050ec:	deffff04 	addi	sp,sp,-4
  8050f0:	df000015 	stw	fp,0(sp)
  8050f4:	d839883a 	mov	fp,sp
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
  8050f8:	d0a4d217 	ldw	r2,-27832(gp)
  8050fc:	10000426 	beq	r2,zero,805110 <pvTaskIncrementMutexHeldCount+0x24>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
  805100:	d0a4d217 	ldw	r2,-27832(gp)
  805104:	10c01117 	ldw	r3,68(r2)
  805108:	18c00044 	addi	r3,r3,1
  80510c:	10c01115 	stw	r3,68(r2)
		}

		return pxCurrentTCB;
  805110:	d0a4d217 	ldw	r2,-27832(gp)
	}
  805114:	e037883a 	mov	sp,fp
  805118:	df000017 	ldw	fp,0(sp)
  80511c:	dec00104 	addi	sp,sp,4
  805120:	f800283a 	ret

00805124 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
  805124:	defffb04 	addi	sp,sp,-20
  805128:	dfc00415 	stw	ra,16(sp)
  80512c:	df000315 	stw	fp,12(sp)
  805130:	df000304 	addi	fp,sp,12
  805134:	e13ffe15 	stw	r4,-8(fp)
  805138:	e17fff15 	stw	r5,-4(fp)
	uint32_t ulReturn;

		taskENTER_CRITICAL();
  80513c:	0804ff40 	call	804ff4 <vTaskEnterCritical>
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
  805140:	d0a4d217 	ldw	r2,-27832(gp)
  805144:	10801217 	ldw	r2,72(r2)
  805148:	1000091e 	bne	r2,zero,805170 <ulTaskNotifyTake+0x4c>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
  80514c:	d0a4d217 	ldw	r2,-27832(gp)
  805150:	00c00044 	movi	r3,1
  805154:	10c01305 	stb	r3,76(r2)

				if( xTicksToWait > ( TickType_t ) 0 )
  805158:	e0bfff17 	ldw	r2,-4(fp)
  80515c:	10000426 	beq	r2,zero,805170 <ulTaskNotifyTake+0x4c>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
  805160:	01400044 	movi	r5,1
  805164:	e13fff17 	ldw	r4,-4(fp)
  805168:	08058680 	call	805868 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
  80516c:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
  805170:	08050480 	call	805048 <vTaskExitCritical>

		taskENTER_CRITICAL();
  805174:	0804ff40 	call	804ff4 <vTaskEnterCritical>
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
  805178:	d0a4d217 	ldw	r2,-27832(gp)
  80517c:	10801217 	ldw	r2,72(r2)
  805180:	e0bffd15 	stw	r2,-12(fp)

			if( ulReturn != 0UL )
  805184:	e0bffd17 	ldw	r2,-12(fp)
  805188:	10000926 	beq	r2,zero,8051b0 <ulTaskNotifyTake+0x8c>
			{
				if( xClearCountOnExit != pdFALSE )
  80518c:	e0bffe17 	ldw	r2,-8(fp)
  805190:	10000326 	beq	r2,zero,8051a0 <ulTaskNotifyTake+0x7c>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
  805194:	d0a4d217 	ldw	r2,-27832(gp)
  805198:	10001215 	stw	zero,72(r2)
  80519c:	00000406 	br	8051b0 <ulTaskNotifyTake+0x8c>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
  8051a0:	d0a4d217 	ldw	r2,-27832(gp)
  8051a4:	e0fffd17 	ldw	r3,-12(fp)
  8051a8:	18ffffc4 	addi	r3,r3,-1
  8051ac:	10c01215 	stw	r3,72(r2)
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
  8051b0:	d0a4d217 	ldw	r2,-27832(gp)
  8051b4:	10001305 	stb	zero,76(r2)
		}
		taskEXIT_CRITICAL();
  8051b8:	08050480 	call	805048 <vTaskExitCritical>

		return ulReturn;
  8051bc:	e0bffd17 	ldw	r2,-12(fp)
	}
  8051c0:	e037883a 	mov	sp,fp
  8051c4:	dfc00117 	ldw	ra,4(sp)
  8051c8:	df000017 	ldw	fp,0(sp)
  8051cc:	dec00204 	addi	sp,sp,8
  8051d0:	f800283a 	ret

008051d4 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
  8051d4:	defff904 	addi	sp,sp,-28
  8051d8:	dfc00615 	stw	ra,24(sp)
  8051dc:	df000515 	stw	fp,20(sp)
  8051e0:	df000504 	addi	fp,sp,20
  8051e4:	e13ffc15 	stw	r4,-16(fp)
  8051e8:	e17ffd15 	stw	r5,-12(fp)
  8051ec:	e1bffe15 	stw	r6,-8(fp)
  8051f0:	e1ffff15 	stw	r7,-4(fp)
	BaseType_t xReturn;

		taskENTER_CRITICAL();
  8051f4:	0804ff40 	call	804ff4 <vTaskEnterCritical>
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
  8051f8:	d0a4d217 	ldw	r2,-27832(gp)
  8051fc:	10801303 	ldbu	r2,76(r2)
  805200:	10803fcc 	andi	r2,r2,255
  805204:	108000a0 	cmpeqi	r2,r2,2
  805208:	10000f1e 	bne	r2,zero,805248 <xTaskNotifyWait+0x74>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
  80520c:	d0a4d217 	ldw	r2,-27832(gp)
  805210:	11001217 	ldw	r4,72(r2)
  805214:	e0fffc17 	ldw	r3,-16(fp)
  805218:	00c6303a 	nor	r3,zero,r3
  80521c:	20c6703a 	and	r3,r4,r3
  805220:	10c01215 	stw	r3,72(r2)

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
  805224:	d0a4d217 	ldw	r2,-27832(gp)
  805228:	00c00044 	movi	r3,1
  80522c:	10c01305 	stb	r3,76(r2)

				if( xTicksToWait > ( TickType_t ) 0 )
  805230:	e0bfff17 	ldw	r2,-4(fp)
  805234:	10000426 	beq	r2,zero,805248 <xTaskNotifyWait+0x74>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
  805238:	01400044 	movi	r5,1
  80523c:	e13fff17 	ldw	r4,-4(fp)
  805240:	08058680 	call	805868 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
  805244:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
  805248:	08050480 	call	805048 <vTaskExitCritical>

		taskENTER_CRITICAL();
  80524c:	0804ff40 	call	804ff4 <vTaskEnterCritical>
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
  805250:	e0bffe17 	ldw	r2,-8(fp)
  805254:	10000426 	beq	r2,zero,805268 <xTaskNotifyWait+0x94>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
  805258:	d0a4d217 	ldw	r2,-27832(gp)
  80525c:	10c01217 	ldw	r3,72(r2)
  805260:	e0bffe17 	ldw	r2,-8(fp)
  805264:	10c00015 	stw	r3,0(r2)

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
  805268:	d0a4d217 	ldw	r2,-27832(gp)
  80526c:	10801303 	ldbu	r2,76(r2)
  805270:	10803fcc 	andi	r2,r2,255
  805274:	108000a0 	cmpeqi	r2,r2,2
  805278:	1000021e 	bne	r2,zero,805284 <xTaskNotifyWait+0xb0>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
  80527c:	e03ffb15 	stw	zero,-20(fp)
  805280:	00000806 	br	8052a4 <xTaskNotifyWait+0xd0>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
  805284:	d0a4d217 	ldw	r2,-27832(gp)
  805288:	11001217 	ldw	r4,72(r2)
  80528c:	e0fffd17 	ldw	r3,-12(fp)
  805290:	00c6303a 	nor	r3,zero,r3
  805294:	20c6703a 	and	r3,r4,r3
  805298:	10c01215 	stw	r3,72(r2)
				xReturn = pdTRUE;
  80529c:	00800044 	movi	r2,1
  8052a0:	e0bffb15 	stw	r2,-20(fp)
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
  8052a4:	d0a4d217 	ldw	r2,-27832(gp)
  8052a8:	10001305 	stb	zero,76(r2)
		}
		taskEXIT_CRITICAL();
  8052ac:	08050480 	call	805048 <vTaskExitCritical>

		return xReturn;
  8052b0:	e0bffb17 	ldw	r2,-20(fp)
	}
  8052b4:	e037883a 	mov	sp,fp
  8052b8:	dfc00117 	ldw	ra,4(sp)
  8052bc:	df000017 	ldw	fp,0(sp)
  8052c0:	dec00204 	addi	sp,sp,8
  8052c4:	f800283a 	ret

008052c8 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
  8052c8:	defff704 	addi	sp,sp,-36
  8052cc:	dfc00815 	stw	ra,32(sp)
  8052d0:	df000715 	stw	fp,28(sp)
  8052d4:	df000704 	addi	fp,sp,28
  8052d8:	e13ffc15 	stw	r4,-16(fp)
  8052dc:	e17ffd15 	stw	r5,-12(fp)
  8052e0:	e1bffe15 	stw	r6,-8(fp)
  8052e4:	e1ffff15 	stw	r7,-4(fp)
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
  8052e8:	00800044 	movi	r2,1
  8052ec:	e0bff915 	stw	r2,-28(fp)
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
  8052f0:	e0bffc17 	ldw	r2,-16(fp)
  8052f4:	e0bffa15 	stw	r2,-24(fp)

		taskENTER_CRITICAL();
  8052f8:	0804ff40 	call	804ff4 <vTaskEnterCritical>
		{
			if( pulPreviousNotificationValue != NULL )
  8052fc:	e0bfff17 	ldw	r2,-4(fp)
  805300:	10000426 	beq	r2,zero,805314 <xTaskGenericNotify+0x4c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
  805304:	e0bffa17 	ldw	r2,-24(fp)
  805308:	10c01217 	ldw	r3,72(r2)
  80530c:	e0bfff17 	ldw	r2,-4(fp)
  805310:	10c00015 	stw	r3,0(r2)
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
  805314:	e0bffa17 	ldw	r2,-24(fp)
  805318:	10801303 	ldbu	r2,76(r2)
  80531c:	e0bffb05 	stb	r2,-20(fp)

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
  805320:	e0bffa17 	ldw	r2,-24(fp)
  805324:	00c00084 	movi	r3,2
  805328:	10c01305 	stb	r3,76(r2)

			switch( eAction )
  80532c:	e0bffe17 	ldw	r2,-8(fp)
  805330:	10800168 	cmpgeui	r2,r2,5
  805334:	1000261e 	bne	r2,zero,8053d0 <xTaskGenericNotify+0x108>
  805338:	e0bffe17 	ldw	r2,-8(fp)
  80533c:	100690ba 	slli	r3,r2,2
  805340:	00802034 	movhi	r2,128
  805344:	1094d504 	addi	r2,r2,21332
  805348:	1885883a 	add	r2,r3,r2
  80534c:	10800017 	ldw	r2,0(r2)
  805350:	1000683a 	jmp	r2
  805354:	008053d8 	cmpnei	r2,zero,335
  805358:	00805368 	cmpgeui	r2,zero,333
  80535c:	00805384 	movi	r2,334
  805360:	0080539c 	xori	r2,zero,334
  805364:	008053ac 	andhi	r2,zero,334
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
  805368:	e0bffa17 	ldw	r2,-24(fp)
  80536c:	10c01217 	ldw	r3,72(r2)
  805370:	e0bffd17 	ldw	r2,-12(fp)
  805374:	1886b03a 	or	r3,r3,r2
  805378:	e0bffa17 	ldw	r2,-24(fp)
  80537c:	10c01215 	stw	r3,72(r2)
					break;
  805380:	00001606 	br	8053dc <xTaskGenericNotify+0x114>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
  805384:	e0bffa17 	ldw	r2,-24(fp)
  805388:	10801217 	ldw	r2,72(r2)
  80538c:	10c00044 	addi	r3,r2,1
  805390:	e0bffa17 	ldw	r2,-24(fp)
  805394:	10c01215 	stw	r3,72(r2)
					break;
  805398:	00001006 	br	8053dc <xTaskGenericNotify+0x114>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
  80539c:	e0bffa17 	ldw	r2,-24(fp)
  8053a0:	e0fffd17 	ldw	r3,-12(fp)
  8053a4:	10c01215 	stw	r3,72(r2)
					break;
  8053a8:	00000c06 	br	8053dc <xTaskGenericNotify+0x114>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
  8053ac:	e0bffb03 	ldbu	r2,-20(fp)
  8053b0:	108000a0 	cmpeqi	r2,r2,2
  8053b4:	1000041e 	bne	r2,zero,8053c8 <xTaskGenericNotify+0x100>
					{
						pxTCB->ulNotifiedValue = ulValue;
  8053b8:	e0bffa17 	ldw	r2,-24(fp)
  8053bc:	e0fffd17 	ldw	r3,-12(fp)
  8053c0:	10c01215 	stw	r3,72(r2)
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
  8053c4:	00000506 	br	8053dc <xTaskGenericNotify+0x114>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
  8053c8:	e03ff915 	stw	zero,-28(fp)
					}
					break;
  8053cc:	00000306 	br	8053dc <xTaskGenericNotify+0x114>
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );

					break;
  8053d0:	0001883a 	nop
  8053d4:	00000106 	br	8053dc <xTaskGenericNotify+0x114>
					break;

				case eNoAction:
					/* The task is being notified without its notify value being
					updated. */
					break;
  8053d8:	0001883a 	nop

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
  8053dc:	e0bffb03 	ldbu	r2,-20(fp)
  8053e0:	10800058 	cmpnei	r2,r2,1
  8053e4:	10001c1e 	bne	r2,zero,805458 <xTaskGenericNotify+0x190>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  8053e8:	e0bffa17 	ldw	r2,-24(fp)
  8053ec:	10800104 	addi	r2,r2,4
  8053f0:	1009883a 	mov	r4,r2
  8053f4:	0800b980 	call	800b98 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
  8053f8:	e0bffa17 	ldw	r2,-24(fp)
  8053fc:	10800b17 	ldw	r2,44(r2)
  805400:	d0e4d817 	ldw	r3,-27808(gp)
  805404:	1880032e 	bgeu	r3,r2,805414 <xTaskGenericNotify+0x14c>
  805408:	e0bffa17 	ldw	r2,-24(fp)
  80540c:	10800b17 	ldw	r2,44(r2)
  805410:	d0a4d815 	stw	r2,-27808(gp)
  805414:	e0bffa17 	ldw	r2,-24(fp)
  805418:	10800b17 	ldw	r2,44(r2)
  80541c:	10c00524 	muli	r3,r2,20
  805420:	00802174 	movhi	r2,133
  805424:	10a18c04 	addi	r2,r2,-31184
  805428:	1887883a 	add	r3,r3,r2
  80542c:	e0bffa17 	ldw	r2,-24(fp)
  805430:	10800104 	addi	r2,r2,4
  805434:	100b883a 	mov	r5,r2
  805438:	1809883a 	mov	r4,r3
  80543c:	0800a340 	call	800a34 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
  805440:	e0bffa17 	ldw	r2,-24(fp)
  805444:	10800b17 	ldw	r2,44(r2)
  805448:	d0e4d217 	ldw	r3,-27832(gp)
  80544c:	18c00b17 	ldw	r3,44(r3)
  805450:	1880012e 	bgeu	r3,r2,805458 <xTaskGenericNotify+0x190>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
  805454:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
  805458:	08050480 	call	805048 <vTaskExitCritical>

		return xReturn;
  80545c:	e0bff917 	ldw	r2,-28(fp)
	}
  805460:	e037883a 	mov	sp,fp
  805464:	dfc00117 	ldw	ra,4(sp)
  805468:	df000017 	ldw	fp,0(sp)
  80546c:	dec00204 	addi	sp,sp,8
  805470:	f800283a 	ret

00805474 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
  805474:	defff604 	addi	sp,sp,-40
  805478:	dfc00915 	stw	ra,36(sp)
  80547c:	df000815 	stw	fp,32(sp)
  805480:	df000804 	addi	fp,sp,32
  805484:	e13ffc15 	stw	r4,-16(fp)
  805488:	e17ffd15 	stw	r5,-12(fp)
  80548c:	e1bffe15 	stw	r6,-8(fp)
  805490:	e1ffff15 	stw	r7,-4(fp)
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
  805494:	00800044 	movi	r2,1
  805498:	e0bff815 	stw	r2,-32(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
  80549c:	e0bffc17 	ldw	r2,-16(fp)
  8054a0:	e0bff915 	stw	r2,-28(fp)

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  8054a4:	e03ffa15 	stw	zero,-24(fp)
		{
			if( pulPreviousNotificationValue != NULL )
  8054a8:	e0bfff17 	ldw	r2,-4(fp)
  8054ac:	10000426 	beq	r2,zero,8054c0 <xTaskGenericNotifyFromISR+0x4c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
  8054b0:	e0bff917 	ldw	r2,-28(fp)
  8054b4:	10c01217 	ldw	r3,72(r2)
  8054b8:	e0bfff17 	ldw	r2,-4(fp)
  8054bc:	10c00015 	stw	r3,0(r2)
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
  8054c0:	e0bff917 	ldw	r2,-28(fp)
  8054c4:	10801303 	ldbu	r2,76(r2)
  8054c8:	e0bffb05 	stb	r2,-20(fp)
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
  8054cc:	e0bff917 	ldw	r2,-28(fp)
  8054d0:	00c00084 	movi	r3,2
  8054d4:	10c01305 	stb	r3,76(r2)

			switch( eAction )
  8054d8:	e0bffe17 	ldw	r2,-8(fp)
  8054dc:	10800168 	cmpgeui	r2,r2,5
  8054e0:	1000261e 	bne	r2,zero,80557c <xTaskGenericNotifyFromISR+0x108>
  8054e4:	e0bffe17 	ldw	r2,-8(fp)
  8054e8:	100690ba 	slli	r3,r2,2
  8054ec:	00802034 	movhi	r2,128
  8054f0:	10954004 	addi	r2,r2,21760
  8054f4:	1885883a 	add	r2,r3,r2
  8054f8:	10800017 	ldw	r2,0(r2)
  8054fc:	1000683a 	jmp	r2
  805500:	00805584 	movi	r2,342
  805504:	00805514 	movui	r2,340
  805508:	00805530 	cmpltui	r2,zero,340
  80550c:	00805548 	cmpgei	r2,zero,341
  805510:	00805558 	cmpnei	r2,zero,341
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
  805514:	e0bff917 	ldw	r2,-28(fp)
  805518:	10c01217 	ldw	r3,72(r2)
  80551c:	e0bffd17 	ldw	r2,-12(fp)
  805520:	1886b03a 	or	r3,r3,r2
  805524:	e0bff917 	ldw	r2,-28(fp)
  805528:	10c01215 	stw	r3,72(r2)
					break;
  80552c:	00001606 	br	805588 <xTaskGenericNotifyFromISR+0x114>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
  805530:	e0bff917 	ldw	r2,-28(fp)
  805534:	10801217 	ldw	r2,72(r2)
  805538:	10c00044 	addi	r3,r2,1
  80553c:	e0bff917 	ldw	r2,-28(fp)
  805540:	10c01215 	stw	r3,72(r2)
					break;
  805544:	00001006 	br	805588 <xTaskGenericNotifyFromISR+0x114>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
  805548:	e0bff917 	ldw	r2,-28(fp)
  80554c:	e0fffd17 	ldw	r3,-12(fp)
  805550:	10c01215 	stw	r3,72(r2)
					break;
  805554:	00000c06 	br	805588 <xTaskGenericNotifyFromISR+0x114>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
  805558:	e0bffb03 	ldbu	r2,-20(fp)
  80555c:	108000a0 	cmpeqi	r2,r2,2
  805560:	1000041e 	bne	r2,zero,805574 <xTaskGenericNotifyFromISR+0x100>
					{
						pxTCB->ulNotifiedValue = ulValue;
  805564:	e0bff917 	ldw	r2,-28(fp)
  805568:	e0fffd17 	ldw	r3,-12(fp)
  80556c:	10c01215 	stw	r3,72(r2)
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
  805570:	00000506 	br	805588 <xTaskGenericNotifyFromISR+0x114>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
  805574:	e03ff815 	stw	zero,-32(fp)
					}
					break;
  805578:	00000306 	br	805588 <xTaskGenericNotifyFromISR+0x114>
				default:
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
					break;
  80557c:	0001883a 	nop
  805580:	00000106 	br	805588 <xTaskGenericNotifyFromISR+0x114>
					break;

				case eNoAction :
					/* The task is being notified without its notify value being
					updated. */
					break;
  805584:	0001883a 	nop

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
  805588:	e0bffb03 	ldbu	r2,-20(fp)
  80558c:	10800058 	cmpnei	r2,r2,1
  805590:	10002b1e 	bne	r2,zero,805640 <xTaskGenericNotifyFromISR+0x1cc>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  805594:	d0a4e017 	ldw	r2,-27776(gp)
  805598:	1000171e 	bne	r2,zero,8055f8 <xTaskGenericNotifyFromISR+0x184>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  80559c:	e0bff917 	ldw	r2,-28(fp)
  8055a0:	10800104 	addi	r2,r2,4
  8055a4:	1009883a 	mov	r4,r2
  8055a8:	0800b980 	call	800b98 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
  8055ac:	e0bff917 	ldw	r2,-28(fp)
  8055b0:	10800b17 	ldw	r2,44(r2)
  8055b4:	d0e4d817 	ldw	r3,-27808(gp)
  8055b8:	1880032e 	bgeu	r3,r2,8055c8 <xTaskGenericNotifyFromISR+0x154>
  8055bc:	e0bff917 	ldw	r2,-28(fp)
  8055c0:	10800b17 	ldw	r2,44(r2)
  8055c4:	d0a4d815 	stw	r2,-27808(gp)
  8055c8:	e0bff917 	ldw	r2,-28(fp)
  8055cc:	10800b17 	ldw	r2,44(r2)
  8055d0:	10c00524 	muli	r3,r2,20
  8055d4:	00802174 	movhi	r2,133
  8055d8:	10a18c04 	addi	r2,r2,-31184
  8055dc:	1887883a 	add	r3,r3,r2
  8055e0:	e0bff917 	ldw	r2,-28(fp)
  8055e4:	10800104 	addi	r2,r2,4
  8055e8:	100b883a 	mov	r5,r2
  8055ec:	1809883a 	mov	r4,r3
  8055f0:	0800a340 	call	800a34 <vListInsertEnd>
  8055f4:	00000606 	br	805610 <xTaskGenericNotifyFromISR+0x19c>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
  8055f8:	e0bff917 	ldw	r2,-28(fp)
  8055fc:	10800604 	addi	r2,r2,24
  805600:	100b883a 	mov	r5,r2
  805604:	01002174 	movhi	r4,133
  805608:	2121af04 	addi	r4,r4,-31044
  80560c:	0800a340 	call	800a34 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
  805610:	e0bff917 	ldw	r2,-28(fp)
  805614:	10800b17 	ldw	r2,44(r2)
  805618:	d0e4d217 	ldw	r3,-27832(gp)
  80561c:	18c00b17 	ldw	r3,44(r3)
  805620:	1880072e 	bgeu	r3,r2,805640 <xTaskGenericNotifyFromISR+0x1cc>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
  805624:	e0800217 	ldw	r2,8(fp)
  805628:	10000326 	beq	r2,zero,805638 <xTaskGenericNotifyFromISR+0x1c4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
  80562c:	e0800217 	ldw	r2,8(fp)
  805630:	00c00044 	movi	r3,1
  805634:	10c00015 	stw	r3,0(r2)
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
  805638:	00800044 	movi	r2,1
  80563c:	d0a4db15 	stw	r2,-27796(gp)
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
  805640:	e0bff817 	ldw	r2,-32(fp)
	}
  805644:	e037883a 	mov	sp,fp
  805648:	dfc00117 	ldw	ra,4(sp)
  80564c:	df000017 	ldw	fp,0(sp)
  805650:	dec00204 	addi	sp,sp,8
  805654:	f800283a 	ret

00805658 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
  805658:	defff904 	addi	sp,sp,-28
  80565c:	dfc00615 	stw	ra,24(sp)
  805660:	df000515 	stw	fp,20(sp)
  805664:	df000504 	addi	fp,sp,20
  805668:	e13ffe15 	stw	r4,-8(fp)
  80566c:	e17fff15 	stw	r5,-4(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
  805670:	e0bffe17 	ldw	r2,-8(fp)
  805674:	e0bffb15 	stw	r2,-20(fp)

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  805678:	e03ffc15 	stw	zero,-16(fp)
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
  80567c:	e0bffb17 	ldw	r2,-20(fp)
  805680:	10801303 	ldbu	r2,76(r2)
  805684:	e0bffd05 	stb	r2,-12(fp)
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
  805688:	e0bffb17 	ldw	r2,-20(fp)
  80568c:	00c00084 	movi	r3,2
  805690:	10c01305 	stb	r3,76(r2)

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
  805694:	e0bffb17 	ldw	r2,-20(fp)
  805698:	10801217 	ldw	r2,72(r2)
  80569c:	10c00044 	addi	r3,r2,1
  8056a0:	e0bffb17 	ldw	r2,-20(fp)
  8056a4:	10c01215 	stw	r3,72(r2)

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
  8056a8:	e0bffd03 	ldbu	r2,-12(fp)
  8056ac:	10800058 	cmpnei	r2,r2,1
  8056b0:	10002b1e 	bne	r2,zero,805760 <vTaskNotifyGiveFromISR+0x108>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  8056b4:	d0a4e017 	ldw	r2,-27776(gp)
  8056b8:	1000171e 	bne	r2,zero,805718 <vTaskNotifyGiveFromISR+0xc0>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  8056bc:	e0bffb17 	ldw	r2,-20(fp)
  8056c0:	10800104 	addi	r2,r2,4
  8056c4:	1009883a 	mov	r4,r2
  8056c8:	0800b980 	call	800b98 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
  8056cc:	e0bffb17 	ldw	r2,-20(fp)
  8056d0:	10800b17 	ldw	r2,44(r2)
  8056d4:	d0e4d817 	ldw	r3,-27808(gp)
  8056d8:	1880032e 	bgeu	r3,r2,8056e8 <vTaskNotifyGiveFromISR+0x90>
  8056dc:	e0bffb17 	ldw	r2,-20(fp)
  8056e0:	10800b17 	ldw	r2,44(r2)
  8056e4:	d0a4d815 	stw	r2,-27808(gp)
  8056e8:	e0bffb17 	ldw	r2,-20(fp)
  8056ec:	10800b17 	ldw	r2,44(r2)
  8056f0:	10c00524 	muli	r3,r2,20
  8056f4:	00802174 	movhi	r2,133
  8056f8:	10a18c04 	addi	r2,r2,-31184
  8056fc:	1887883a 	add	r3,r3,r2
  805700:	e0bffb17 	ldw	r2,-20(fp)
  805704:	10800104 	addi	r2,r2,4
  805708:	100b883a 	mov	r5,r2
  80570c:	1809883a 	mov	r4,r3
  805710:	0800a340 	call	800a34 <vListInsertEnd>
  805714:	00000606 	br	805730 <vTaskNotifyGiveFromISR+0xd8>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
  805718:	e0bffb17 	ldw	r2,-20(fp)
  80571c:	10800604 	addi	r2,r2,24
  805720:	100b883a 	mov	r5,r2
  805724:	01002174 	movhi	r4,133
  805728:	2121af04 	addi	r4,r4,-31044
  80572c:	0800a340 	call	800a34 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
  805730:	e0bffb17 	ldw	r2,-20(fp)
  805734:	10800b17 	ldw	r2,44(r2)
  805738:	d0e4d217 	ldw	r3,-27832(gp)
  80573c:	18c00b17 	ldw	r3,44(r3)
  805740:	1880072e 	bgeu	r3,r2,805760 <vTaskNotifyGiveFromISR+0x108>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
  805744:	e0bfff17 	ldw	r2,-4(fp)
  805748:	10000326 	beq	r2,zero,805758 <vTaskNotifyGiveFromISR+0x100>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
  80574c:	e0bfff17 	ldw	r2,-4(fp)
  805750:	00c00044 	movi	r3,1
  805754:	10c00015 	stw	r3,0(r2)
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
  805758:	00800044 	movi	r2,1
  80575c:	d0a4db15 	stw	r2,-27796(gp)
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
  805760:	0001883a 	nop
  805764:	e037883a 	mov	sp,fp
  805768:	dfc00117 	ldw	ra,4(sp)
  80576c:	df000017 	ldw	fp,0(sp)
  805770:	dec00204 	addi	sp,sp,8
  805774:	f800283a 	ret

00805778 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
  805778:	defffb04 	addi	sp,sp,-20
  80577c:	dfc00415 	stw	ra,16(sp)
  805780:	df000315 	stw	fp,12(sp)
  805784:	df000304 	addi	fp,sp,12
  805788:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
  80578c:	e0bfff17 	ldw	r2,-4(fp)
  805790:	1000021e 	bne	r2,zero,80579c <xTaskNotifyStateClear+0x24>
  805794:	d0a4d217 	ldw	r2,-27832(gp)
  805798:	00000106 	br	8057a0 <xTaskNotifyStateClear+0x28>
  80579c:	e0bfff17 	ldw	r2,-4(fp)
  8057a0:	e0bffe15 	stw	r2,-8(fp)

		taskENTER_CRITICAL();
  8057a4:	0804ff40 	call	804ff4 <vTaskEnterCritical>
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
  8057a8:	e0bffe17 	ldw	r2,-8(fp)
  8057ac:	10801303 	ldbu	r2,76(r2)
  8057b0:	10803fcc 	andi	r2,r2,255
  8057b4:	10800098 	cmpnei	r2,r2,2
  8057b8:	1000051e 	bne	r2,zero,8057d0 <xTaskNotifyStateClear+0x58>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
  8057bc:	e0bffe17 	ldw	r2,-8(fp)
  8057c0:	10001305 	stb	zero,76(r2)
				xReturn = pdPASS;
  8057c4:	00800044 	movi	r2,1
  8057c8:	e0bffd15 	stw	r2,-12(fp)
  8057cc:	00000106 	br	8057d4 <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
  8057d0:	e03ffd15 	stw	zero,-12(fp)
			}
		}
		taskEXIT_CRITICAL();
  8057d4:	08050480 	call	805048 <vTaskExitCritical>

		return xReturn;
  8057d8:	e0bffd17 	ldw	r2,-12(fp)
	}
  8057dc:	e037883a 	mov	sp,fp
  8057e0:	dfc00117 	ldw	ra,4(sp)
  8057e4:	df000017 	ldw	fp,0(sp)
  8057e8:	dec00204 	addi	sp,sp,8
  8057ec:	f800283a 	ret

008057f0 <ulTaskNotifyValueClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyValueClear( TaskHandle_t xTask, uint32_t ulBitsToClear )
	{
  8057f0:	defffa04 	addi	sp,sp,-24
  8057f4:	dfc00515 	stw	ra,20(sp)
  8057f8:	df000415 	stw	fp,16(sp)
  8057fc:	df000404 	addi	fp,sp,16
  805800:	e13ffe15 	stw	r4,-8(fp)
  805804:	e17fff15 	stw	r5,-4(fp)
	TCB_t *pxTCB;
	uint32_t ulReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
  805808:	e0bffe17 	ldw	r2,-8(fp)
  80580c:	1000021e 	bne	r2,zero,805818 <ulTaskNotifyValueClear+0x28>
  805810:	d0a4d217 	ldw	r2,-27832(gp)
  805814:	00000106 	br	80581c <ulTaskNotifyValueClear+0x2c>
  805818:	e0bffe17 	ldw	r2,-8(fp)
  80581c:	e0bffc15 	stw	r2,-16(fp)

		taskENTER_CRITICAL();
  805820:	0804ff40 	call	804ff4 <vTaskEnterCritical>
		{
			/* Return the notification as it was before the bits were cleared,
			then clear the bit mask. */
			ulReturn = pxCurrentTCB->ulNotifiedValue;
  805824:	d0a4d217 	ldw	r2,-27832(gp)
  805828:	10801217 	ldw	r2,72(r2)
  80582c:	e0bffd15 	stw	r2,-12(fp)
			pxTCB->ulNotifiedValue &= ~ulBitsToClear;
  805830:	e0bffc17 	ldw	r2,-16(fp)
  805834:	10c01217 	ldw	r3,72(r2)
  805838:	e0bfff17 	ldw	r2,-4(fp)
  80583c:	0084303a 	nor	r2,zero,r2
  805840:	1886703a 	and	r3,r3,r2
  805844:	e0bffc17 	ldw	r2,-16(fp)
  805848:	10c01215 	stw	r3,72(r2)
		}
		taskEXIT_CRITICAL();
  80584c:	08050480 	call	805048 <vTaskExitCritical>

		return ulReturn;
  805850:	e0bffd17 	ldw	r2,-12(fp)
	}
  805854:	e037883a 	mov	sp,fp
  805858:	dfc00117 	ldw	ra,4(sp)
  80585c:	df000017 	ldw	fp,0(sp)
  805860:	dec00204 	addi	sp,sp,8
  805864:	f800283a 	ret

00805868 <prvAddCurrentTaskToDelayedList>:

#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
  805868:	defffa04 	addi	sp,sp,-24
  80586c:	dfc00515 	stw	ra,20(sp)
  805870:	df000415 	stw	fp,16(sp)
  805874:	df000404 	addi	fp,sp,16
  805878:	e13ffe15 	stw	r4,-8(fp)
  80587c:	e17fff15 	stw	r5,-4(fp)
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
  805880:	d0a4d717 	ldw	r2,-27812(gp)
  805884:	e0bffc15 	stw	r2,-16(fp)
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  805888:	d0a4d217 	ldw	r2,-27832(gp)
  80588c:	10800104 	addi	r2,r2,4
  805890:	1009883a 	mov	r4,r2
  805894:	0800b980 	call	800b98 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
  805898:	e0bffe17 	ldw	r2,-8(fp)
  80589c:	10bfffd8 	cmpnei	r2,r2,-1
  8058a0:	1000091e 	bne	r2,zero,8058c8 <prvAddCurrentTaskToDelayedList+0x60>
  8058a4:	e0bfff17 	ldw	r2,-4(fp)
  8058a8:	10000726 	beq	r2,zero,8058c8 <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
  8058ac:	d0a4d217 	ldw	r2,-27832(gp)
  8058b0:	10800104 	addi	r2,r2,4
  8058b4:	100b883a 	mov	r5,r2
  8058b8:	01002174 	movhi	r4,133
  8058bc:	2121b904 	addi	r4,r4,-31004
  8058c0:	0800a340 	call	800a34 <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
  8058c4:	00001c06 	br	805938 <prvAddCurrentTaskToDelayedList+0xd0>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
  8058c8:	e0fffc17 	ldw	r3,-16(fp)
  8058cc:	e0bffe17 	ldw	r2,-8(fp)
  8058d0:	1885883a 	add	r2,r3,r2
  8058d4:	e0bffd15 	stw	r2,-12(fp)

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
  8058d8:	d0a4d217 	ldw	r2,-27832(gp)
  8058dc:	e0fffd17 	ldw	r3,-12(fp)
  8058e0:	10c00115 	stw	r3,4(r2)

			if( xTimeToWake < xConstTickCount )
  8058e4:	e0fffd17 	ldw	r3,-12(fp)
  8058e8:	e0bffc17 	ldw	r2,-16(fp)
  8058ec:	1880072e 	bgeu	r3,r2,80590c <prvAddCurrentTaskToDelayedList+0xa4>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
  8058f0:	d0e4d417 	ldw	r3,-27824(gp)
  8058f4:	d0a4d217 	ldw	r2,-27832(gp)
  8058f8:	10800104 	addi	r2,r2,4
  8058fc:	100b883a 	mov	r5,r2
  805900:	1809883a 	mov	r4,r3
  805904:	0800ac00 	call	800ac0 <vListInsert>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
  805908:	00000b06 	br	805938 <prvAddCurrentTaskToDelayedList+0xd0>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
  80590c:	d0e4d317 	ldw	r3,-27828(gp)
  805910:	d0a4d217 	ldw	r2,-27832(gp)
  805914:	10800104 	addi	r2,r2,4
  805918:	100b883a 	mov	r5,r2
  80591c:	1809883a 	mov	r4,r3
  805920:	0800ac00 	call	800ac0 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
  805924:	d0a4de17 	ldw	r2,-27784(gp)
  805928:	e0fffd17 	ldw	r3,-12(fp)
  80592c:	1880022e 	bgeu	r3,r2,805938 <prvAddCurrentTaskToDelayedList+0xd0>
				{
					xNextTaskUnblockTime = xTimeToWake;
  805930:	e0bffd17 	ldw	r2,-12(fp)
  805934:	d0a4de15 	stw	r2,-27784(gp)

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
  805938:	0001883a 	nop
  80593c:	e037883a 	mov	sp,fp
  805940:	dfc00117 	ldw	ra,4(sp)
  805944:	df000017 	ldw	fp,0(sp)
  805948:	dec00204 	addi	sp,sp,8
  80594c:	f800283a 	ret

00805950 <set_output>:

//#pragma diag_warning 188


static void set_output(const bool output)
{
  805950:	defffe04 	addi	sp,sp,-8
  805954:	df000115 	stw	fp,4(sp)
  805958:	df000104 	addi	fp,sp,4
  80595c:	e13fff15 	stw	r4,-4(fp)

	IOWR_ALTERA_AVALON_PIO_DIRECTION(LCD_DATA_BASE, 0);
  805960:	0007883a 	mov	r3,zero
  805964:	00804434 	movhi	r2,272
  805968:	10841904 	addi	r2,r2,4196
  80596c:	10c00035 	stwio	r3,0(r2)
	if (output)
  805970:	e0bfff17 	ldw	r2,-4(fp)
  805974:	10000426 	beq	r2,zero,805988 <set_output+0x38>
		IOWR_ALTERA_AVALON_PIO_DIRECTION(LCD_DATA_BASE, 0xFF);
  805978:	00c03fc4 	movi	r3,255
  80597c:	00804434 	movhi	r2,272
  805980:	10841904 	addi	r2,r2,4196
  805984:	10c00035 	stwio	r3,0(r2)
}
  805988:	0001883a 	nop
  80598c:	e037883a 	mov	sp,fp
  805990:	df000017 	ldw	fp,0(sp)
  805994:	dec00104 	addi	sp,sp,4
  805998:	f800283a 	ret

0080599c <enable>:

static void enable(const bool pulse)
{
  80599c:	defffd04 	addi	sp,sp,-12
  8059a0:	dfc00215 	stw	ra,8(sp)
  8059a4:	df000115 	stw	fp,4(sp)
  8059a8:	df000104 	addi	fp,sp,4
  8059ac:	e13fff15 	stw	r4,-4(fp)
	if (pulse)
  8059b0:	e0bfff17 	ldw	r2,-4(fp)
  8059b4:	10000626 	beq	r2,zero,8059d0 <enable+0x34>
	{
		IOWR_ALTERA_AVALON_PIO_DATA(LCD_E_BASE, 0x01);
  8059b8:	00c00044 	movi	r3,1
  8059bc:	00804434 	movhi	r2,272
  8059c0:	10840c04 	addi	r2,r2,4144
  8059c4:	10c00035 	stwio	r3,0(r2)
		vTaskDelay(1);
  8059c8:	01000044 	movi	r4,1
  8059cc:	0803a040 	call	803a04 <vTaskDelay>
	}
	IOWR_ALTERA_AVALON_PIO_DATA(LCD_E_BASE, 0);
  8059d0:	0007883a 	mov	r3,zero
  8059d4:	00804434 	movhi	r2,272
  8059d8:	10840c04 	addi	r2,r2,4144
  8059dc:	10c00035 	stwio	r3,0(r2)
	vTaskDelay(1);
  8059e0:	01000044 	movi	r4,1
  8059e4:	0803a040 	call	803a04 <vTaskDelay>
}
  8059e8:	0001883a 	nop
  8059ec:	e037883a 	mov	sp,fp
  8059f0:	dfc00117 	ldw	ra,4(sp)
  8059f4:	df000017 	ldw	fp,0(sp)
  8059f8:	dec00204 	addi	sp,sp,8
  8059fc:	f800283a 	ret

00805a00 <write>:

static void write(const alt_u8 data, const bool reg)
{
  805a00:	defffc04 	addi	sp,sp,-16
  805a04:	dfc00315 	stw	ra,12(sp)
  805a08:	df000215 	stw	fp,8(sp)
  805a0c:	df000204 	addi	fp,sp,8
  805a10:	2005883a 	mov	r2,r4
  805a14:	e17fff15 	stw	r5,-4(fp)
  805a18:	e0bffe05 	stb	r2,-8(fp)
	set_output(TRUE);
  805a1c:	01000044 	movi	r4,1
  805a20:	08059500 	call	805950 <set_output>
	//alt_putstr("set_output TRUE\n");
	
	IOWR_ALTERA_AVALON_PIO_DATA(LCD_RW_BASE, 0);
  805a24:	0007883a 	mov	r3,zero
  805a28:	00804434 	movhi	r2,272
  805a2c:	10841004 	addi	r2,r2,4160
  805a30:	10c00035 	stwio	r3,0(r2)
	//alt_putstr("RW 0\n");
	IOWR_ALTERA_AVALON_PIO_DATA(LCD_RS_BASE, reg);
  805a34:	00804434 	movhi	r2,272
  805a38:	10841404 	addi	r2,r2,4176
  805a3c:	e0ffff17 	ldw	r3,-4(fp)
  805a40:	10c00035 	stwio	r3,0(r2)
	//alt_putstr("RS installed\n");
	
	if (MODE_8_OR_4 == 8) IOWR_ALTERA_AVALON_PIO_DATA(LCD_DATA_BASE, data);
  805a44:	e0fffe03 	ldbu	r3,-8(fp)
  805a48:	00804434 	movhi	r2,272
  805a4c:	10841804 	addi	r2,r2,4192
  805a50:	10c00035 	stwio	r3,0(r2)
	else IOWR_ALTERA_AVALON_PIO_DATA(LCD_DATA_BASE, data << 4);
	//alt_putstr("data installed\n");
	
	enable(TRUE);
  805a54:	01000044 	movi	r4,1
  805a58:	080599c0 	call	80599c <enable>
	//alt_putstr("enable\n");
}
  805a5c:	0001883a 	nop
  805a60:	e037883a 	mov	sp,fp
  805a64:	dfc00117 	ldw	ra,4(sp)
  805a68:	df000017 	ldw	fp,0(sp)
  805a6c:	dec00204 	addi	sp,sp,8
  805a70:	f800283a 	ret

00805a74 <read_busy>:

static bool read_busy(void)
{
  805a74:	defffd04 	addi	sp,sp,-12
  805a78:	dfc00215 	stw	ra,8(sp)
  805a7c:	df000115 	stw	fp,4(sp)
  805a80:	df000104 	addi	fp,sp,4
	alt_u8 data;

	set_output(FALSE);
  805a84:	0009883a 	mov	r4,zero
  805a88:	08059500 	call	805950 <set_output>
	IOWR_ALTERA_AVALON_PIO_DATA(LCD_RS_BASE, 0);
  805a8c:	0007883a 	mov	r3,zero
  805a90:	00804434 	movhi	r2,272
  805a94:	10841404 	addi	r2,r2,4176
  805a98:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_AVALON_PIO_DATA(LCD_RW_BASE, 0x01);
  805a9c:	00c00044 	movi	r3,1
  805aa0:	00804434 	movhi	r2,272
  805aa4:	10841004 	addi	r2,r2,4160
  805aa8:	10c00035 	stwio	r3,0(r2)
	enable(FALSE);
  805aac:	0009883a 	mov	r4,zero
  805ab0:	080599c0 	call	80599c <enable>
	data = IORD_ALTERA_AVALON_PIO_DATA(LCD_DATA_BASE);
  805ab4:	00804434 	movhi	r2,272
  805ab8:	10841804 	addi	r2,r2,4192
  805abc:	10800037 	ldwio	r2,0(r2)
  805ac0:	e0bfff05 	stb	r2,-4(fp)
	enable(FALSE);
  805ac4:	0009883a 	mov	r4,zero
  805ac8:	080599c0 	call	80599c <enable>
	enable(TRUE);
  805acc:	01000044 	movi	r4,1
  805ad0:	080599c0 	call	80599c <enable>

	if (data >> 7 == 1)
  805ad4:	e0bfff03 	ldbu	r2,-4(fp)
  805ad8:	1004d1fa 	srli	r2,r2,7
  805adc:	10803fcc 	andi	r2,r2,255
  805ae0:	10800058 	cmpnei	r2,r2,1
  805ae4:	1000021e 	bne	r2,zero,805af0 <read_busy+0x7c>
		return (TRUE);
  805ae8:	00800044 	movi	r2,1
  805aec:	00000106 	br	805af4 <read_busy+0x80>

	return (FALSE);
  805af0:	0005883a 	mov	r2,zero

}
  805af4:	e037883a 	mov	sp,fp
  805af8:	dfc00117 	ldw	ra,4(sp)
  805afc:	df000017 	ldw	fp,0(sp)
  805b00:	dec00204 	addi	sp,sp,8
  805b04:	f800283a 	ret

00805b08 <hd44780_clear>:

/**
 * Clear the LCD
 */
void hd44780_clear(xQueueHandle Queue_lcd_data, xQueueHandle Queue_lcd_rs, xSemaphoreHandle Mutex_write_lcd)
{
  805b08:	defff904 	addi	sp,sp,-28
  805b0c:	dfc00615 	stw	ra,24(sp)
  805b10:	df000515 	stw	fp,20(sp)
  805b14:	df000504 	addi	fp,sp,20
  805b18:	e13ffd15 	stw	r4,-12(fp)
  805b1c:	e17ffe15 	stw	r5,-8(fp)
  805b20:	e1bfff15 	stw	r6,-4(fp)
	int data = 0x01;
  805b24:	00800044 	movi	r2,1
  805b28:	e0bffb15 	stw	r2,-20(fp)
	int rs = 0;
  805b2c:	e03ffc15 	stw	zero,-16(fp)
	if( xSemaphoreTake( Mutex_write_lcd, portMAX_DELAY ) == pdTRUE )
  805b30:	017fffc4 	movi	r5,-1
  805b34:	e13fff17 	ldw	r4,-4(fp)
  805b38:	0801aec0 	call	801aec <xQueueSemaphoreTake>
  805b3c:	10800058 	cmpnei	r2,r2,1
  805b40:	1000101e 	bne	r2,zero,805b84 <hd44780_clear+0x7c>
	{
		xQueueSendToBack(Queue_lcd_data, &data, portMAX_DELAY);
  805b44:	000f883a 	mov	r7,zero
  805b48:	01bfffc4 	movi	r6,-1
  805b4c:	e17ffb04 	addi	r5,fp,-20
  805b50:	e13ffd17 	ldw	r4,-12(fp)
  805b54:	08015c00 	call	8015c0 <xQueueGenericSend>
		xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
  805b58:	e0bffc04 	addi	r2,fp,-16
  805b5c:	000f883a 	mov	r7,zero
  805b60:	01bfffc4 	movi	r6,-1
  805b64:	100b883a 	mov	r5,r2
  805b68:	e13ffe17 	ldw	r4,-8(fp)
  805b6c:	08015c00 	call	8015c0 <xQueueGenericSend>
		xSemaphoreGive( Mutex_write_lcd );
  805b70:	000f883a 	mov	r7,zero
  805b74:	000d883a 	mov	r6,zero
  805b78:	000b883a 	mov	r5,zero
  805b7c:	e13fff17 	ldw	r4,-4(fp)
  805b80:	08015c00 	call	8015c0 <xQueueGenericSend>
	}
}
  805b84:	0001883a 	nop
  805b88:	e037883a 	mov	sp,fp
  805b8c:	dfc00117 	ldw	ra,4(sp)
  805b90:	df000017 	ldw	fp,0(sp)
  805b94:	dec00204 	addi	sp,sp,8
  805b98:	f800283a 	ret

00805b9c <hd44780_home>:

/**
 * Move cursor home
 */
void hd44780_home(xQueueHandle Queue_lcd_data, xQueueHandle Queue_lcd_rs, xSemaphoreHandle Mutex_write_lcd)
{
  805b9c:	defff904 	addi	sp,sp,-28
  805ba0:	dfc00615 	stw	ra,24(sp)
  805ba4:	df000515 	stw	fp,20(sp)
  805ba8:	df000504 	addi	fp,sp,20
  805bac:	e13ffd15 	stw	r4,-12(fp)
  805bb0:	e17ffe15 	stw	r5,-8(fp)
  805bb4:	e1bfff15 	stw	r6,-4(fp)
	int data = 0x02;
  805bb8:	00800084 	movi	r2,2
  805bbc:	e0bffb15 	stw	r2,-20(fp)
	int rs = 0;
  805bc0:	e03ffc15 	stw	zero,-16(fp)
	if( xSemaphoreTake( Mutex_write_lcd, portMAX_DELAY ) == pdTRUE )
  805bc4:	017fffc4 	movi	r5,-1
  805bc8:	e13fff17 	ldw	r4,-4(fp)
  805bcc:	0801aec0 	call	801aec <xQueueSemaphoreTake>
  805bd0:	10800058 	cmpnei	r2,r2,1
  805bd4:	1000101e 	bne	r2,zero,805c18 <hd44780_home+0x7c>
	{
		xQueueSendToBack(Queue_lcd_data, &data, portMAX_DELAY);
  805bd8:	000f883a 	mov	r7,zero
  805bdc:	01bfffc4 	movi	r6,-1
  805be0:	e17ffb04 	addi	r5,fp,-20
  805be4:	e13ffd17 	ldw	r4,-12(fp)
  805be8:	08015c00 	call	8015c0 <xQueueGenericSend>
		xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
  805bec:	e0bffc04 	addi	r2,fp,-16
  805bf0:	000f883a 	mov	r7,zero
  805bf4:	01bfffc4 	movi	r6,-1
  805bf8:	100b883a 	mov	r5,r2
  805bfc:	e13ffe17 	ldw	r4,-8(fp)
  805c00:	08015c00 	call	8015c0 <xQueueGenericSend>
		xSemaphoreGive( Mutex_write_lcd );
  805c04:	000f883a 	mov	r7,zero
  805c08:	000d883a 	mov	r6,zero
  805c0c:	000b883a 	mov	r5,zero
  805c10:	e13fff17 	ldw	r4,-4(fp)
  805c14:	08015c00 	call	8015c0 <xQueueGenericSend>
	}
}
  805c18:	0001883a 	nop
  805c1c:	e037883a 	mov	sp,fp
  805c20:	dfc00117 	ldw	ra,4(sp)
  805c24:	df000017 	ldw	fp,0(sp)
  805c28:	dec00204 	addi	sp,sp,8
  805c2c:	f800283a 	ret

00805c30 <hd44780_display>:
 * @param cursor	Cursor on/off
 * @param blink		Blinking cursor on/off
 *
 */
void hd44780_display(xQueueHandle Queue_lcd_data, xQueueHandle Queue_lcd_rs, xSemaphoreHandle Mutex_write_lcd, const bool enable, const bool cursor, const bool blink)
{
  805c30:	defff804 	addi	sp,sp,-32
  805c34:	dfc00715 	stw	ra,28(sp)
  805c38:	df000615 	stw	fp,24(sp)
  805c3c:	df000604 	addi	fp,sp,24
  805c40:	e13ffc15 	stw	r4,-16(fp)
  805c44:	e17ffd15 	stw	r5,-12(fp)
  805c48:	e1bffe15 	stw	r6,-8(fp)
  805c4c:	e1ffff15 	stw	r7,-4(fp)
	alt_u16 command = HD44780_DISPLAY;
  805c50:	00800204 	movi	r2,8
  805c54:	e0bffa0d 	sth	r2,-24(fp)

	if (enable)
  805c58:	e0bfff17 	ldw	r2,-4(fp)
  805c5c:	10000326 	beq	r2,zero,805c6c <hd44780_display+0x3c>
		command |= HD44780_DISPLAY_ON;
  805c60:	e0bffa0b 	ldhu	r2,-24(fp)
  805c64:	10800114 	ori	r2,r2,4
  805c68:	e0bffa0d 	sth	r2,-24(fp)
	/*else
  {
		Queue_Head = Queue_Tail = 0;
	}*/
	if (cursor)
  805c6c:	e0800217 	ldw	r2,8(fp)
  805c70:	10000326 	beq	r2,zero,805c80 <hd44780_display+0x50>
		command |= HD44780_CURSOR_ON;
  805c74:	e0bffa0b 	ldhu	r2,-24(fp)
  805c78:	10800094 	ori	r2,r2,2
  805c7c:	e0bffa0d 	sth	r2,-24(fp)
	if (blink)
  805c80:	e0800317 	ldw	r2,12(fp)
  805c84:	10000326 	beq	r2,zero,805c94 <hd44780_display+0x64>
		command |= HD44780_BLINK_ON;
  805c88:	e0bffa0b 	ldhu	r2,-24(fp)
  805c8c:	10800054 	ori	r2,r2,1
  805c90:	e0bffa0d 	sth	r2,-24(fp)

	int rs = 0;
  805c94:	e03ffb15 	stw	zero,-20(fp)
	if( xSemaphoreTake( Mutex_write_lcd, portMAX_DELAY ) == pdTRUE )
  805c98:	017fffc4 	movi	r5,-1
  805c9c:	e13ffe17 	ldw	r4,-8(fp)
  805ca0:	0801aec0 	call	801aec <xQueueSemaphoreTake>
  805ca4:	10800058 	cmpnei	r2,r2,1
  805ca8:	1000101e 	bne	r2,zero,805cec <hd44780_display+0xbc>
	{
		xQueueSendToBack(Queue_lcd_data, &command, portMAX_DELAY);
  805cac:	000f883a 	mov	r7,zero
  805cb0:	01bfffc4 	movi	r6,-1
  805cb4:	e17ffa04 	addi	r5,fp,-24
  805cb8:	e13ffc17 	ldw	r4,-16(fp)
  805cbc:	08015c00 	call	8015c0 <xQueueGenericSend>
		xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
  805cc0:	e0bffb04 	addi	r2,fp,-20
  805cc4:	000f883a 	mov	r7,zero
  805cc8:	01bfffc4 	movi	r6,-1
  805ccc:	100b883a 	mov	r5,r2
  805cd0:	e13ffd17 	ldw	r4,-12(fp)
  805cd4:	08015c00 	call	8015c0 <xQueueGenericSend>
		xSemaphoreGive( Mutex_write_lcd );
  805cd8:	000f883a 	mov	r7,zero
  805cdc:	000d883a 	mov	r6,zero
  805ce0:	000b883a 	mov	r5,zero
  805ce4:	e13ffe17 	ldw	r4,-8(fp)
  805ce8:	08015c00 	call	8015c0 <xQueueGenericSend>
	}
}
  805cec:	0001883a 	nop
  805cf0:	e037883a 	mov	sp,fp
  805cf4:	dfc00117 	ldw	ra,4(sp)
  805cf8:	df000017 	ldw	fp,0(sp)
  805cfc:	dec00204 	addi	sp,sp,8
  805d00:	f800283a 	ret

00805d04 <hd44780_position>:
 *
 * @param row	Row
 * @param col	Column
 */
void hd44780_position(xQueueHandle Queue_lcd_data, xQueueHandle Queue_lcd_rs, xSemaphoreHandle Mutex_write_lcd, const alt_u8 row, const alt_u8 col)
{
  805d04:	defff604 	addi	sp,sp,-40
  805d08:	dfc00915 	stw	ra,36(sp)
  805d0c:	df000815 	stw	fp,32(sp)
  805d10:	df000804 	addi	fp,sp,32
  805d14:	e13ffb15 	stw	r4,-20(fp)
  805d18:	e17ffc15 	stw	r5,-16(fp)
  805d1c:	e1bffd15 	stw	r6,-12(fp)
  805d20:	3807883a 	mov	r3,r7
  805d24:	e0800217 	ldw	r2,8(fp)
  805d28:	e0fffe05 	stb	r3,-8(fp)
  805d2c:	e0bfff05 	stb	r2,-4(fp)
	alt_u16 command = HD44780_DGRAM;
  805d30:	00802004 	movi	r2,128
  805d34:	e0bff80d 	sth	r2,-32(fp)
	const alt_u8 offsets[] = { 0x00, 0x40, 0x14, 0x54 };
  805d38:	e03ff885 	stb	zero,-30(fp)
  805d3c:	00801004 	movi	r2,64
  805d40:	e0bff8c5 	stb	r2,-29(fp)
  805d44:	00800504 	movi	r2,20
  805d48:	e0bff905 	stb	r2,-28(fp)
  805d4c:	00801504 	movi	r2,84
  805d50:	e0bff945 	stb	r2,-27(fp)

	command |= col + offsets[row];
  805d54:	e0ffff03 	ldbu	r3,-4(fp)
  805d58:	e0bffe03 	ldbu	r2,-8(fp)
  805d5c:	e13ff884 	addi	r4,fp,-30
  805d60:	2085883a 	add	r2,r4,r2
  805d64:	10800003 	ldbu	r2,0(r2)
  805d68:	10803fcc 	andi	r2,r2,255
  805d6c:	1885883a 	add	r2,r3,r2
  805d70:	1007883a 	mov	r3,r2
  805d74:	e0bff80b 	ldhu	r2,-32(fp)
  805d78:	1884b03a 	or	r2,r3,r2
  805d7c:	e0bff80d 	sth	r2,-32(fp)
	int rs = 0;
  805d80:	e03ffa15 	stw	zero,-24(fp)
	if( xSemaphoreTake( Mutex_write_lcd, portMAX_DELAY ) == pdTRUE )
  805d84:	017fffc4 	movi	r5,-1
  805d88:	e13ffd17 	ldw	r4,-12(fp)
  805d8c:	0801aec0 	call	801aec <xQueueSemaphoreTake>
  805d90:	10800058 	cmpnei	r2,r2,1
  805d94:	1000101e 	bne	r2,zero,805dd8 <hd44780_position+0xd4>
	{
		xQueueSendToBack(Queue_lcd_data, &command, portMAX_DELAY);
  805d98:	000f883a 	mov	r7,zero
  805d9c:	01bfffc4 	movi	r6,-1
  805da0:	e17ff804 	addi	r5,fp,-32
  805da4:	e13ffb17 	ldw	r4,-20(fp)
  805da8:	08015c00 	call	8015c0 <xQueueGenericSend>
		xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
  805dac:	e0bffa04 	addi	r2,fp,-24
  805db0:	000f883a 	mov	r7,zero
  805db4:	01bfffc4 	movi	r6,-1
  805db8:	100b883a 	mov	r5,r2
  805dbc:	e13ffc17 	ldw	r4,-16(fp)
  805dc0:	08015c00 	call	8015c0 <xQueueGenericSend>
		xSemaphoreGive( Mutex_write_lcd );
  805dc4:	000f883a 	mov	r7,zero
  805dc8:	000d883a 	mov	r6,zero
  805dcc:	000b883a 	mov	r5,zero
  805dd0:	e13ffd17 	ldw	r4,-12(fp)
  805dd4:	08015c00 	call	8015c0 <xQueueGenericSend>
	}
}
  805dd8:	0001883a 	nop
  805ddc:	e037883a 	mov	sp,fp
  805de0:	dfc00117 	ldw	ra,4(sp)
  805de4:	df000017 	ldw	fp,0(sp)
  805de8:	dec00204 	addi	sp,sp,8
  805dec:	f800283a 	ret

00805df0 <hd44780_cgram>:
 * @param pos	UDG number
 * @param udg	UDG definition
 */
 //необходимо проработать вопрос о записи элементо массива в очередь подряд без перерыва
void hd44780_cgram(xQueueHandle Queue_lcd_data, xQueueHandle Queue_lcd_rs, xSemaphoreHandle Mutex_write_lcd, const alt_u8 pos, const char udg[8])
{
  805df0:	defff804 	addi	sp,sp,-32
  805df4:	dfc00715 	stw	ra,28(sp)
  805df8:	df000615 	stw	fp,24(sp)
  805dfc:	df000604 	addi	fp,sp,24
  805e00:	e13ffc15 	stw	r4,-16(fp)
  805e04:	e17ffd15 	stw	r5,-12(fp)
  805e08:	e1bffe15 	stw	r6,-8(fp)
  805e0c:	3805883a 	mov	r2,r7
  805e10:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 i;
	alt_u16 command = HD44780_CGRAM;
  805e14:	00801004 	movi	r2,64
  805e18:	e0bffa8d 	sth	r2,-22(fp)

	if (pos < 8) alt_putstr("pos cgram failed");
  805e1c:	e0bfff03 	ldbu	r2,-4(fp)
  805e20:	10800228 	cmpgeui	r2,r2,8
  805e24:	1000031e 	bne	r2,zero,805e34 <hd44780_cgram+0x44>
  805e28:	01002074 	movhi	r4,129
  805e2c:	21237004 	addi	r4,r4,-29248
  805e30:	08071d00 	call	8071d0 <alt_putstr>

	command |= pos * 8;
  805e34:	e0bfff03 	ldbu	r2,-4(fp)
  805e38:	100490fa 	slli	r2,r2,3
  805e3c:	1007883a 	mov	r3,r2
  805e40:	e0bffa8b 	ldhu	r2,-22(fp)
  805e44:	1884b03a 	or	r2,r3,r2
  805e48:	e0bffa8d 	sth	r2,-22(fp)

	int rs = 0;
  805e4c:	e03ffb15 	stw	zero,-20(fp)
	if( xSemaphoreTake( Mutex_write_lcd, portMAX_DELAY ) == pdTRUE )
  805e50:	017fffc4 	movi	r5,-1
  805e54:	e13ffe17 	ldw	r4,-8(fp)
  805e58:	0801aec0 	call	801aec <xQueueSemaphoreTake>
  805e5c:	10800058 	cmpnei	r2,r2,1
  805e60:	1000291e 	bne	r2,zero,805f08 <hd44780_cgram+0x118>
	{
		xQueueSendToBack(Queue_lcd_data, &command, portMAX_DELAY);
  805e64:	e0bffa84 	addi	r2,fp,-22
  805e68:	000f883a 	mov	r7,zero
  805e6c:	01bfffc4 	movi	r6,-1
  805e70:	100b883a 	mov	r5,r2
  805e74:	e13ffc17 	ldw	r4,-16(fp)
  805e78:	08015c00 	call	8015c0 <xQueueGenericSend>
		xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
  805e7c:	e0bffb04 	addi	r2,fp,-20
  805e80:	000f883a 	mov	r7,zero
  805e84:	01bfffc4 	movi	r6,-1
  805e88:	100b883a 	mov	r5,r2
  805e8c:	e13ffd17 	ldw	r4,-12(fp)
  805e90:	08015c00 	call	8015c0 <xQueueGenericSend>
		
		rs = 1;
  805e94:	00800044 	movi	r2,1
  805e98:	e0bffb15 	stw	r2,-20(fp)
		for (i = 0; i < 8; i++)
  805e9c:	e03ffa05 	stb	zero,-24(fp)
  805ea0:	00001106 	br	805ee8 <hd44780_cgram+0xf8>
		{
				xQueueSendToBack(Queue_lcd_data, &udg[i], portMAX_DELAY);
  805ea4:	e0bffa03 	ldbu	r2,-24(fp)
  805ea8:	e0c00217 	ldw	r3,8(fp)
  805eac:	1885883a 	add	r2,r3,r2
  805eb0:	000f883a 	mov	r7,zero
  805eb4:	01bfffc4 	movi	r6,-1
  805eb8:	100b883a 	mov	r5,r2
  805ebc:	e13ffc17 	ldw	r4,-16(fp)
  805ec0:	08015c00 	call	8015c0 <xQueueGenericSend>
				xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
  805ec4:	e0bffb04 	addi	r2,fp,-20
  805ec8:	000f883a 	mov	r7,zero
  805ecc:	01bfffc4 	movi	r6,-1
  805ed0:	100b883a 	mov	r5,r2
  805ed4:	e13ffd17 	ldw	r4,-12(fp)
  805ed8:	08015c00 	call	8015c0 <xQueueGenericSend>
	{
		xQueueSendToBack(Queue_lcd_data, &command, portMAX_DELAY);
		xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
		
		rs = 1;
		for (i = 0; i < 8; i++)
  805edc:	e0bffa03 	ldbu	r2,-24(fp)
  805ee0:	10800044 	addi	r2,r2,1
  805ee4:	e0bffa05 	stb	r2,-24(fp)
  805ee8:	e0bffa03 	ldbu	r2,-24(fp)
  805eec:	10800230 	cmpltui	r2,r2,8
  805ef0:	103fec1e 	bne	r2,zero,805ea4 <__alt_mem_onchip_memory2_0+0xff785ea4>
		{
				xQueueSendToBack(Queue_lcd_data, &udg[i], portMAX_DELAY);
				xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
		}
		xSemaphoreGive( Mutex_write_lcd );
  805ef4:	000f883a 	mov	r7,zero
  805ef8:	000d883a 	mov	r6,zero
  805efc:	000b883a 	mov	r5,zero
  805f00:	e13ffe17 	ldw	r4,-8(fp)
  805f04:	08015c00 	call	8015c0 <xQueueGenericSend>
	}
}
  805f08:	0001883a 	nop
  805f0c:	e037883a 	mov	sp,fp
  805f10:	dfc00117 	ldw	ra,4(sp)
  805f14:	df000017 	ldw	fp,0(sp)
  805f18:	dec00204 	addi	sp,sp,8
  805f1c:	f800283a 	ret

00805f20 <hd44780_put>:
 * Send a single character to the LCD
 *
 * @param chr	Character to send
 */
void hd44780_put(xQueueHandle Queue_lcd_data, xQueueHandle Queue_lcd_rs, xSemaphoreHandle Mutex_write_lcd, const char chr)
{
  805f20:	defff904 	addi	sp,sp,-28
  805f24:	dfc00615 	stw	ra,24(sp)
  805f28:	df000515 	stw	fp,20(sp)
  805f2c:	df000504 	addi	fp,sp,20
  805f30:	e13ffc15 	stw	r4,-16(fp)
  805f34:	e17ffd15 	stw	r5,-12(fp)
  805f38:	e1bffe15 	stw	r6,-8(fp)
  805f3c:	3805883a 	mov	r2,r7
  805f40:	e0bfff05 	stb	r2,-4(fp)
	int rs = 1;
  805f44:	00800044 	movi	r2,1
  805f48:	e0bffb15 	stw	r2,-20(fp)
	if( xSemaphoreTake( Mutex_write_lcd, portMAX_DELAY ) == pdTRUE )
  805f4c:	017fffc4 	movi	r5,-1
  805f50:	e13ffe17 	ldw	r4,-8(fp)
  805f54:	0801aec0 	call	801aec <xQueueSemaphoreTake>
  805f58:	10800058 	cmpnei	r2,r2,1
  805f5c:	1000101e 	bne	r2,zero,805fa0 <hd44780_put+0x80>
	{
		xQueueSendToBack(Queue_lcd_data, &chr, portMAX_DELAY);
  805f60:	e0bfff04 	addi	r2,fp,-4
  805f64:	000f883a 	mov	r7,zero
  805f68:	01bfffc4 	movi	r6,-1
  805f6c:	100b883a 	mov	r5,r2
  805f70:	e13ffc17 	ldw	r4,-16(fp)
  805f74:	08015c00 	call	8015c0 <xQueueGenericSend>
		xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
  805f78:	000f883a 	mov	r7,zero
  805f7c:	01bfffc4 	movi	r6,-1
  805f80:	e17ffb04 	addi	r5,fp,-20
  805f84:	e13ffd17 	ldw	r4,-12(fp)
  805f88:	08015c00 	call	8015c0 <xQueueGenericSend>
		xSemaphoreGive( Mutex_write_lcd );
  805f8c:	000f883a 	mov	r7,zero
  805f90:	000d883a 	mov	r6,zero
  805f94:	000b883a 	mov	r5,zero
  805f98:	e13ffe17 	ldw	r4,-8(fp)
  805f9c:	08015c00 	call	8015c0 <xQueueGenericSend>
	}
}
  805fa0:	0001883a 	nop
  805fa4:	e037883a 	mov	sp,fp
  805fa8:	dfc00117 	ldw	ra,4(sp)
  805fac:	df000017 	ldw	fp,0(sp)
  805fb0:	dec00204 	addi	sp,sp,8
  805fb4:	f800283a 	ret

00805fb8 <hd44780_print>:
 * Send a string to the LCD
 *
 * @param string	String to send
 */
void hd44780_print(xQueueHandle Queue_lcd_data, xQueueHandle Queue_lcd_rs, xSemaphoreHandle Mutex_write_lcd, const char* string)
{
  805fb8:	defff704 	addi	sp,sp,-36
  805fbc:	dfc00815 	stw	ra,32(sp)
  805fc0:	df000715 	stw	fp,28(sp)
  805fc4:	dc000615 	stw	r16,24(sp)
  805fc8:	df000704 	addi	fp,sp,28
  805fcc:	e13ffb15 	stw	r4,-20(fp)
  805fd0:	e17ffc15 	stw	r5,-16(fp)
  805fd4:	e1bffd15 	stw	r6,-12(fp)
  805fd8:	e1fffe15 	stw	r7,-8(fp)
	alt_u8 i = 0;
  805fdc:	e03ff905 	stb	zero,-28(fp)
	int rs = 1;
  805fe0:	00800044 	movi	r2,1
  805fe4:	e0bffa15 	stw	r2,-24(fp)
	
	for(; i < strlen(string); i++)
  805fe8:	00000f06 	br	806028 <hd44780_print+0x70>
	{
		hd44780_put(Queue_lcd_data, Queue_lcd_rs, Mutex_write_lcd, string[i]);
  805fec:	e0bff903 	ldbu	r2,-28(fp)
  805ff0:	e0fffe17 	ldw	r3,-8(fp)
  805ff4:	1885883a 	add	r2,r3,r2
  805ff8:	10800003 	ldbu	r2,0(r2)
  805ffc:	10803fcc 	andi	r2,r2,255
  806000:	1080201c 	xori	r2,r2,128
  806004:	10bfe004 	addi	r2,r2,-128
  806008:	100f883a 	mov	r7,r2
  80600c:	e1bffd17 	ldw	r6,-12(fp)
  806010:	e17ffc17 	ldw	r5,-16(fp)
  806014:	e13ffb17 	ldw	r4,-20(fp)
  806018:	0805f200 	call	805f20 <hd44780_put>
void hd44780_print(xQueueHandle Queue_lcd_data, xQueueHandle Queue_lcd_rs, xSemaphoreHandle Mutex_write_lcd, const char* string)
{
	alt_u8 i = 0;
	int rs = 1;
	
	for(; i < strlen(string); i++)
  80601c:	e0bff903 	ldbu	r2,-28(fp)
  806020:	10800044 	addi	r2,r2,1
  806024:	e0bff905 	stb	r2,-28(fp)
  806028:	e43ff903 	ldbu	r16,-28(fp)
  80602c:	e13ffe17 	ldw	r4,-8(fp)
  806030:	080666c0 	call	80666c <strlen>
  806034:	80bfed36 	bltu	r16,r2,805fec <__alt_mem_onchip_memory2_0+0xff785fec>
	{
		hd44780_put(Queue_lcd_data, Queue_lcd_rs, Mutex_write_lcd, string[i]);
	}
}
  806038:	0001883a 	nop
  80603c:	e6ffff04 	addi	sp,fp,-4
  806040:	dfc00217 	ldw	ra,8(sp)
  806044:	df000117 	ldw	fp,4(sp)
  806048:	dc000017 	ldw	r16,0(sp)
  80604c:	dec00304 	addi	sp,sp,12
  806050:	f800283a 	ret

00806054 <hd44780_printf>:
 *
 * @param fmt	String format
 * @param ...	Variable arguments (see printf())
 */
void hd44780_printf(xQueueHandle Queue_lcd_data, xQueueHandle Queue_lcd_rs, xSemaphoreHandle Mutex_write_lcd, const char *fmt, ...)
{
  806054:	deffee04 	addi	sp,sp,-72
  806058:	dfc01115 	stw	ra,68(sp)
  80605c:	df001015 	stw	fp,64(sp)
  806060:	df001004 	addi	fp,sp,64
  806064:	e13ffc15 	stw	r4,-16(fp)
  806068:	e17ffd15 	stw	r5,-12(fp)
  80606c:	e1bffe15 	stw	r6,-8(fp)
  806070:	e1ffff15 	stw	r7,-4(fp)
	alt_u16 i;
	alt_u16 size;
	alt_u8 character;
	char buffer[32];
	va_list args;
	int rs = 1;
  806074:	00800044 	movi	r2,1
  806078:	e0bff115 	stw	r2,-60(fp)

	va_start(args, fmt);
  80607c:	e0800204 	addi	r2,fp,8
  806080:	e0bffb15 	stw	r2,-20(fp)
	size = vsprintf(buffer, fmt, args);
  806084:	e0fffb17 	ldw	r3,-20(fp)
  806088:	e0bff2c4 	addi	r2,fp,-53
  80608c:	180d883a 	mov	r6,r3
  806090:	e17fff17 	ldw	r5,-4(fp)
  806094:	1009883a 	mov	r4,r2
  806098:	08066e40 	call	8066e4 <vsprintf>
  80609c:	e0bff20d 	sth	r2,-56(fp)
	for (i = 0; i < size; i++)
  8060a0:	e03ff00d 	sth	zero,-64(fp)
  8060a4:	00001106 	br	8060ec <hd44780_printf+0x98>
	{
		character = buffer[i];
  8060a8:	e0bff00b 	ldhu	r2,-64(fp)
  8060ac:	e0fff2c4 	addi	r3,fp,-53
  8060b0:	1885883a 	add	r2,r3,r2
  8060b4:	10800003 	ldbu	r2,0(r2)
  8060b8:	e0bff285 	stb	r2,-54(fp)
		hd44780_put(Queue_lcd_data, Queue_lcd_rs, Mutex_write_lcd, character);
  8060bc:	e0bff283 	ldbu	r2,-54(fp)
  8060c0:	10803fcc 	andi	r2,r2,255
  8060c4:	1080201c 	xori	r2,r2,128
  8060c8:	10bfe004 	addi	r2,r2,-128
  8060cc:	100f883a 	mov	r7,r2
  8060d0:	e1bffe17 	ldw	r6,-8(fp)
  8060d4:	e17ffd17 	ldw	r5,-12(fp)
  8060d8:	e13ffc17 	ldw	r4,-16(fp)
  8060dc:	0805f200 	call	805f20 <hd44780_put>
	va_list args;
	int rs = 1;

	va_start(args, fmt);
	size = vsprintf(buffer, fmt, args);
	for (i = 0; i < size; i++)
  8060e0:	e0bff00b 	ldhu	r2,-64(fp)
  8060e4:	10800044 	addi	r2,r2,1
  8060e8:	e0bff00d 	sth	r2,-64(fp)
  8060ec:	e0fff00b 	ldhu	r3,-64(fp)
  8060f0:	e0bff20b 	ldhu	r2,-56(fp)
  8060f4:	18bfec36 	bltu	r3,r2,8060a8 <__alt_mem_onchip_memory2_0+0xff7860a8>
	{
		character = buffer[i];
		hd44780_put(Queue_lcd_data, Queue_lcd_rs, Mutex_write_lcd, character);
	}
}
  8060f8:	0001883a 	nop
  8060fc:	e037883a 	mov	sp,fp
  806100:	dfc00117 	ldw	ra,4(sp)
  806104:	df000017 	ldw	fp,0(sp)
  806108:	dec00204 	addi	sp,sp,8
  80610c:	f800283a 	ret

00806110 <hd44780_init>:

/**
 * Initialise the LCD
 */
void hd44780_init(xQueueHandle Queue_lcd_data, xQueueHandle Queue_lcd_rs, xSemaphoreHandle Mutex_write_lcd)
{
  806110:	defff904 	addi	sp,sp,-28
  806114:	dfc00615 	stw	ra,24(sp)
  806118:	df000515 	stw	fp,20(sp)
  80611c:	df000504 	addi	fp,sp,20
  806120:	e13ffd15 	stw	r4,-12(fp)
  806124:	e17ffe15 	stw	r5,-8(fp)
  806128:	e1bfff15 	stw	r6,-4(fp)
	int data, rs = 0;
  80612c:	e03ffc15 	stw	zero,-16(fp)
	alt_putstr("initialisation start\n");
  806130:	01002074 	movhi	r4,129
  806134:	21237504 	addi	r4,r4,-29228
  806138:	08071d00 	call	8071d0 <alt_putstr>
	//function set
	if( xSemaphoreTake( Mutex_write_lcd, portMAX_DELAY ) == pdTRUE )
  80613c:	017fffc4 	movi	r5,-1
  806140:	e13fff17 	ldw	r4,-4(fp)
  806144:	0801aec0 	call	801aec <xQueueSemaphoreTake>
  806148:	10800058 	cmpnei	r2,r2,1
  80614c:	1000421e 	bne	r2,zero,806258 <hd44780_init+0x148>
	{
		data = 0x3C;
  806150:	00800f04 	movi	r2,60
  806154:	e0bffb15 	stw	r2,-20(fp)
		xQueueSendToBack(Queue_lcd_data, &data, portMAX_DELAY);
  806158:	000f883a 	mov	r7,zero
  80615c:	01bfffc4 	movi	r6,-1
  806160:	e17ffb04 	addi	r5,fp,-20
  806164:	e13ffd17 	ldw	r4,-12(fp)
  806168:	08015c00 	call	8015c0 <xQueueGenericSend>
		xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
  80616c:	e0bffc04 	addi	r2,fp,-16
  806170:	000f883a 	mov	r7,zero
  806174:	01bfffc4 	movi	r6,-1
  806178:	100b883a 	mov	r5,r2
  80617c:	e13ffe17 	ldw	r4,-8(fp)
  806180:	08015c00 	call	8015c0 <xQueueGenericSend>
		alt_putstr("initialisation function\n");
  806184:	01002074 	movhi	r4,129
  806188:	21237b04 	addi	r4,r4,-29204
  80618c:	08071d00 	call	8071d0 <alt_putstr>
		//display and cursor control
		data = 0x0C;
  806190:	00800304 	movi	r2,12
  806194:	e0bffb15 	stw	r2,-20(fp)
		xQueueSendToBack(Queue_lcd_data, &data, portMAX_DELAY);
  806198:	000f883a 	mov	r7,zero
  80619c:	01bfffc4 	movi	r6,-1
  8061a0:	e17ffb04 	addi	r5,fp,-20
  8061a4:	e13ffd17 	ldw	r4,-12(fp)
  8061a8:	08015c00 	call	8015c0 <xQueueGenericSend>
		xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
  8061ac:	e0bffc04 	addi	r2,fp,-16
  8061b0:	000f883a 	mov	r7,zero
  8061b4:	01bfffc4 	movi	r6,-1
  8061b8:	100b883a 	mov	r5,r2
  8061bc:	e13ffe17 	ldw	r4,-8(fp)
  8061c0:	08015c00 	call	8015c0 <xQueueGenericSend>
		alt_putstr("initialisation display\n");
  8061c4:	01002074 	movhi	r4,129
  8061c8:	21238204 	addi	r4,r4,-29176
  8061cc:	08071d00 	call	8071d0 <alt_putstr>
		//display clear
		data = 0x01;
  8061d0:	00800044 	movi	r2,1
  8061d4:	e0bffb15 	stw	r2,-20(fp)
		xQueueSendToBack(Queue_lcd_data, &data, portMAX_DELAY);
  8061d8:	000f883a 	mov	r7,zero
  8061dc:	01bfffc4 	movi	r6,-1
  8061e0:	e17ffb04 	addi	r5,fp,-20
  8061e4:	e13ffd17 	ldw	r4,-12(fp)
  8061e8:	08015c00 	call	8015c0 <xQueueGenericSend>
		xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
  8061ec:	e0bffc04 	addi	r2,fp,-16
  8061f0:	000f883a 	mov	r7,zero
  8061f4:	01bfffc4 	movi	r6,-1
  8061f8:	100b883a 	mov	r5,r2
  8061fc:	e13ffe17 	ldw	r4,-8(fp)
  806200:	08015c00 	call	8015c0 <xQueueGenericSend>
		alt_putstr("clear display\n");
  806204:	01002074 	movhi	r4,129
  806208:	21238804 	addi	r4,r4,-29152
  80620c:	08071d00 	call	8071d0 <alt_putstr>
		//entry mode set
		data = 0x07;
  806210:	008001c4 	movi	r2,7
  806214:	e0bffb15 	stw	r2,-20(fp)
		xQueueSendToBack(Queue_lcd_data, &data, portMAX_DELAY);
  806218:	000f883a 	mov	r7,zero
  80621c:	01bfffc4 	movi	r6,-1
  806220:	e17ffb04 	addi	r5,fp,-20
  806224:	e13ffd17 	ldw	r4,-12(fp)
  806228:	08015c00 	call	8015c0 <xQueueGenericSend>
		xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
  80622c:	e0bffc04 	addi	r2,fp,-16
  806230:	000f883a 	mov	r7,zero
  806234:	01bfffc4 	movi	r6,-1
  806238:	100b883a 	mov	r5,r2
  80623c:	e13ffe17 	ldw	r4,-8(fp)
  806240:	08015c00 	call	8015c0 <xQueueGenericSend>
		xSemaphoreGive( Mutex_write_lcd );
  806244:	000f883a 	mov	r7,zero
  806248:	000d883a 	mov	r6,zero
  80624c:	000b883a 	mov	r5,zero
  806250:	e13fff17 	ldw	r4,-4(fp)
  806254:	08015c00 	call	8015c0 <xQueueGenericSend>
	}
	alt_putstr("initialisation finished\n");
  806258:	01002074 	movhi	r4,129
  80625c:	21238c04 	addi	r4,r4,-29136
  806260:	08071d00 	call	8071d0 <alt_putstr>
	/* hd44780_clear();
	hd44780_home(); */
}
  806264:	0001883a 	nop
  806268:	e037883a 	mov	sp,fp
  80626c:	dfc00117 	ldw	ra,4(sp)
  806270:	df000017 	ldw	fp,0(sp)
  806274:	dec00204 	addi	sp,sp,8
  806278:	f800283a 	ret

0080627c <sayHello>:

xQueueHandle Queue_lcd_data, Queue_lcd_rs;
xSemaphoreHandle Mutex_write_lcd;
int n = 0;

void sayHello( void *p){
  80627c:	defff304 	addi	sp,sp,-52
  806280:	dfc00c15 	stw	ra,48(sp)
  806284:	df000b15 	stw	fp,44(sp)
  806288:	df000b04 	addi	fp,sp,44
  80628c:	e13fff15 	stw	r4,-4(fp)
	char data[] = "%s, %s, %d, ", data2[] = "asd", data3[] = "sdf";
  806290:	00880b34 	movhi	r2,8236
  806294:	109cc944 	addi	r2,r2,29477
  806298:	e0bff915 	stw	r2,-28(fp)
  80629c:	00880b34 	movhi	r2,8236
  8062a0:	109cc944 	addi	r2,r2,29477
  8062a4:	e0bffa15 	stw	r2,-24(fp)
  8062a8:	00880b34 	movhi	r2,8236
  8062ac:	10990944 	addi	r2,r2,25637
  8062b0:	e0bffb15 	stw	r2,-20(fp)
  8062b4:	e03ffc05 	stb	zero,-16(fp)
  8062b8:	00801844 	movi	r2,97
  8062bc:	e0bffc45 	stb	r2,-15(fp)
  8062c0:	00801cc4 	movi	r2,115
  8062c4:	e0bffc85 	stb	r2,-14(fp)
  8062c8:	00801904 	movi	r2,100
  8062cc:	e0bffcc5 	stb	r2,-13(fp)
  8062d0:	e03ffd05 	stb	zero,-12(fp)
  8062d4:	00801cc4 	movi	r2,115
  8062d8:	e0bffd45 	stb	r2,-11(fp)
  8062dc:	00801904 	movi	r2,100
  8062e0:	e0bffd85 	stb	r2,-10(fp)
  8062e4:	00801984 	movi	r2,102
  8062e8:	e0bffdc5 	stb	r2,-9(fp)
  8062ec:	e03ffe05 	stb	zero,-8(fp)
	int data4 = 20;
  8062f0:	00800504 	movi	r2,20
  8062f4:	e0bff815 	stw	r2,-32(fp)
while(1){
	printf("Hello, world!\n");
  8062f8:	01002074 	movhi	r4,129
  8062fc:	21239304 	addi	r4,r4,-29108
  806300:	08066580 	call	806658 <puts>
	hd44780_printf(Queue_lcd_data, Queue_lcd_rs, Mutex_write_lcd, data, data2, data3, data4);
  806304:	00802074 	movhi	r2,129
  806308:	10ad5f04 	addi	r2,r2,-19076
  80630c:	10c00017 	ldw	r3,0(r2)
  806310:	00802074 	movhi	r2,129
  806314:	10ad5e04 	addi	r2,r2,-19080
  806318:	11000017 	ldw	r4,0(r2)
  80631c:	00802074 	movhi	r2,129
  806320:	10ad6004 	addi	r2,r2,-19072
  806324:	11400017 	ldw	r5,0(r2)
  806328:	e1bff904 	addi	r6,fp,-28
  80632c:	e0bff817 	ldw	r2,-32(fp)
  806330:	d8800215 	stw	r2,8(sp)
  806334:	e0bffd44 	addi	r2,fp,-11
  806338:	d8800115 	stw	r2,4(sp)
  80633c:	e0bffc44 	addi	r2,fp,-15
  806340:	d8800015 	stw	r2,0(sp)
  806344:	300f883a 	mov	r7,r6
  806348:	280d883a 	mov	r6,r5
  80634c:	200b883a 	mov	r5,r4
  806350:	1809883a 	mov	r4,r3
  806354:	08060540 	call	806054 <hd44780_printf>

	vTaskDelay(1000*10);
  806358:	0109c404 	movi	r4,10000
  80635c:	0803a040 	call	803a04 <vTaskDelay>
 }
  806360:	003fe506 	br	8062f8 <__alt_mem_onchip_memory2_0+0xff7862f8>

00806364 <sayInBitween>:
}


void sayInBitween (void *p){
  806364:	defffd04 	addi	sp,sp,-12
  806368:	dfc00215 	stw	ra,8(sp)
  80636c:	df000115 	stw	fp,4(sp)
  806370:	df000104 	addi	fp,sp,4
  806374:	e13fff15 	stw	r4,-4(fp)
while(1){
 printf("In between\n");
  806378:	01002074 	movhi	r4,129
  80637c:	21239704 	addi	r4,r4,-29092
  806380:	08066580 	call	806658 <puts>
 IOWR_ALTERA_AVALON_PIO_DATA(LED_BASE, 1 << n);
  806384:	d0a4e117 	ldw	r2,-27772(gp)
  806388:	00c00044 	movi	r3,1
  80638c:	1886983a 	sll	r3,r3,r2
  806390:	00804434 	movhi	r2,272
  806394:	10842404 	addi	r2,r2,4240
  806398:	10c00035 	stwio	r3,0(r2)
 n++;
  80639c:	d0a4e117 	ldw	r2,-27772(gp)
  8063a0:	10800044 	addi	r2,r2,1
  8063a4:	d0a4e115 	stw	r2,-27772(gp)
 if (n == 10) n = 0;
  8063a8:	d0a4e117 	ldw	r2,-27772(gp)
  8063ac:	10800298 	cmpnei	r2,r2,10
  8063b0:	1000011e 	bne	r2,zero,8063b8 <sayInBitween+0x54>
  8063b4:	d024e115 	stw	zero,-27772(gp)
 vTaskDelay(300*10);
  8063b8:	0102ee04 	movi	r4,3000
  8063bc:	0803a040 	call	803a04 <vTaskDelay>
 }
  8063c0:	003fed06 	br	806378 <__alt_mem_onchip_memory2_0+0xff786378>

008063c4 <task_lcd_write>:
}
void task_lcd_write(void *p)
{
  8063c4:	defffb04 	addi	sp,sp,-20
  8063c8:	dfc00415 	stw	ra,16(sp)
  8063cc:	df000315 	stw	fp,12(sp)
  8063d0:	df000304 	addi	fp,sp,12
  8063d4:	e13fff15 	stw	r4,-4(fp)
	hd44780_init(Queue_lcd_data, Queue_lcd_rs, Mutex_write_lcd);
  8063d8:	00802074 	movhi	r2,129
  8063dc:	10ad5f04 	addi	r2,r2,-19076
  8063e0:	10c00017 	ldw	r3,0(r2)
  8063e4:	00802074 	movhi	r2,129
  8063e8:	10ad5e04 	addi	r2,r2,-19080
  8063ec:	11000017 	ldw	r4,0(r2)
  8063f0:	00802074 	movhi	r2,129
  8063f4:	10ad6004 	addi	r2,r2,-19072
  8063f8:	10800017 	ldw	r2,0(r2)
  8063fc:	100d883a 	mov	r6,r2
  806400:	200b883a 	mov	r5,r4
  806404:	1809883a 	mov	r4,r3
  806408:	08061100 	call	806110 <hd44780_init>
	int data, rs;
	while(1)
	{
		xQueueReceive(Queue_lcd_data, &data, portMAX_DELAY);
  80640c:	00802074 	movhi	r2,129
  806410:	10ad5f04 	addi	r2,r2,-19076
  806414:	10800017 	ldw	r2,0(r2)
  806418:	01bfffc4 	movi	r6,-1
  80641c:	e17ffd04 	addi	r5,fp,-12
  806420:	1009883a 	mov	r4,r2
  806424:	08019440 	call	801944 <xQueueReceive>
		xQueueReceive(Queue_lcd_rs, &rs, portMAX_DELAY);
  806428:	00802074 	movhi	r2,129
  80642c:	10ad5e04 	addi	r2,r2,-19080
  806430:	10800017 	ldw	r2,0(r2)
  806434:	e0fffe04 	addi	r3,fp,-8
  806438:	01bfffc4 	movi	r6,-1
  80643c:	180b883a 	mov	r5,r3
  806440:	1009883a 	mov	r4,r2
  806444:	08019440 	call	801944 <xQueueReceive>
		write(data, rs);
  806448:	e0bffd17 	ldw	r2,-12(fp)
  80644c:	10803fcc 	andi	r2,r2,255
  806450:	e0fffe17 	ldw	r3,-8(fp)
  806454:	180b883a 	mov	r5,r3
  806458:	1009883a 	mov	r4,r2
  80645c:	0805a000 	call	805a00 <write>
		while(!read_busy());
  806460:	0001883a 	nop
  806464:	0805a740 	call	805a74 <read_busy>
  806468:	103ffe26 	beq	r2,zero,806464 <__alt_mem_onchip_memory2_0+0xff786464>
	}
  80646c:	003fe706 	br	80640c <__alt_mem_onchip_memory2_0+0xff78640c>

00806470 <main>:
}
int main()
{
  806470:	defffc04 	addi	sp,sp,-16
  806474:	dfc00315 	stw	ra,12(sp)
  806478:	df000215 	stw	fp,8(sp)
  80647c:	df000204 	addi	fp,sp,8
	alt_putstr("Hello from Nios II!\n");
  806480:	01002074 	movhi	r4,129
  806484:	21239a04 	addi	r4,r4,-29080
  806488:	08071d00 	call	8071d0 <alt_putstr>
	Queue_lcd_data = xQueueCreate(100, 1);
  80648c:	000d883a 	mov	r6,zero
  806490:	01400044 	movi	r5,1
  806494:	01001904 	movi	r4,100
  806498:	08012640 	call	801264 <xQueueGenericCreate>
  80649c:	1007883a 	mov	r3,r2
  8064a0:	00802074 	movhi	r2,129
  8064a4:	10ad5f04 	addi	r2,r2,-19076
  8064a8:	10c00015 	stw	r3,0(r2)
	Queue_lcd_rs = xQueueCreate(100, 1);
  8064ac:	000d883a 	mov	r6,zero
  8064b0:	01400044 	movi	r5,1
  8064b4:	01001904 	movi	r4,100
  8064b8:	08012640 	call	801264 <xQueueGenericCreate>
  8064bc:	1007883a 	mov	r3,r2
  8064c0:	00802074 	movhi	r2,129
  8064c4:	10ad5e04 	addi	r2,r2,-19080
  8064c8:	10c00015 	stw	r3,0(r2)
	Mutex_write_lcd = xSemaphoreCreateMutex();
  8064cc:	01000044 	movi	r4,1
  8064d0:	08013e00 	call	8013e0 <xQueueCreateMutex>
  8064d4:	1007883a 	mov	r3,r2
  8064d8:	00802074 	movhi	r2,129
  8064dc:	10ad6004 	addi	r2,r2,-19072
  8064e0:	10c00015 	stw	r3,0(r2)
	xTaskCreate(task_lcd_write, "task_lcd_write", configMINIMAL_STACK_SIZE, NULL, 2, NULL);
  8064e4:	d8000115 	stw	zero,4(sp)
  8064e8:	00800084 	movi	r2,2
  8064ec:	d8800015 	stw	r2,0(sp)
  8064f0:	000f883a 	mov	r7,zero
  8064f4:	01810004 	movi	r6,1024
  8064f8:	01402074 	movhi	r5,129
  8064fc:	2963a004 	addi	r5,r5,-29056
  806500:	01002034 	movhi	r4,128
  806504:	2118f104 	addi	r4,r4,25540
  806508:	08034640 	call	803464 <xTaskCreate>
	xTaskCreate(sayHello, "sayHello", configMINIMAL_STACK_SIZE, NULL, 2, NULL);
  80650c:	d8000115 	stw	zero,4(sp)
  806510:	00800084 	movi	r2,2
  806514:	d8800015 	stw	r2,0(sp)
  806518:	000f883a 	mov	r7,zero
  80651c:	01810004 	movi	r6,1024
  806520:	01402074 	movhi	r5,129
  806524:	2963a404 	addi	r5,r5,-29040
  806528:	01002034 	movhi	r4,128
  80652c:	21189f04 	addi	r4,r4,25212
  806530:	08034640 	call	803464 <xTaskCreate>
	printf("sayHello inst\n");
  806534:	01002074 	movhi	r4,129
  806538:	2123a704 	addi	r4,r4,-29028
  80653c:	08066580 	call	806658 <puts>
	xTaskCreate(sayInBitween, "sayInBitween",configMINIMAL_STACK_SIZE,NULL,2,NULL);
  806540:	d8000115 	stw	zero,4(sp)
  806544:	00800084 	movi	r2,2
  806548:	d8800015 	stw	r2,0(sp)
  80654c:	000f883a 	mov	r7,zero
  806550:	01810004 	movi	r6,1024
  806554:	01402074 	movhi	r5,129
  806558:	2963ab04 	addi	r5,r5,-29012
  80655c:	01002034 	movhi	r4,128
  806560:	2118d904 	addi	r4,r4,25444
  806564:	08034640 	call	803464 <xTaskCreate>
	printf("sayInBitween inst\n");
  806568:	01002074 	movhi	r4,129
  80656c:	2123af04 	addi	r4,r4,-28996
  806570:	08066580 	call	806658 <puts>
	vTaskStartScheduler();
  806574:	0803fbc0 	call	803fbc <vTaskStartScheduler>
	return 0;
  806578:	0005883a 	mov	r2,zero
}
  80657c:	e037883a 	mov	sp,fp
  806580:	dfc00117 	ldw	ra,4(sp)
  806584:	df000017 	ldw	fp,0(sp)
  806588:	dec00204 	addi	sp,sp,8
  80658c:	f800283a 	ret

00806590 <memcpy>:
  806590:	2005883a 	mov	r2,r4
  806594:	2007883a 	mov	r3,r4
  806598:	218d883a 	add	r6,r4,r6
  80659c:	19800526 	beq	r3,r6,8065b4 <memcpy+0x24>
  8065a0:	29000003 	ldbu	r4,0(r5)
  8065a4:	18c00044 	addi	r3,r3,1
  8065a8:	29400044 	addi	r5,r5,1
  8065ac:	193fffc5 	stb	r4,-1(r3)
  8065b0:	003ffa06 	br	80659c <__alt_mem_onchip_memory2_0+0xff78659c>
  8065b4:	f800283a 	ret

008065b8 <memset>:
  8065b8:	2005883a 	mov	r2,r4
  8065bc:	2007883a 	mov	r3,r4
  8065c0:	218d883a 	add	r6,r4,r6
  8065c4:	19800326 	beq	r3,r6,8065d4 <memset+0x1c>
  8065c8:	19400005 	stb	r5,0(r3)
  8065cc:	18c00044 	addi	r3,r3,1
  8065d0:	003ffc06 	br	8065c4 <__alt_mem_onchip_memory2_0+0xff7865c4>
  8065d4:	f800283a 	ret

008065d8 <_puts_r>:
  8065d8:	defffd04 	addi	sp,sp,-12
  8065dc:	dc000015 	stw	r16,0(sp)
  8065e0:	2021883a 	mov	r16,r4
  8065e4:	2809883a 	mov	r4,r5
  8065e8:	dfc00215 	stw	ra,8(sp)
  8065ec:	dc400115 	stw	r17,4(sp)
  8065f0:	2823883a 	mov	r17,r5
  8065f4:	080666c0 	call	80666c <strlen>
  8065f8:	81400217 	ldw	r5,8(r16)
  8065fc:	01002034 	movhi	r4,128
  806600:	2119c004 	addi	r4,r4,26368
  806604:	29000115 	stw	r4,4(r5)
  806608:	100f883a 	mov	r7,r2
  80660c:	880d883a 	mov	r6,r17
  806610:	8009883a 	mov	r4,r16
  806614:	08067000 	call	806700 <__sfvwrite_small_dev>
  806618:	00ffffc4 	movi	r3,-1
  80661c:	10c00926 	beq	r2,r3,806644 <_puts_r+0x6c>
  806620:	81400217 	ldw	r5,8(r16)
  806624:	01802074 	movhi	r6,129
  806628:	01c00044 	movi	r7,1
  80662c:	28800117 	ldw	r2,4(r5)
  806630:	31a3b404 	addi	r6,r6,-28976
  806634:	8009883a 	mov	r4,r16
  806638:	103ee83a 	callr	r2
  80663c:	10bfffe0 	cmpeqi	r2,r2,-1
  806640:	0085c83a 	sub	r2,zero,r2
  806644:	dfc00217 	ldw	ra,8(sp)
  806648:	dc400117 	ldw	r17,4(sp)
  80664c:	dc000017 	ldw	r16,0(sp)
  806650:	dec00304 	addi	sp,sp,12
  806654:	f800283a 	ret

00806658 <puts>:
  806658:	00802074 	movhi	r2,129
  80665c:	10a87d04 	addi	r2,r2,-24076
  806660:	200b883a 	mov	r5,r4
  806664:	11000017 	ldw	r4,0(r2)
  806668:	08065d81 	jmpi	8065d8 <_puts_r>

0080666c <strlen>:
  80666c:	2005883a 	mov	r2,r4
  806670:	10c00007 	ldb	r3,0(r2)
  806674:	18000226 	beq	r3,zero,806680 <strlen+0x14>
  806678:	10800044 	addi	r2,r2,1
  80667c:	003ffc06 	br	806670 <__alt_mem_onchip_memory2_0+0xff786670>
  806680:	1105c83a 	sub	r2,r2,r4
  806684:	f800283a 	ret

00806688 <_vsprintf_r>:
  806688:	defff804 	addi	sp,sp,-32
  80668c:	00808204 	movi	r2,520
  806690:	d880000d 	sth	r2,0(sp)
  806694:	00a00034 	movhi	r2,32768
  806698:	10bfffc4 	addi	r2,r2,-1
  80669c:	d8800515 	stw	r2,20(sp)
  8066a0:	d8800315 	stw	r2,12(sp)
  8066a4:	00bfffc4 	movi	r2,-1
  8066a8:	d880008d 	sth	r2,2(sp)
  8066ac:	00802034 	movhi	r2,128
  8066b0:	d9400415 	stw	r5,16(sp)
  8066b4:	d9400215 	stw	r5,8(sp)
  8066b8:	1099ee04 	addi	r2,r2,26552
  8066bc:	d80b883a 	mov	r5,sp
  8066c0:	dfc00715 	stw	ra,28(sp)
  8066c4:	d8800115 	stw	r2,4(sp)
  8066c8:	d8000615 	stw	zero,24(sp)
  8066cc:	080692c0 	call	80692c <___svfprintf_internal_r>
  8066d0:	d8c00417 	ldw	r3,16(sp)
  8066d4:	18000005 	stb	zero,0(r3)
  8066d8:	dfc00717 	ldw	ra,28(sp)
  8066dc:	dec00804 	addi	sp,sp,32
  8066e0:	f800283a 	ret

008066e4 <vsprintf>:
  8066e4:	00802074 	movhi	r2,129
  8066e8:	10a87d04 	addi	r2,r2,-24076
  8066ec:	300f883a 	mov	r7,r6
  8066f0:	280d883a 	mov	r6,r5
  8066f4:	200b883a 	mov	r5,r4
  8066f8:	11000017 	ldw	r4,0(r2)
  8066fc:	08066881 	jmpi	806688 <_vsprintf_r>

00806700 <__sfvwrite_small_dev>:
  806700:	2880000b 	ldhu	r2,0(r5)
  806704:	1080020c 	andi	r2,r2,8
  806708:	10002126 	beq	r2,zero,806790 <__sfvwrite_small_dev+0x90>
  80670c:	2880008f 	ldh	r2,2(r5)
  806710:	defffa04 	addi	sp,sp,-24
  806714:	dc000015 	stw	r16,0(sp)
  806718:	dfc00515 	stw	ra,20(sp)
  80671c:	dd000415 	stw	r20,16(sp)
  806720:	dcc00315 	stw	r19,12(sp)
  806724:	dc800215 	stw	r18,8(sp)
  806728:	dc400115 	stw	r17,4(sp)
  80672c:	2821883a 	mov	r16,r5
  806730:	10001216 	blt	r2,zero,80677c <__sfvwrite_small_dev+0x7c>
  806734:	2027883a 	mov	r19,r4
  806738:	3025883a 	mov	r18,r6
  80673c:	3823883a 	mov	r17,r7
  806740:	05010004 	movi	r20,1024
  806744:	04400b0e 	bge	zero,r17,806774 <__sfvwrite_small_dev+0x74>
  806748:	880f883a 	mov	r7,r17
  80674c:	a440010e 	bge	r20,r17,806754 <__sfvwrite_small_dev+0x54>
  806750:	01c10004 	movi	r7,1024
  806754:	8140008f 	ldh	r5,2(r16)
  806758:	900d883a 	mov	r6,r18
  80675c:	9809883a 	mov	r4,r19
  806760:	0806e6c0 	call	806e6c <_write_r>
  806764:	0080050e 	bge	zero,r2,80677c <__sfvwrite_small_dev+0x7c>
  806768:	88a3c83a 	sub	r17,r17,r2
  80676c:	90a5883a 	add	r18,r18,r2
  806770:	003ff406 	br	806744 <__alt_mem_onchip_memory2_0+0xff786744>
  806774:	0005883a 	mov	r2,zero
  806778:	00000706 	br	806798 <__sfvwrite_small_dev+0x98>
  80677c:	8080000b 	ldhu	r2,0(r16)
  806780:	10801014 	ori	r2,r2,64
  806784:	8080000d 	sth	r2,0(r16)
  806788:	00bfffc4 	movi	r2,-1
  80678c:	00000206 	br	806798 <__sfvwrite_small_dev+0x98>
  806790:	00bfffc4 	movi	r2,-1
  806794:	f800283a 	ret
  806798:	dfc00517 	ldw	ra,20(sp)
  80679c:	dd000417 	ldw	r20,16(sp)
  8067a0:	dcc00317 	ldw	r19,12(sp)
  8067a4:	dc800217 	ldw	r18,8(sp)
  8067a8:	dc400117 	ldw	r17,4(sp)
  8067ac:	dc000017 	ldw	r16,0(sp)
  8067b0:	dec00604 	addi	sp,sp,24
  8067b4:	f800283a 	ret

008067b8 <__sfvwrite_small_str>:
  8067b8:	2880000b 	ldhu	r2,0(r5)
  8067bc:	10c0020c 	andi	r3,r2,8
  8067c0:	18002026 	beq	r3,zero,806844 <__sfvwrite_small_str+0x8c>
  8067c4:	28c0008f 	ldh	r3,2(r5)
  8067c8:	defffd04 	addi	sp,sp,-12
  8067cc:	dc000015 	stw	r16,0(sp)
  8067d0:	dfc00215 	stw	ra,8(sp)
  8067d4:	dc400115 	stw	r17,4(sp)
  8067d8:	2821883a 	mov	r16,r5
  8067dc:	1800150e 	bge	r3,zero,806834 <__sfvwrite_small_str+0x7c>
  8067e0:	10c0800c 	andi	r3,r2,512
  8067e4:	18001326 	beq	r3,zero,806834 <__sfvwrite_small_str+0x7c>
  8067e8:	2c400517 	ldw	r17,20(r5)
  8067ec:	89c0030e 	bge	r17,r7,8067fc <__sfvwrite_small_str+0x44>
  8067f0:	10c0200c 	andi	r3,r2,128
  8067f4:	18000326 	beq	r3,zero,806804 <__sfvwrite_small_str+0x4c>
  8067f8:	00000e06 	br	806834 <__sfvwrite_small_str+0x7c>
  8067fc:	3c40010e 	bge	r7,r17,806804 <__sfvwrite_small_str+0x4c>
  806800:	3823883a 	mov	r17,r7
  806804:	81000417 	ldw	r4,16(r16)
  806808:	300b883a 	mov	r5,r6
  80680c:	880d883a 	mov	r6,r17
  806810:	08068600 	call	806860 <memmove>
  806814:	80800517 	ldw	r2,20(r16)
  806818:	1445c83a 	sub	r2,r2,r17
  80681c:	80800515 	stw	r2,20(r16)
  806820:	80800417 	ldw	r2,16(r16)
  806824:	1463883a 	add	r17,r2,r17
  806828:	84400415 	stw	r17,16(r16)
  80682c:	0005883a 	mov	r2,zero
  806830:	00000606 	br	80684c <__sfvwrite_small_str+0x94>
  806834:	10801014 	ori	r2,r2,64
  806838:	8080000d 	sth	r2,0(r16)
  80683c:	00bfffc4 	movi	r2,-1
  806840:	00000206 	br	80684c <__sfvwrite_small_str+0x94>
  806844:	00bfffc4 	movi	r2,-1
  806848:	f800283a 	ret
  80684c:	dfc00217 	ldw	ra,8(sp)
  806850:	dc400117 	ldw	r17,4(sp)
  806854:	dc000017 	ldw	r16,0(sp)
  806858:	dec00304 	addi	sp,sp,12
  80685c:	f800283a 	ret

00806860 <memmove>:
  806860:	2005883a 	mov	r2,r4
  806864:	218f883a 	add	r7,r4,r6
  806868:	29000236 	bltu	r5,r4,806874 <memmove+0x14>
  80686c:	1007883a 	mov	r3,r2
  806870:	00000c06 	br	8068a4 <memmove+0x44>
  806874:	2987883a 	add	r3,r5,r6
  806878:	20fffc2e 	bgeu	r4,r3,80686c <__alt_mem_onchip_memory2_0+0xff78686c>
  80687c:	380b883a 	mov	r5,r7
  806880:	30cdc83a 	sub	r6,r6,r3
  806884:	1989883a 	add	r4,r3,r6
  806888:	20000526 	beq	r4,zero,8068a0 <memmove+0x40>
  80688c:	18ffffc4 	addi	r3,r3,-1
  806890:	19000003 	ldbu	r4,0(r3)
  806894:	297fffc4 	addi	r5,r5,-1
  806898:	29000005 	stb	r4,0(r5)
  80689c:	003ff906 	br	806884 <__alt_mem_onchip_memory2_0+0xff786884>
  8068a0:	f800283a 	ret
  8068a4:	19c00526 	beq	r3,r7,8068bc <memmove+0x5c>
  8068a8:	29000003 	ldbu	r4,0(r5)
  8068ac:	18c00044 	addi	r3,r3,1
  8068b0:	29400044 	addi	r5,r5,1
  8068b4:	193fffc5 	stb	r4,-1(r3)
  8068b8:	003ffa06 	br	8068a4 <__alt_mem_onchip_memory2_0+0xff7868a4>
  8068bc:	f800283a 	ret

008068c0 <print_repeat>:
  8068c0:	defffb04 	addi	sp,sp,-20
  8068c4:	dc800315 	stw	r18,12(sp)
  8068c8:	dc400215 	stw	r17,8(sp)
  8068cc:	dc000115 	stw	r16,4(sp)
  8068d0:	dfc00415 	stw	ra,16(sp)
  8068d4:	2025883a 	mov	r18,r4
  8068d8:	2823883a 	mov	r17,r5
  8068dc:	d9800005 	stb	r6,0(sp)
  8068e0:	3821883a 	mov	r16,r7
  8068e4:	04000a0e 	bge	zero,r16,806910 <print_repeat+0x50>
  8068e8:	88800117 	ldw	r2,4(r17)
  8068ec:	01c00044 	movi	r7,1
  8068f0:	d80d883a 	mov	r6,sp
  8068f4:	880b883a 	mov	r5,r17
  8068f8:	9009883a 	mov	r4,r18
  8068fc:	103ee83a 	callr	r2
  806900:	843fffc4 	addi	r16,r16,-1
  806904:	103ff726 	beq	r2,zero,8068e4 <__alt_mem_onchip_memory2_0+0xff7868e4>
  806908:	00bfffc4 	movi	r2,-1
  80690c:	00000106 	br	806914 <print_repeat+0x54>
  806910:	0005883a 	mov	r2,zero
  806914:	dfc00417 	ldw	ra,16(sp)
  806918:	dc800317 	ldw	r18,12(sp)
  80691c:	dc400217 	ldw	r17,8(sp)
  806920:	dc000117 	ldw	r16,4(sp)
  806924:	dec00504 	addi	sp,sp,20
  806928:	f800283a 	ret

0080692c <___svfprintf_internal_r>:
  80692c:	deffe504 	addi	sp,sp,-108
  806930:	d8c00804 	addi	r3,sp,32
  806934:	df001915 	stw	fp,100(sp)
  806938:	ddc01815 	stw	r23,96(sp)
  80693c:	dd801715 	stw	r22,92(sp)
  806940:	dd401615 	stw	r21,88(sp)
  806944:	dd001515 	stw	r20,84(sp)
  806948:	dcc01415 	stw	r19,80(sp)
  80694c:	dc801315 	stw	r18,76(sp)
  806950:	dc401215 	stw	r17,72(sp)
  806954:	dc001115 	stw	r16,68(sp)
  806958:	dfc01a15 	stw	ra,104(sp)
  80695c:	2027883a 	mov	r19,r4
  806960:	2839883a 	mov	fp,r5
  806964:	382d883a 	mov	r22,r7
  806968:	d9800f15 	stw	r6,60(sp)
  80696c:	0021883a 	mov	r16,zero
  806970:	d8000e15 	stw	zero,56(sp)
  806974:	002f883a 	mov	r23,zero
  806978:	002b883a 	mov	r21,zero
  80697c:	0025883a 	mov	r18,zero
  806980:	0023883a 	mov	r17,zero
  806984:	d8000c15 	stw	zero,48(sp)
  806988:	d8000b15 	stw	zero,44(sp)
  80698c:	0029883a 	mov	r20,zero
  806990:	d8c00915 	stw	r3,36(sp)
  806994:	d8c00f17 	ldw	r3,60(sp)
  806998:	19000003 	ldbu	r4,0(r3)
  80699c:	20803fcc 	andi	r2,r4,255
  8069a0:	1080201c 	xori	r2,r2,128
  8069a4:	10bfe004 	addi	r2,r2,-128
  8069a8:	10011c26 	beq	r2,zero,806e1c <___svfprintf_internal_r+0x4f0>
  8069ac:	00c00044 	movi	r3,1
  8069b0:	a0c01426 	beq	r20,r3,806a04 <___svfprintf_internal_r+0xd8>
  8069b4:	1d000216 	blt	r3,r20,8069c0 <___svfprintf_internal_r+0x94>
  8069b8:	a0000626 	beq	r20,zero,8069d4 <___svfprintf_internal_r+0xa8>
  8069bc:	00011306 	br	806e0c <___svfprintf_internal_r+0x4e0>
  8069c0:	01400084 	movi	r5,2
  8069c4:	a1401d26 	beq	r20,r5,806a3c <___svfprintf_internal_r+0x110>
  8069c8:	014000c4 	movi	r5,3
  8069cc:	a1402926 	beq	r20,r5,806a74 <___svfprintf_internal_r+0x148>
  8069d0:	00010e06 	br	806e0c <___svfprintf_internal_r+0x4e0>
  8069d4:	01400944 	movi	r5,37
  8069d8:	1140fb26 	beq	r2,r5,806dc8 <___svfprintf_internal_r+0x49c>
  8069dc:	e0800117 	ldw	r2,4(fp)
  8069e0:	d9000005 	stb	r4,0(sp)
  8069e4:	01c00044 	movi	r7,1
  8069e8:	d80d883a 	mov	r6,sp
  8069ec:	e00b883a 	mov	r5,fp
  8069f0:	9809883a 	mov	r4,r19
  8069f4:	103ee83a 	callr	r2
  8069f8:	1000d61e 	bne	r2,zero,806d54 <___svfprintf_internal_r+0x428>
  8069fc:	84000044 	addi	r16,r16,1
  806a00:	00010206 	br	806e0c <___svfprintf_internal_r+0x4e0>
  806a04:	01400c04 	movi	r5,48
  806a08:	1140f826 	beq	r2,r5,806dec <___svfprintf_internal_r+0x4c0>
  806a0c:	01400944 	movi	r5,37
  806a10:	11400a1e 	bne	r2,r5,806a3c <___svfprintf_internal_r+0x110>
  806a14:	d8800005 	stb	r2,0(sp)
  806a18:	e0800117 	ldw	r2,4(fp)
  806a1c:	a00f883a 	mov	r7,r20
  806a20:	d80d883a 	mov	r6,sp
  806a24:	e00b883a 	mov	r5,fp
  806a28:	9809883a 	mov	r4,r19
  806a2c:	103ee83a 	callr	r2
  806a30:	1000c81e 	bne	r2,zero,806d54 <___svfprintf_internal_r+0x428>
  806a34:	84000044 	addi	r16,r16,1
  806a38:	0000f306 	br	806e08 <___svfprintf_internal_r+0x4dc>
  806a3c:	217ff404 	addi	r5,r4,-48
  806a40:	29403fcc 	andi	r5,r5,255
  806a44:	00c00244 	movi	r3,9
  806a48:	19400736 	bltu	r3,r5,806a68 <___svfprintf_internal_r+0x13c>
  806a4c:	00bfffc4 	movi	r2,-1
  806a50:	88800226 	beq	r17,r2,806a5c <___svfprintf_internal_r+0x130>
  806a54:	8c4002a4 	muli	r17,r17,10
  806a58:	00000106 	br	806a60 <___svfprintf_internal_r+0x134>
  806a5c:	0023883a 	mov	r17,zero
  806a60:	2c63883a 	add	r17,r5,r17
  806a64:	0000e206 	br	806df0 <___svfprintf_internal_r+0x4c4>
  806a68:	01400b84 	movi	r5,46
  806a6c:	1140e426 	beq	r2,r5,806e00 <___svfprintf_internal_r+0x4d4>
  806a70:	05000084 	movi	r20,2
  806a74:	213ff404 	addi	r4,r4,-48
  806a78:	21003fcc 	andi	r4,r4,255
  806a7c:	00c00244 	movi	r3,9
  806a80:	19000736 	bltu	r3,r4,806aa0 <___svfprintf_internal_r+0x174>
  806a84:	00bfffc4 	movi	r2,-1
  806a88:	90800226 	beq	r18,r2,806a94 <___svfprintf_internal_r+0x168>
  806a8c:	948002a4 	muli	r18,r18,10
  806a90:	00000106 	br	806a98 <___svfprintf_internal_r+0x16c>
  806a94:	0025883a 	mov	r18,zero
  806a98:	24a5883a 	add	r18,r4,r18
  806a9c:	0000db06 	br	806e0c <___svfprintf_internal_r+0x4e0>
  806aa0:	00c01b04 	movi	r3,108
  806aa4:	10c0d426 	beq	r2,r3,806df8 <___svfprintf_internal_r+0x4cc>
  806aa8:	013fffc4 	movi	r4,-1
  806aac:	91000226 	beq	r18,r4,806ab8 <___svfprintf_internal_r+0x18c>
  806ab0:	d8000b15 	stw	zero,44(sp)
  806ab4:	00000106 	br	806abc <___svfprintf_internal_r+0x190>
  806ab8:	04800044 	movi	r18,1
  806abc:	01001a44 	movi	r4,105
  806ac0:	11001626 	beq	r2,r4,806b1c <___svfprintf_internal_r+0x1f0>
  806ac4:	20800916 	blt	r4,r2,806aec <___svfprintf_internal_r+0x1c0>
  806ac8:	010018c4 	movi	r4,99
  806acc:	11008a26 	beq	r2,r4,806cf8 <___svfprintf_internal_r+0x3cc>
  806ad0:	01001904 	movi	r4,100
  806ad4:	11001126 	beq	r2,r4,806b1c <___svfprintf_internal_r+0x1f0>
  806ad8:	01001604 	movi	r4,88
  806adc:	1100ca1e 	bne	r2,r4,806e08 <___svfprintf_internal_r+0x4dc>
  806ae0:	00c00044 	movi	r3,1
  806ae4:	d8c00e15 	stw	r3,56(sp)
  806ae8:	00001406 	br	806b3c <___svfprintf_internal_r+0x210>
  806aec:	01001cc4 	movi	r4,115
  806af0:	11009a26 	beq	r2,r4,806d5c <___svfprintf_internal_r+0x430>
  806af4:	20800416 	blt	r4,r2,806b08 <___svfprintf_internal_r+0x1dc>
  806af8:	01001bc4 	movi	r4,111
  806afc:	1100c21e 	bne	r2,r4,806e08 <___svfprintf_internal_r+0x4dc>
  806b00:	05400204 	movi	r21,8
  806b04:	00000e06 	br	806b40 <___svfprintf_internal_r+0x214>
  806b08:	01001d44 	movi	r4,117
  806b0c:	11000c26 	beq	r2,r4,806b40 <___svfprintf_internal_r+0x214>
  806b10:	01001e04 	movi	r4,120
  806b14:	11000926 	beq	r2,r4,806b3c <___svfprintf_internal_r+0x210>
  806b18:	0000bb06 	br	806e08 <___svfprintf_internal_r+0x4dc>
  806b1c:	b5000104 	addi	r20,r22,4
  806b20:	b8000726 	beq	r23,zero,806b40 <___svfprintf_internal_r+0x214>
  806b24:	dd000d15 	stw	r20,52(sp)
  806b28:	b5800017 	ldw	r22,0(r22)
  806b2c:	b000080e 	bge	r22,zero,806b50 <___svfprintf_internal_r+0x224>
  806b30:	05adc83a 	sub	r22,zero,r22
  806b34:	02800044 	movi	r10,1
  806b38:	00000606 	br	806b54 <___svfprintf_internal_r+0x228>
  806b3c:	05400404 	movi	r21,16
  806b40:	b0c00104 	addi	r3,r22,4
  806b44:	d8c00d15 	stw	r3,52(sp)
  806b48:	b5800017 	ldw	r22,0(r22)
  806b4c:	002f883a 	mov	r23,zero
  806b50:	0015883a 	mov	r10,zero
  806b54:	d829883a 	mov	r20,sp
  806b58:	b0001426 	beq	r22,zero,806bac <___svfprintf_internal_r+0x280>
  806b5c:	b009883a 	mov	r4,r22
  806b60:	a80b883a 	mov	r5,r21
  806b64:	da801015 	stw	r10,64(sp)
  806b68:	0806fbc0 	call	806fbc <__udivsi3>
  806b6c:	1549383a 	mul	r4,r2,r21
  806b70:	00c00244 	movi	r3,9
  806b74:	da801017 	ldw	r10,64(sp)
  806b78:	b12dc83a 	sub	r22,r22,r4
  806b7c:	1d800216 	blt	r3,r22,806b88 <___svfprintf_internal_r+0x25c>
  806b80:	b5800c04 	addi	r22,r22,48
  806b84:	00000506 	br	806b9c <___svfprintf_internal_r+0x270>
  806b88:	d8c00e17 	ldw	r3,56(sp)
  806b8c:	18000226 	beq	r3,zero,806b98 <___svfprintf_internal_r+0x26c>
  806b90:	b5800dc4 	addi	r22,r22,55
  806b94:	00000106 	br	806b9c <___svfprintf_internal_r+0x270>
  806b98:	b58015c4 	addi	r22,r22,87
  806b9c:	a5800005 	stb	r22,0(r20)
  806ba0:	a5000044 	addi	r20,r20,1
  806ba4:	102d883a 	mov	r22,r2
  806ba8:	003feb06 	br	806b58 <__alt_mem_onchip_memory2_0+0xff786b58>
  806bac:	a6c7c83a 	sub	r3,r20,sp
  806bb0:	d8c00a15 	stw	r3,40(sp)
  806bb4:	90c5c83a 	sub	r2,r18,r3
  806bb8:	00800a0e 	bge	zero,r2,806be4 <___svfprintf_internal_r+0x2b8>
  806bbc:	a085883a 	add	r2,r20,r2
  806bc0:	01400c04 	movi	r5,48
  806bc4:	d8c00917 	ldw	r3,36(sp)
  806bc8:	a009883a 	mov	r4,r20
  806bcc:	a0c0032e 	bgeu	r20,r3,806bdc <___svfprintf_internal_r+0x2b0>
  806bd0:	a5000044 	addi	r20,r20,1
  806bd4:	21400005 	stb	r5,0(r4)
  806bd8:	a0bffa1e 	bne	r20,r2,806bc4 <__alt_mem_onchip_memory2_0+0xff786bc4>
  806bdc:	a6c7c83a 	sub	r3,r20,sp
  806be0:	d8c00a15 	stw	r3,40(sp)
  806be4:	d8c00a17 	ldw	r3,40(sp)
  806be8:	50d3883a 	add	r9,r10,r3
  806bec:	d8c00b17 	ldw	r3,44(sp)
  806bf0:	8a6dc83a 	sub	r22,r17,r9
  806bf4:	18001726 	beq	r3,zero,806c54 <___svfprintf_internal_r+0x328>
  806bf8:	50000a26 	beq	r10,zero,806c24 <___svfprintf_internal_r+0x2f8>
  806bfc:	00800b44 	movi	r2,45
  806c00:	d8800805 	stb	r2,32(sp)
  806c04:	e0800117 	ldw	r2,4(fp)
  806c08:	01c00044 	movi	r7,1
  806c0c:	d9800804 	addi	r6,sp,32
  806c10:	e00b883a 	mov	r5,fp
  806c14:	9809883a 	mov	r4,r19
  806c18:	103ee83a 	callr	r2
  806c1c:	10004d1e 	bne	r2,zero,806d54 <___svfprintf_internal_r+0x428>
  806c20:	84000044 	addi	r16,r16,1
  806c24:	0580070e 	bge	zero,r22,806c44 <___svfprintf_internal_r+0x318>
  806c28:	b00f883a 	mov	r7,r22
  806c2c:	01800c04 	movi	r6,48
  806c30:	e00b883a 	mov	r5,fp
  806c34:	9809883a 	mov	r4,r19
  806c38:	08068c00 	call	8068c0 <print_repeat>
  806c3c:	1000451e 	bne	r2,zero,806d54 <___svfprintf_internal_r+0x428>
  806c40:	85a1883a 	add	r16,r16,r22
  806c44:	d8c00a17 	ldw	r3,40(sp)
  806c48:	a013883a 	mov	r9,r20
  806c4c:	1d2dc83a 	sub	r22,r3,r20
  806c50:	00002206 	br	806cdc <___svfprintf_internal_r+0x3b0>
  806c54:	0580090e 	bge	zero,r22,806c7c <___svfprintf_internal_r+0x350>
  806c58:	b00f883a 	mov	r7,r22
  806c5c:	01800804 	movi	r6,32
  806c60:	e00b883a 	mov	r5,fp
  806c64:	9809883a 	mov	r4,r19
  806c68:	da801015 	stw	r10,64(sp)
  806c6c:	08068c00 	call	8068c0 <print_repeat>
  806c70:	da801017 	ldw	r10,64(sp)
  806c74:	1000371e 	bne	r2,zero,806d54 <___svfprintf_internal_r+0x428>
  806c78:	85a1883a 	add	r16,r16,r22
  806c7c:	503ff126 	beq	r10,zero,806c44 <__alt_mem_onchip_memory2_0+0xff786c44>
  806c80:	00800b44 	movi	r2,45
  806c84:	d8800805 	stb	r2,32(sp)
  806c88:	e0800117 	ldw	r2,4(fp)
  806c8c:	01c00044 	movi	r7,1
  806c90:	d9800804 	addi	r6,sp,32
  806c94:	e00b883a 	mov	r5,fp
  806c98:	9809883a 	mov	r4,r19
  806c9c:	103ee83a 	callr	r2
  806ca0:	10002c1e 	bne	r2,zero,806d54 <___svfprintf_internal_r+0x428>
  806ca4:	84000044 	addi	r16,r16,1
  806ca8:	003fe606 	br	806c44 <__alt_mem_onchip_memory2_0+0xff786c44>
  806cac:	4a7fffc4 	addi	r9,r9,-1
  806cb0:	48800003 	ldbu	r2,0(r9)
  806cb4:	01c00044 	movi	r7,1
  806cb8:	d9800804 	addi	r6,sp,32
  806cbc:	d8800805 	stb	r2,32(sp)
  806cc0:	e0800117 	ldw	r2,4(fp)
  806cc4:	e00b883a 	mov	r5,fp
  806cc8:	da401015 	stw	r9,64(sp)
  806ccc:	9809883a 	mov	r4,r19
  806cd0:	103ee83a 	callr	r2
  806cd4:	da401017 	ldw	r9,64(sp)
  806cd8:	10001e1e 	bne	r2,zero,806d54 <___svfprintf_internal_r+0x428>
  806cdc:	8245c83a 	sub	r2,r16,r9
  806ce0:	4d89883a 	add	r4,r9,r22
  806ce4:	a085883a 	add	r2,r20,r2
  806ce8:	013ff016 	blt	zero,r4,806cac <__alt_mem_onchip_memory2_0+0xff786cac>
  806cec:	1021883a 	mov	r16,r2
  806cf0:	dd800d17 	ldw	r22,52(sp)
  806cf4:	00004406 	br	806e08 <___svfprintf_internal_r+0x4dc>
  806cf8:	00800044 	movi	r2,1
  806cfc:	1440080e 	bge	r2,r17,806d20 <___svfprintf_internal_r+0x3f4>
  806d00:	8d3fffc4 	addi	r20,r17,-1
  806d04:	a00f883a 	mov	r7,r20
  806d08:	01800804 	movi	r6,32
  806d0c:	e00b883a 	mov	r5,fp
  806d10:	9809883a 	mov	r4,r19
  806d14:	08068c00 	call	8068c0 <print_repeat>
  806d18:	10000e1e 	bne	r2,zero,806d54 <___svfprintf_internal_r+0x428>
  806d1c:	8521883a 	add	r16,r16,r20
  806d20:	b0800017 	ldw	r2,0(r22)
  806d24:	01c00044 	movi	r7,1
  806d28:	d80d883a 	mov	r6,sp
  806d2c:	d8800005 	stb	r2,0(sp)
  806d30:	e0800117 	ldw	r2,4(fp)
  806d34:	e00b883a 	mov	r5,fp
  806d38:	9809883a 	mov	r4,r19
  806d3c:	b5000104 	addi	r20,r22,4
  806d40:	103ee83a 	callr	r2
  806d44:	1000031e 	bne	r2,zero,806d54 <___svfprintf_internal_r+0x428>
  806d48:	84000044 	addi	r16,r16,1
  806d4c:	a02d883a 	mov	r22,r20
  806d50:	00002d06 	br	806e08 <___svfprintf_internal_r+0x4dc>
  806d54:	00bfffc4 	movi	r2,-1
  806d58:	00003106 	br	806e20 <___svfprintf_internal_r+0x4f4>
  806d5c:	b5000017 	ldw	r20,0(r22)
  806d60:	b0c00104 	addi	r3,r22,4
  806d64:	d8c00a15 	stw	r3,40(sp)
  806d68:	a009883a 	mov	r4,r20
  806d6c:	080666c0 	call	80666c <strlen>
  806d70:	8893c83a 	sub	r9,r17,r2
  806d74:	102d883a 	mov	r22,r2
  806d78:	0240090e 	bge	zero,r9,806da0 <___svfprintf_internal_r+0x474>
  806d7c:	480f883a 	mov	r7,r9
  806d80:	01800804 	movi	r6,32
  806d84:	e00b883a 	mov	r5,fp
  806d88:	9809883a 	mov	r4,r19
  806d8c:	da401015 	stw	r9,64(sp)
  806d90:	08068c00 	call	8068c0 <print_repeat>
  806d94:	da401017 	ldw	r9,64(sp)
  806d98:	103fee1e 	bne	r2,zero,806d54 <__alt_mem_onchip_memory2_0+0xff786d54>
  806d9c:	8261883a 	add	r16,r16,r9
  806da0:	e0800117 	ldw	r2,4(fp)
  806da4:	b00f883a 	mov	r7,r22
  806da8:	a00d883a 	mov	r6,r20
  806dac:	e00b883a 	mov	r5,fp
  806db0:	9809883a 	mov	r4,r19
  806db4:	103ee83a 	callr	r2
  806db8:	103fe61e 	bne	r2,zero,806d54 <__alt_mem_onchip_memory2_0+0xff786d54>
  806dbc:	85a1883a 	add	r16,r16,r22
  806dc0:	dd800a17 	ldw	r22,40(sp)
  806dc4:	00001006 	br	806e08 <___svfprintf_internal_r+0x4dc>
  806dc8:	05c00044 	movi	r23,1
  806dcc:	04bfffc4 	movi	r18,-1
  806dd0:	d8000e15 	stw	zero,56(sp)
  806dd4:	05400284 	movi	r21,10
  806dd8:	9023883a 	mov	r17,r18
  806ddc:	d8000c15 	stw	zero,48(sp)
  806de0:	d8000b15 	stw	zero,44(sp)
  806de4:	b829883a 	mov	r20,r23
  806de8:	00000806 	br	806e0c <___svfprintf_internal_r+0x4e0>
  806dec:	dd000b15 	stw	r20,44(sp)
  806df0:	05000084 	movi	r20,2
  806df4:	00000506 	br	806e0c <___svfprintf_internal_r+0x4e0>
  806df8:	00c00044 	movi	r3,1
  806dfc:	d8c00c15 	stw	r3,48(sp)
  806e00:	050000c4 	movi	r20,3
  806e04:	00000106 	br	806e0c <___svfprintf_internal_r+0x4e0>
  806e08:	0029883a 	mov	r20,zero
  806e0c:	d8c00f17 	ldw	r3,60(sp)
  806e10:	18c00044 	addi	r3,r3,1
  806e14:	d8c00f15 	stw	r3,60(sp)
  806e18:	003ede06 	br	806994 <__alt_mem_onchip_memory2_0+0xff786994>
  806e1c:	8005883a 	mov	r2,r16
  806e20:	dfc01a17 	ldw	ra,104(sp)
  806e24:	df001917 	ldw	fp,100(sp)
  806e28:	ddc01817 	ldw	r23,96(sp)
  806e2c:	dd801717 	ldw	r22,92(sp)
  806e30:	dd401617 	ldw	r21,88(sp)
  806e34:	dd001517 	ldw	r20,84(sp)
  806e38:	dcc01417 	ldw	r19,80(sp)
  806e3c:	dc801317 	ldw	r18,76(sp)
  806e40:	dc401217 	ldw	r17,72(sp)
  806e44:	dc001117 	ldw	r16,68(sp)
  806e48:	dec01b04 	addi	sp,sp,108
  806e4c:	f800283a 	ret

00806e50 <__vfprintf_internal_unused>:
  806e50:	00802074 	movhi	r2,129
  806e54:	10a87d04 	addi	r2,r2,-24076
  806e58:	300f883a 	mov	r7,r6
  806e5c:	280d883a 	mov	r6,r5
  806e60:	200b883a 	mov	r5,r4
  806e64:	11000017 	ldw	r4,0(r2)
  806e68:	080692c1 	jmpi	80692c <___svfprintf_internal_r>

00806e6c <_write_r>:
  806e6c:	defffd04 	addi	sp,sp,-12
  806e70:	dc000015 	stw	r16,0(sp)
  806e74:	04002074 	movhi	r16,129
  806e78:	dc400115 	stw	r17,4(sp)
  806e7c:	842d6104 	addi	r16,r16,-19068
  806e80:	2023883a 	mov	r17,r4
  806e84:	2809883a 	mov	r4,r5
  806e88:	300b883a 	mov	r5,r6
  806e8c:	380d883a 	mov	r6,r7
  806e90:	dfc00215 	stw	ra,8(sp)
  806e94:	80000015 	stw	zero,0(r16)
  806e98:	08072640 	call	807264 <write>
  806e9c:	00ffffc4 	movi	r3,-1
  806ea0:	10c0031e 	bne	r2,r3,806eb0 <_write_r+0x44>
  806ea4:	80c00017 	ldw	r3,0(r16)
  806ea8:	18000126 	beq	r3,zero,806eb0 <_write_r+0x44>
  806eac:	88c00015 	stw	r3,0(r17)
  806eb0:	dfc00217 	ldw	ra,8(sp)
  806eb4:	dc400117 	ldw	r17,4(sp)
  806eb8:	dc000017 	ldw	r16,0(sp)
  806ebc:	dec00304 	addi	sp,sp,12
  806ec0:	f800283a 	ret

00806ec4 <__divsi3>:
  806ec4:	20001b16 	blt	r4,zero,806f34 <__divsi3+0x70>
  806ec8:	000f883a 	mov	r7,zero
  806ecc:	28001616 	blt	r5,zero,806f28 <__divsi3+0x64>
  806ed0:	200d883a 	mov	r6,r4
  806ed4:	29001a2e 	bgeu	r5,r4,806f40 <__divsi3+0x7c>
  806ed8:	00800804 	movi	r2,32
  806edc:	00c00044 	movi	r3,1
  806ee0:	00000106 	br	806ee8 <__divsi3+0x24>
  806ee4:	10000d26 	beq	r2,zero,806f1c <__divsi3+0x58>
  806ee8:	294b883a 	add	r5,r5,r5
  806eec:	10bfffc4 	addi	r2,r2,-1
  806ef0:	18c7883a 	add	r3,r3,r3
  806ef4:	293ffb36 	bltu	r5,r4,806ee4 <__alt_mem_onchip_memory2_0+0xff786ee4>
  806ef8:	0005883a 	mov	r2,zero
  806efc:	18000726 	beq	r3,zero,806f1c <__divsi3+0x58>
  806f00:	0005883a 	mov	r2,zero
  806f04:	31400236 	bltu	r6,r5,806f10 <__divsi3+0x4c>
  806f08:	314dc83a 	sub	r6,r6,r5
  806f0c:	10c4b03a 	or	r2,r2,r3
  806f10:	1806d07a 	srli	r3,r3,1
  806f14:	280ad07a 	srli	r5,r5,1
  806f18:	183ffa1e 	bne	r3,zero,806f04 <__alt_mem_onchip_memory2_0+0xff786f04>
  806f1c:	38000126 	beq	r7,zero,806f24 <__divsi3+0x60>
  806f20:	0085c83a 	sub	r2,zero,r2
  806f24:	f800283a 	ret
  806f28:	014bc83a 	sub	r5,zero,r5
  806f2c:	39c0005c 	xori	r7,r7,1
  806f30:	003fe706 	br	806ed0 <__alt_mem_onchip_memory2_0+0xff786ed0>
  806f34:	0109c83a 	sub	r4,zero,r4
  806f38:	01c00044 	movi	r7,1
  806f3c:	003fe306 	br	806ecc <__alt_mem_onchip_memory2_0+0xff786ecc>
  806f40:	00c00044 	movi	r3,1
  806f44:	003fee06 	br	806f00 <__alt_mem_onchip_memory2_0+0xff786f00>

00806f48 <__modsi3>:
  806f48:	20001716 	blt	r4,zero,806fa8 <__modsi3+0x60>
  806f4c:	000f883a 	mov	r7,zero
  806f50:	2005883a 	mov	r2,r4
  806f54:	28001216 	blt	r5,zero,806fa0 <__modsi3+0x58>
  806f58:	2900162e 	bgeu	r5,r4,806fb4 <__modsi3+0x6c>
  806f5c:	01800804 	movi	r6,32
  806f60:	00c00044 	movi	r3,1
  806f64:	00000106 	br	806f6c <__modsi3+0x24>
  806f68:	30000a26 	beq	r6,zero,806f94 <__modsi3+0x4c>
  806f6c:	294b883a 	add	r5,r5,r5
  806f70:	31bfffc4 	addi	r6,r6,-1
  806f74:	18c7883a 	add	r3,r3,r3
  806f78:	293ffb36 	bltu	r5,r4,806f68 <__alt_mem_onchip_memory2_0+0xff786f68>
  806f7c:	18000526 	beq	r3,zero,806f94 <__modsi3+0x4c>
  806f80:	1806d07a 	srli	r3,r3,1
  806f84:	11400136 	bltu	r2,r5,806f8c <__modsi3+0x44>
  806f88:	1145c83a 	sub	r2,r2,r5
  806f8c:	280ad07a 	srli	r5,r5,1
  806f90:	183ffb1e 	bne	r3,zero,806f80 <__alt_mem_onchip_memory2_0+0xff786f80>
  806f94:	38000126 	beq	r7,zero,806f9c <__modsi3+0x54>
  806f98:	0085c83a 	sub	r2,zero,r2
  806f9c:	f800283a 	ret
  806fa0:	014bc83a 	sub	r5,zero,r5
  806fa4:	003fec06 	br	806f58 <__alt_mem_onchip_memory2_0+0xff786f58>
  806fa8:	0109c83a 	sub	r4,zero,r4
  806fac:	01c00044 	movi	r7,1
  806fb0:	003fe706 	br	806f50 <__alt_mem_onchip_memory2_0+0xff786f50>
  806fb4:	00c00044 	movi	r3,1
  806fb8:	003ff106 	br	806f80 <__alt_mem_onchip_memory2_0+0xff786f80>

00806fbc <__udivsi3>:
  806fbc:	200d883a 	mov	r6,r4
  806fc0:	2900152e 	bgeu	r5,r4,807018 <__udivsi3+0x5c>
  806fc4:	28001416 	blt	r5,zero,807018 <__udivsi3+0x5c>
  806fc8:	00800804 	movi	r2,32
  806fcc:	00c00044 	movi	r3,1
  806fd0:	00000206 	br	806fdc <__udivsi3+0x20>
  806fd4:	10000e26 	beq	r2,zero,807010 <__udivsi3+0x54>
  806fd8:	28000516 	blt	r5,zero,806ff0 <__udivsi3+0x34>
  806fdc:	294b883a 	add	r5,r5,r5
  806fe0:	10bfffc4 	addi	r2,r2,-1
  806fe4:	18c7883a 	add	r3,r3,r3
  806fe8:	293ffa36 	bltu	r5,r4,806fd4 <__alt_mem_onchip_memory2_0+0xff786fd4>
  806fec:	18000826 	beq	r3,zero,807010 <__udivsi3+0x54>
  806ff0:	0005883a 	mov	r2,zero
  806ff4:	31400236 	bltu	r6,r5,807000 <__udivsi3+0x44>
  806ff8:	314dc83a 	sub	r6,r6,r5
  806ffc:	10c4b03a 	or	r2,r2,r3
  807000:	1806d07a 	srli	r3,r3,1
  807004:	280ad07a 	srli	r5,r5,1
  807008:	183ffa1e 	bne	r3,zero,806ff4 <__alt_mem_onchip_memory2_0+0xff786ff4>
  80700c:	f800283a 	ret
  807010:	0005883a 	mov	r2,zero
  807014:	f800283a 	ret
  807018:	00c00044 	movi	r3,1
  80701c:	003ff406 	br	806ff0 <__alt_mem_onchip_memory2_0+0xff786ff0>

00807020 <__umodsi3>:
  807020:	2005883a 	mov	r2,r4
  807024:	2900122e 	bgeu	r5,r4,807070 <__umodsi3+0x50>
  807028:	28001116 	blt	r5,zero,807070 <__umodsi3+0x50>
  80702c:	01800804 	movi	r6,32
  807030:	00c00044 	movi	r3,1
  807034:	00000206 	br	807040 <__umodsi3+0x20>
  807038:	30000c26 	beq	r6,zero,80706c <__umodsi3+0x4c>
  80703c:	28000516 	blt	r5,zero,807054 <__umodsi3+0x34>
  807040:	294b883a 	add	r5,r5,r5
  807044:	31bfffc4 	addi	r6,r6,-1
  807048:	18c7883a 	add	r3,r3,r3
  80704c:	293ffa36 	bltu	r5,r4,807038 <__alt_mem_onchip_memory2_0+0xff787038>
  807050:	18000626 	beq	r3,zero,80706c <__umodsi3+0x4c>
  807054:	1806d07a 	srli	r3,r3,1
  807058:	11400136 	bltu	r2,r5,807060 <__umodsi3+0x40>
  80705c:	1145c83a 	sub	r2,r2,r5
  807060:	280ad07a 	srli	r5,r5,1
  807064:	183ffb1e 	bne	r3,zero,807054 <__alt_mem_onchip_memory2_0+0xff787054>
  807068:	f800283a 	ret
  80706c:	f800283a 	ret
  807070:	00c00044 	movi	r3,1
  807074:	003ff706 	br	807054 <__alt_mem_onchip_memory2_0+0xff787054>

00807078 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  807078:	defffc04 	addi	sp,sp,-16
  80707c:	df000315 	stw	fp,12(sp)
  807080:	df000304 	addi	fp,sp,12
  807084:	e13ffd15 	stw	r4,-12(fp)
  807088:	e17ffe15 	stw	r5,-8(fp)
  80708c:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
  807090:	e0fffe17 	ldw	r3,-8(fp)
  807094:	e0bffd17 	ldw	r2,-12(fp)
  807098:	18800c26 	beq	r3,r2,8070cc <alt_load_section+0x54>
  {
    while( to != end )
  80709c:	00000806 	br	8070c0 <alt_load_section+0x48>
    {
      *to++ = *from++;
  8070a0:	e0bffe17 	ldw	r2,-8(fp)
  8070a4:	10c00104 	addi	r3,r2,4
  8070a8:	e0fffe15 	stw	r3,-8(fp)
  8070ac:	e0fffd17 	ldw	r3,-12(fp)
  8070b0:	19000104 	addi	r4,r3,4
  8070b4:	e13ffd15 	stw	r4,-12(fp)
  8070b8:	18c00017 	ldw	r3,0(r3)
  8070bc:	10c00015 	stw	r3,0(r2)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
  8070c0:	e0fffe17 	ldw	r3,-8(fp)
  8070c4:	e0bfff17 	ldw	r2,-4(fp)
  8070c8:	18bff51e 	bne	r3,r2,8070a0 <__alt_mem_onchip_memory2_0+0xff7870a0>
    {
      *to++ = *from++;
    }
  }
}
  8070cc:	0001883a 	nop
  8070d0:	e037883a 	mov	sp,fp
  8070d4:	df000017 	ldw	fp,0(sp)
  8070d8:	dec00104 	addi	sp,sp,4
  8070dc:	f800283a 	ret

008070e0 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
  8070e0:	defffe04 	addi	sp,sp,-8
  8070e4:	dfc00115 	stw	ra,4(sp)
  8070e8:	df000015 	stw	fp,0(sp)
  8070ec:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
  8070f0:	01802074 	movhi	r6,129
  8070f4:	31a88704 	addi	r6,r6,-24036
  8070f8:	01402074 	movhi	r5,129
  8070fc:	2963c204 	addi	r5,r5,-28920
  807100:	01002074 	movhi	r4,129
  807104:	21288704 	addi	r4,r4,-24036
  807108:	08070780 	call	807078 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
  80710c:	01802034 	movhi	r6,128
  807110:	31809504 	addi	r6,r6,596
  807114:	01402034 	movhi	r5,128
  807118:	29400804 	addi	r5,r5,32
  80711c:	01002034 	movhi	r4,128
  807120:	21000804 	addi	r4,r4,32
  807124:	08070780 	call	807078 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
  807128:	01802074 	movhi	r6,129
  80712c:	31a3c204 	addi	r6,r6,-28920
  807130:	01402074 	movhi	r5,129
  807134:	29636e04 	addi	r5,r5,-29256
  807138:	01002074 	movhi	r4,129
  80713c:	21236e04 	addi	r4,r4,-29256
  807140:	08070780 	call	807078 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  807144:	08080e80 	call	8080e8 <alt_dcache_flush_all>
  alt_icache_flush_all();
  807148:	08082500 	call	808250 <alt_icache_flush_all>
}
  80714c:	0001883a 	nop
  807150:	e037883a 	mov	sp,fp
  807154:	dfc00117 	ldw	ra,4(sp)
  807158:	df000017 	ldw	fp,0(sp)
  80715c:	dec00204 	addi	sp,sp,8
  807160:	f800283a 	ret

00807164 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
  807164:	defffd04 	addi	sp,sp,-12
  807168:	dfc00215 	stw	ra,8(sp)
  80716c:	df000115 	stw	fp,4(sp)
  807170:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
  807174:	0009883a 	mov	r4,zero
  807178:	08073940 	call	807394 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
  80717c:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
  807180:	08073cc0 	call	8073cc <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
  807184:	01802074 	movhi	r6,129
  807188:	31a3b504 	addi	r6,r6,-28972
  80718c:	01402074 	movhi	r5,129
  807190:	2963b504 	addi	r5,r5,-28972
  807194:	01002074 	movhi	r4,129
  807198:	2123b504 	addi	r4,r4,-28972
  80719c:	08083480 	call	808348 <alt_io_redirect>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
  8071a0:	d0a4e717 	ldw	r2,-27748(gp)
  8071a4:	d0e4e817 	ldw	r3,-27744(gp)
  8071a8:	d124e917 	ldw	r4,-27740(gp)
  8071ac:	200d883a 	mov	r6,r4
  8071b0:	180b883a 	mov	r5,r3
  8071b4:	1009883a 	mov	r4,r2
  8071b8:	08064700 	call	806470 <main>
  8071bc:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
  8071c0:	01000044 	movi	r4,1
  8071c4:	08080180 	call	808018 <close>
  exit (result);
  8071c8:	e13fff17 	ldw	r4,-4(fp)
  8071cc:	0808b4c0 	call	808b4c <exit>

008071d0 <alt_putstr>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided fputs() routine.
 */
int 
alt_putstr(const char* str)
{
  8071d0:	defffd04 	addi	sp,sp,-12
  8071d4:	dfc00215 	stw	ra,8(sp)
  8071d8:	df000115 	stw	fp,4(sp)
  8071dc:	df000104 	addi	fp,sp,4
  8071e0:	e13fff15 	stw	r4,-4(fp)
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, str, strlen(str), 0);
#else
    return fputs(str, stdout);
  8071e4:	00802074 	movhi	r2,129
  8071e8:	10a87d04 	addi	r2,r2,-24076
  8071ec:	10800017 	ldw	r2,0(r2)
  8071f0:	10800217 	ldw	r2,8(r2)
  8071f4:	100b883a 	mov	r5,r2
  8071f8:	e13fff17 	ldw	r4,-4(fp)
  8071fc:	0808b6c0 	call	808b6c <fputs>
#endif
#endif
}
  807200:	e037883a 	mov	sp,fp
  807204:	dfc00117 	ldw	ra,4(sp)
  807208:	df000017 	ldw	fp,0(sp)
  80720c:	dec00204 	addi	sp,sp,8
  807210:	f800283a 	ret

00807214 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  807214:	defffe04 	addi	sp,sp,-8
  807218:	dfc00115 	stw	ra,4(sp)
  80721c:	df000015 	stw	fp,0(sp)
  807220:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  807224:	00802074 	movhi	r2,129
  807228:	10a88404 	addi	r2,r2,-24048
  80722c:	10800017 	ldw	r2,0(r2)
  807230:	10000526 	beq	r2,zero,807248 <alt_get_errno+0x34>
  807234:	00802074 	movhi	r2,129
  807238:	10a88404 	addi	r2,r2,-24048
  80723c:	10800017 	ldw	r2,0(r2)
  807240:	103ee83a 	callr	r2
  807244:	00000206 	br	807250 <alt_get_errno+0x3c>
  807248:	00802074 	movhi	r2,129
  80724c:	10ad6104 	addi	r2,r2,-19068
}
  807250:	e037883a 	mov	sp,fp
  807254:	dfc00117 	ldw	ra,4(sp)
  807258:	df000017 	ldw	fp,0(sp)
  80725c:	dec00204 	addi	sp,sp,8
  807260:	f800283a 	ret

00807264 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
  807264:	defff904 	addi	sp,sp,-28
  807268:	dfc00615 	stw	ra,24(sp)
  80726c:	df000515 	stw	fp,20(sp)
  807270:	df000504 	addi	fp,sp,20
  807274:	e13ffd15 	stw	r4,-12(fp)
  807278:	e17ffe15 	stw	r5,-8(fp)
  80727c:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
  807280:	e0bffd17 	ldw	r2,-12(fp)
  807284:	10000616 	blt	r2,zero,8072a0 <write+0x3c>
  807288:	e0bffd17 	ldw	r2,-12(fp)
  80728c:	10c00324 	muli	r3,r2,12
  807290:	00802074 	movhi	r2,129
  807294:	10a81c04 	addi	r2,r2,-24464
  807298:	1885883a 	add	r2,r3,r2
  80729c:	00000106 	br	8072a4 <write+0x40>
  8072a0:	0005883a 	mov	r2,zero
  8072a4:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
  8072a8:	e0bffb17 	ldw	r2,-20(fp)
  8072ac:	10002126 	beq	r2,zero,807334 <write+0xd0>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
  8072b0:	e0bffb17 	ldw	r2,-20(fp)
  8072b4:	10800217 	ldw	r2,8(r2)
  8072b8:	108000cc 	andi	r2,r2,3
  8072bc:	10001826 	beq	r2,zero,807320 <write+0xbc>
  8072c0:	e0bffb17 	ldw	r2,-20(fp)
  8072c4:	10800017 	ldw	r2,0(r2)
  8072c8:	10800617 	ldw	r2,24(r2)
  8072cc:	10001426 	beq	r2,zero,807320 <write+0xbc>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
  8072d0:	e0bffb17 	ldw	r2,-20(fp)
  8072d4:	10800017 	ldw	r2,0(r2)
  8072d8:	10800617 	ldw	r2,24(r2)
  8072dc:	e0ffff17 	ldw	r3,-4(fp)
  8072e0:	180d883a 	mov	r6,r3
  8072e4:	e17ffe17 	ldw	r5,-8(fp)
  8072e8:	e13ffb17 	ldw	r4,-20(fp)
  8072ec:	103ee83a 	callr	r2
  8072f0:	e0bffc15 	stw	r2,-16(fp)
  8072f4:	e0bffc17 	ldw	r2,-16(fp)
  8072f8:	1000070e 	bge	r2,zero,807318 <write+0xb4>
      {
        ALT_ERRNO = -rval;
  8072fc:	08072140 	call	807214 <alt_get_errno>
  807300:	1007883a 	mov	r3,r2
  807304:	e0bffc17 	ldw	r2,-16(fp)
  807308:	0085c83a 	sub	r2,zero,r2
  80730c:	18800015 	stw	r2,0(r3)
        return -1;
  807310:	00bfffc4 	movi	r2,-1
  807314:	00000c06 	br	807348 <write+0xe4>
      }
      return rval;
  807318:	e0bffc17 	ldw	r2,-16(fp)
  80731c:	00000a06 	br	807348 <write+0xe4>
    }
    else
    {
      ALT_ERRNO = EACCES;
  807320:	08072140 	call	807214 <alt_get_errno>
  807324:	1007883a 	mov	r3,r2
  807328:	00800344 	movi	r2,13
  80732c:	18800015 	stw	r2,0(r3)
  807330:	00000406 	br	807344 <write+0xe0>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
  807334:	08072140 	call	807214 <alt_get_errno>
  807338:	1007883a 	mov	r3,r2
  80733c:	00801444 	movi	r2,81
  807340:	18800015 	stw	r2,0(r3)
  }
  return -1;
  807344:	00bfffc4 	movi	r2,-1
}
  807348:	e037883a 	mov	sp,fp
  80734c:	dfc00117 	ldw	ra,4(sp)
  807350:	df000017 	ldw	fp,0(sp)
  807354:	dec00204 	addi	sp,sp,8
  807358:	f800283a 	ret

0080735c <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
  80735c:	defffd04 	addi	sp,sp,-12
  807360:	dfc00215 	stw	ra,8(sp)
  807364:	df000115 	stw	fp,4(sp)
  807368:	df000104 	addi	fp,sp,4
  80736c:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
  807370:	01402074 	movhi	r5,129
  807374:	29688104 	addi	r5,r5,-24060
  807378:	e13fff17 	ldw	r4,-4(fp)
  80737c:	08081ac0 	call	8081ac <alt_dev_llist_insert>
}
  807380:	e037883a 	mov	sp,fp
  807384:	dfc00117 	ldw	ra,4(sp)
  807388:	df000017 	ldw	fp,0(sp)
  80738c:	dec00204 	addi	sp,sp,8
  807390:	f800283a 	ret

00807394 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
  807394:	defffd04 	addi	sp,sp,-12
  807398:	dfc00215 	stw	ra,8(sp)
  80739c:	df000115 	stw	fp,4(sp)
  8073a0:	df000104 	addi	fp,sp,4
  8073a4:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
  8073a8:	08088400 	call	808840 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
  8073ac:	00800044 	movi	r2,1
  8073b0:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
  8073b4:	0001883a 	nop
  8073b8:	e037883a 	mov	sp,fp
  8073bc:	dfc00117 	ldw	ra,4(sp)
  8073c0:	df000017 	ldw	fp,0(sp)
  8073c4:	dec00204 	addi	sp,sp,8
  8073c8:	f800283a 	ret

008073cc <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
  8073cc:	defffe04 	addi	sp,sp,-8
  8073d0:	dfc00115 	stw	ra,4(sp)
  8073d4:	df000015 	stw	fp,0(sp)
  8073d8:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
  8073dc:	000d883a 	mov	r6,zero
  8073e0:	000b883a 	mov	r5,zero
  8073e4:	01002074 	movhi	r4,129
  8073e8:	21240404 	addi	r4,r4,-28656
  8073ec:	080757c0 	call	80757c <altera_avalon_jtag_uart_init>
  8073f0:	01002074 	movhi	r4,129
  8073f4:	2123fa04 	addi	r4,r4,-28696
  8073f8:	080735c0 	call	80735c <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS_0, sysid_qsys_0);
  8073fc:	0001883a 	nop
}
  807400:	0001883a 	nop
  807404:	e037883a 	mov	sp,fp
  807408:	dfc00117 	ldw	ra,4(sp)
  80740c:	df000017 	ldw	fp,0(sp)
  807410:	dec00204 	addi	sp,sp,8
  807414:	f800283a 	ret

00807418 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
  807418:	defffa04 	addi	sp,sp,-24
  80741c:	dfc00515 	stw	ra,20(sp)
  807420:	df000415 	stw	fp,16(sp)
  807424:	df000404 	addi	fp,sp,16
  807428:	e13ffd15 	stw	r4,-12(fp)
  80742c:	e17ffe15 	stw	r5,-8(fp)
  807430:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  807434:	e0bffd17 	ldw	r2,-12(fp)
  807438:	10800017 	ldw	r2,0(r2)
  80743c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
  807440:	e0bffc17 	ldw	r2,-16(fp)
  807444:	10c00a04 	addi	r3,r2,40
  807448:	e0bffd17 	ldw	r2,-12(fp)
  80744c:	10800217 	ldw	r2,8(r2)
  807450:	100f883a 	mov	r7,r2
  807454:	e1bfff17 	ldw	r6,-4(fp)
  807458:	e17ffe17 	ldw	r5,-8(fp)
  80745c:	1809883a 	mov	r4,r3
  807460:	0807a480 	call	807a48 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
  807464:	e037883a 	mov	sp,fp
  807468:	dfc00117 	ldw	ra,4(sp)
  80746c:	df000017 	ldw	fp,0(sp)
  807470:	dec00204 	addi	sp,sp,8
  807474:	f800283a 	ret

00807478 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
  807478:	defffa04 	addi	sp,sp,-24
  80747c:	dfc00515 	stw	ra,20(sp)
  807480:	df000415 	stw	fp,16(sp)
  807484:	df000404 	addi	fp,sp,16
  807488:	e13ffd15 	stw	r4,-12(fp)
  80748c:	e17ffe15 	stw	r5,-8(fp)
  807490:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  807494:	e0bffd17 	ldw	r2,-12(fp)
  807498:	10800017 	ldw	r2,0(r2)
  80749c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
  8074a0:	e0bffc17 	ldw	r2,-16(fp)
  8074a4:	10c00a04 	addi	r3,r2,40
  8074a8:	e0bffd17 	ldw	r2,-12(fp)
  8074ac:	10800217 	ldw	r2,8(r2)
  8074b0:	100f883a 	mov	r7,r2
  8074b4:	e1bfff17 	ldw	r6,-4(fp)
  8074b8:	e17ffe17 	ldw	r5,-8(fp)
  8074bc:	1809883a 	mov	r4,r3
  8074c0:	0807c640 	call	807c64 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
  8074c4:	e037883a 	mov	sp,fp
  8074c8:	dfc00117 	ldw	ra,4(sp)
  8074cc:	df000017 	ldw	fp,0(sp)
  8074d0:	dec00204 	addi	sp,sp,8
  8074d4:	f800283a 	ret

008074d8 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
  8074d8:	defffc04 	addi	sp,sp,-16
  8074dc:	dfc00315 	stw	ra,12(sp)
  8074e0:	df000215 	stw	fp,8(sp)
  8074e4:	df000204 	addi	fp,sp,8
  8074e8:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  8074ec:	e0bfff17 	ldw	r2,-4(fp)
  8074f0:	10800017 	ldw	r2,0(r2)
  8074f4:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
  8074f8:	e0bffe17 	ldw	r2,-8(fp)
  8074fc:	10c00a04 	addi	r3,r2,40
  807500:	e0bfff17 	ldw	r2,-4(fp)
  807504:	10800217 	ldw	r2,8(r2)
  807508:	100b883a 	mov	r5,r2
  80750c:	1809883a 	mov	r4,r3
  807510:	08078f00 	call	8078f0 <altera_avalon_jtag_uart_close>
}
  807514:	e037883a 	mov	sp,fp
  807518:	dfc00117 	ldw	ra,4(sp)
  80751c:	df000017 	ldw	fp,0(sp)
  807520:	dec00204 	addi	sp,sp,8
  807524:	f800283a 	ret

00807528 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
  807528:	defffa04 	addi	sp,sp,-24
  80752c:	dfc00515 	stw	ra,20(sp)
  807530:	df000415 	stw	fp,16(sp)
  807534:	df000404 	addi	fp,sp,16
  807538:	e13ffd15 	stw	r4,-12(fp)
  80753c:	e17ffe15 	stw	r5,-8(fp)
  807540:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
  807544:	e0bffd17 	ldw	r2,-12(fp)
  807548:	10800017 	ldw	r2,0(r2)
  80754c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
  807550:	e0bffc17 	ldw	r2,-16(fp)
  807554:	10800a04 	addi	r2,r2,40
  807558:	e1bfff17 	ldw	r6,-4(fp)
  80755c:	e17ffe17 	ldw	r5,-8(fp)
  807560:	1009883a 	mov	r4,r2
  807564:	08079580 	call	807958 <altera_avalon_jtag_uart_ioctl>
}
  807568:	e037883a 	mov	sp,fp
  80756c:	dfc00117 	ldw	ra,4(sp)
  807570:	df000017 	ldw	fp,0(sp)
  807574:	dec00204 	addi	sp,sp,8
  807578:	f800283a 	ret

0080757c <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
  80757c:	defffb04 	addi	sp,sp,-20
  807580:	dfc00415 	stw	ra,16(sp)
  807584:	df000315 	stw	fp,12(sp)
  807588:	df000304 	addi	fp,sp,12
  80758c:	e13ffd15 	stw	r4,-12(fp)
  807590:	e17ffe15 	stw	r5,-8(fp)
  807594:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  807598:	e0bffd17 	ldw	r2,-12(fp)
  80759c:	00c00044 	movi	r3,1
  8075a0:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
  8075a4:	e0bffd17 	ldw	r2,-12(fp)
  8075a8:	10800017 	ldw	r2,0(r2)
  8075ac:	10800104 	addi	r2,r2,4
  8075b0:	1007883a 	mov	r3,r2
  8075b4:	e0bffd17 	ldw	r2,-12(fp)
  8075b8:	10800817 	ldw	r2,32(r2)
  8075bc:	18800035 	stwio	r2,0(r3)
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
                      sp, NULL);
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
  8075c0:	e0bfff17 	ldw	r2,-4(fp)
  8075c4:	01802034 	movhi	r6,128
  8075c8:	319d8e04 	addi	r6,r6,30264
  8075cc:	e17ffd17 	ldw	r5,-12(fp)
  8075d0:	1009883a 	mov	r4,r2
  8075d4:	0800e7c0 	call	800e7c <alt_irq_register>
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
  8075d8:	e0bffd17 	ldw	r2,-12(fp)
  8075dc:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
  8075e0:	e0bffd17 	ldw	r2,-12(fp)
  8075e4:	10c00204 	addi	r3,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
  8075e8:	00802074 	movhi	r2,129
  8075ec:	10ad6604 	addi	r2,r2,-19048
  8075f0:	10800017 	ldw	r2,0(r2)
  8075f4:	e1fffd17 	ldw	r7,-12(fp)
  8075f8:	01802034 	movhi	r6,128
  8075fc:	319e1204 	addi	r6,r6,30792
  807600:	100b883a 	mov	r5,r2
  807604:	1809883a 	mov	r4,r3
  807608:	0807e880 	call	807e88 <alt_alarm_start>
  80760c:	1000040e 	bge	r2,zero,807620 <altera_avalon_jtag_uart_init+0xa4>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
  807610:	e0fffd17 	ldw	r3,-12(fp)
  807614:	00a00034 	movhi	r2,32768
  807618:	10bfffc4 	addi	r2,r2,-1
  80761c:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
  807620:	0001883a 	nop
  807624:	e037883a 	mov	sp,fp
  807628:	dfc00117 	ldw	ra,4(sp)
  80762c:	df000017 	ldw	fp,0(sp)
  807630:	dec00204 	addi	sp,sp,8
  807634:	f800283a 	ret

00807638 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
  807638:	defff704 	addi	sp,sp,-36
  80763c:	df000815 	stw	fp,32(sp)
  807640:	df000804 	addi	fp,sp,32
  807644:	e13ffe15 	stw	r4,-8(fp)
  807648:	e17fff15 	stw	r5,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
  80764c:	e0bffe17 	ldw	r2,-8(fp)
  807650:	e0bffa15 	stw	r2,-24(fp)
  unsigned int base = sp->base;
  807654:	e0bffa17 	ldw	r2,-24(fp)
  807658:	10800017 	ldw	r2,0(r2)
  80765c:	e0bffb15 	stw	r2,-20(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  807660:	e0bffb17 	ldw	r2,-20(fp)
  807664:	10800104 	addi	r2,r2,4
  807668:	10800037 	ldwio	r2,0(r2)
  80766c:	e0bffc15 	stw	r2,-16(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
  807670:	e0bffc17 	ldw	r2,-16(fp)
  807674:	1080c00c 	andi	r2,r2,768
  807678:	10006d26 	beq	r2,zero,807830 <altera_avalon_jtag_uart_irq+0x1f8>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
  80767c:	e0bffc17 	ldw	r2,-16(fp)
  807680:	1080400c 	andi	r2,r2,256
  807684:	10003526 	beq	r2,zero,80775c <altera_avalon_jtag_uart_irq+0x124>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
  807688:	00800074 	movhi	r2,1
  80768c:	e0bff815 	stw	r2,-32(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  807690:	e0bffa17 	ldw	r2,-24(fp)
  807694:	10800a17 	ldw	r2,40(r2)
  807698:	10800044 	addi	r2,r2,1
  80769c:	1081ffcc 	andi	r2,r2,2047
  8076a0:	e0bffd15 	stw	r2,-12(fp)
        if (next == sp->rx_out)
  8076a4:	e0bffa17 	ldw	r2,-24(fp)
  8076a8:	10c00b17 	ldw	r3,44(r2)
  8076ac:	e0bffd17 	ldw	r2,-12(fp)
  8076b0:	18801526 	beq	r3,r2,807708 <altera_avalon_jtag_uart_irq+0xd0>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
  8076b4:	e0bffb17 	ldw	r2,-20(fp)
  8076b8:	10800037 	ldwio	r2,0(r2)
  8076bc:	e0bff815 	stw	r2,-32(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
  8076c0:	e0bff817 	ldw	r2,-32(fp)
  8076c4:	10a0000c 	andi	r2,r2,32768
  8076c8:	10001126 	beq	r2,zero,807710 <altera_avalon_jtag_uart_irq+0xd8>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
  8076cc:	e0bffa17 	ldw	r2,-24(fp)
  8076d0:	10800a17 	ldw	r2,40(r2)
  8076d4:	e0fff817 	ldw	r3,-32(fp)
  8076d8:	1809883a 	mov	r4,r3
  8076dc:	e0fffa17 	ldw	r3,-24(fp)
  8076e0:	1885883a 	add	r2,r3,r2
  8076e4:	10800e04 	addi	r2,r2,56
  8076e8:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  8076ec:	e0bffa17 	ldw	r2,-24(fp)
  8076f0:	10800a17 	ldw	r2,40(r2)
  8076f4:	10800044 	addi	r2,r2,1
  8076f8:	10c1ffcc 	andi	r3,r2,2047
  8076fc:	e0bffa17 	ldw	r2,-24(fp)
  807700:	10c00a15 	stw	r3,40(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
  807704:	003fe206 	br	807690 <__alt_mem_onchip_memory2_0+0xff787690>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
  807708:	0001883a 	nop
  80770c:	00000106 	br	807714 <altera_avalon_jtag_uart_irq+0xdc>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
  807710:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
  807714:	e0bff817 	ldw	r2,-32(fp)
  807718:	10bfffec 	andhi	r2,r2,65535
  80771c:	10000f26 	beq	r2,zero,80775c <altera_avalon_jtag_uart_irq+0x124>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  807720:	e0bffa17 	ldw	r2,-24(fp)
  807724:	10c00817 	ldw	r3,32(r2)
  807728:	00bfff84 	movi	r2,-2
  80772c:	1886703a 	and	r3,r3,r2
  807730:	e0bffa17 	ldw	r2,-24(fp)
  807734:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
  807738:	e0bffb17 	ldw	r2,-20(fp)
  80773c:	10800104 	addi	r2,r2,4
  807740:	1007883a 	mov	r3,r2
  807744:	e0bffa17 	ldw	r2,-24(fp)
  807748:	10800817 	ldw	r2,32(r2)
  80774c:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  807750:	e0bffb17 	ldw	r2,-20(fp)
  807754:	10800104 	addi	r2,r2,4
  807758:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
  80775c:	e0bffc17 	ldw	r2,-16(fp)
  807760:	1080800c 	andi	r2,r2,512
  807764:	103fbe26 	beq	r2,zero,807660 <__alt_mem_onchip_memory2_0+0xff787660>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
  807768:	e0bffc17 	ldw	r2,-16(fp)
  80776c:	1004d43a 	srli	r2,r2,16
  807770:	e0bff915 	stw	r2,-28(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
  807774:	00001406 	br	8077c8 <altera_avalon_jtag_uart_irq+0x190>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
  807778:	e0bffb17 	ldw	r2,-20(fp)
  80777c:	e0fffa17 	ldw	r3,-24(fp)
  807780:	18c00d17 	ldw	r3,52(r3)
  807784:	e13ffa17 	ldw	r4,-24(fp)
  807788:	20c7883a 	add	r3,r4,r3
  80778c:	18c20e04 	addi	r3,r3,2104
  807790:	18c00003 	ldbu	r3,0(r3)
  807794:	18c03fcc 	andi	r3,r3,255
  807798:	18c0201c 	xori	r3,r3,128
  80779c:	18ffe004 	addi	r3,r3,-128
  8077a0:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  8077a4:	e0bffa17 	ldw	r2,-24(fp)
  8077a8:	10800d17 	ldw	r2,52(r2)
  8077ac:	10800044 	addi	r2,r2,1
  8077b0:	10c1ffcc 	andi	r3,r2,2047
  8077b4:	e0bffa17 	ldw	r2,-24(fp)
  8077b8:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
  8077bc:	e0bff917 	ldw	r2,-28(fp)
  8077c0:	10bfffc4 	addi	r2,r2,-1
  8077c4:	e0bff915 	stw	r2,-28(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
  8077c8:	e0bff917 	ldw	r2,-28(fp)
  8077cc:	10000526 	beq	r2,zero,8077e4 <altera_avalon_jtag_uart_irq+0x1ac>
  8077d0:	e0bffa17 	ldw	r2,-24(fp)
  8077d4:	10c00d17 	ldw	r3,52(r2)
  8077d8:	e0bffa17 	ldw	r2,-24(fp)
  8077dc:	10800c17 	ldw	r2,48(r2)
  8077e0:	18bfe51e 	bne	r3,r2,807778 <__alt_mem_onchip_memory2_0+0xff787778>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
  8077e4:	e0bff917 	ldw	r2,-28(fp)
  8077e8:	103f9d26 	beq	r2,zero,807660 <__alt_mem_onchip_memory2_0+0xff787660>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
  8077ec:	e0bffa17 	ldw	r2,-24(fp)
  8077f0:	10c00817 	ldw	r3,32(r2)
  8077f4:	00bfff44 	movi	r2,-3
  8077f8:	1886703a 	and	r3,r3,r2
  8077fc:	e0bffa17 	ldw	r2,-24(fp)
  807800:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  807804:	e0bffa17 	ldw	r2,-24(fp)
  807808:	10800017 	ldw	r2,0(r2)
  80780c:	10800104 	addi	r2,r2,4
  807810:	1007883a 	mov	r3,r2
  807814:	e0bffa17 	ldw	r2,-24(fp)
  807818:	10800817 	ldw	r2,32(r2)
  80781c:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  807820:	e0bffb17 	ldw	r2,-20(fp)
  807824:	10800104 	addi	r2,r2,4
  807828:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
  80782c:	003f8c06 	br	807660 <__alt_mem_onchip_memory2_0+0xff787660>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
  807830:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
  807834:	0001883a 	nop
  807838:	e037883a 	mov	sp,fp
  80783c:	df000017 	ldw	fp,0(sp)
  807840:	dec00104 	addi	sp,sp,4
  807844:	f800283a 	ret

00807848 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
  807848:	defff804 	addi	sp,sp,-32
  80784c:	df000715 	stw	fp,28(sp)
  807850:	df000704 	addi	fp,sp,28
  807854:	e13ffb15 	stw	r4,-20(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
  807858:	e0bffb17 	ldw	r2,-20(fp)
  80785c:	e0bff915 	stw	r2,-28(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
  807860:	e0bff917 	ldw	r2,-28(fp)
  807864:	10800017 	ldw	r2,0(r2)
  807868:	10800104 	addi	r2,r2,4
  80786c:	10800037 	ldwio	r2,0(r2)
  807870:	e0bffa15 	stw	r2,-24(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
  807874:	e0bffa17 	ldw	r2,-24(fp)
  807878:	1081000c 	andi	r2,r2,1024
  80787c:	10000b26 	beq	r2,zero,8078ac <altera_avalon_jtag_uart_timeout+0x64>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
  807880:	e0bff917 	ldw	r2,-28(fp)
  807884:	10800017 	ldw	r2,0(r2)
  807888:	10800104 	addi	r2,r2,4
  80788c:	1007883a 	mov	r3,r2
  807890:	e0bff917 	ldw	r2,-28(fp)
  807894:	10800817 	ldw	r2,32(r2)
  807898:	10810014 	ori	r2,r2,1024
  80789c:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
  8078a0:	e0bff917 	ldw	r2,-28(fp)
  8078a4:	10000915 	stw	zero,36(r2)
  8078a8:	00000a06 	br	8078d4 <altera_avalon_jtag_uart_timeout+0x8c>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
  8078ac:	e0bff917 	ldw	r2,-28(fp)
  8078b0:	10c00917 	ldw	r3,36(r2)
  8078b4:	00a00034 	movhi	r2,32768
  8078b8:	10bfff04 	addi	r2,r2,-4
  8078bc:	10c00536 	bltu	r2,r3,8078d4 <altera_avalon_jtag_uart_timeout+0x8c>
    sp->host_inactive++;
  8078c0:	e0bff917 	ldw	r2,-28(fp)
  8078c4:	10800917 	ldw	r2,36(r2)
  8078c8:	10c00044 	addi	r3,r2,1
  8078cc:	e0bff917 	ldw	r2,-28(fp)
  8078d0:	10c00915 	stw	r3,36(r2)
  8078d4:	00802074 	movhi	r2,129
  8078d8:	10ad6604 	addi	r2,r2,-19048
  8078dc:	10800017 	ldw	r2,0(r2)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
  8078e0:	e037883a 	mov	sp,fp
  8078e4:	df000017 	ldw	fp,0(sp)
  8078e8:	dec00104 	addi	sp,sp,4
  8078ec:	f800283a 	ret

008078f0 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
  8078f0:	defffd04 	addi	sp,sp,-12
  8078f4:	df000215 	stw	fp,8(sp)
  8078f8:	df000204 	addi	fp,sp,8
  8078fc:	e13ffe15 	stw	r4,-8(fp)
  807900:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
  807904:	00000506 	br	80791c <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
  807908:	e0bfff17 	ldw	r2,-4(fp)
  80790c:	1090000c 	andi	r2,r2,16384
  807910:	10000226 	beq	r2,zero,80791c <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
  807914:	00bffd44 	movi	r2,-11
  807918:	00000b06 	br	807948 <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
  80791c:	e0bffe17 	ldw	r2,-8(fp)
  807920:	10c00d17 	ldw	r3,52(r2)
  807924:	e0bffe17 	ldw	r2,-8(fp)
  807928:	10800c17 	ldw	r2,48(r2)
  80792c:	18800526 	beq	r3,r2,807944 <altera_avalon_jtag_uart_close+0x54>
  807930:	e0bffe17 	ldw	r2,-8(fp)
  807934:	10c00917 	ldw	r3,36(r2)
  807938:	e0bffe17 	ldw	r2,-8(fp)
  80793c:	10800117 	ldw	r2,4(r2)
  807940:	18bff136 	bltu	r3,r2,807908 <__alt_mem_onchip_memory2_0+0xff787908>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
  807944:	0005883a 	mov	r2,zero
}
  807948:	e037883a 	mov	sp,fp
  80794c:	df000017 	ldw	fp,0(sp)
  807950:	dec00104 	addi	sp,sp,4
  807954:	f800283a 	ret

00807958 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
  807958:	defffa04 	addi	sp,sp,-24
  80795c:	df000515 	stw	fp,20(sp)
  807960:	df000504 	addi	fp,sp,20
  807964:	e13ffd15 	stw	r4,-12(fp)
  807968:	e17ffe15 	stw	r5,-8(fp)
  80796c:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
  807970:	00bff9c4 	movi	r2,-25
  807974:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
  807978:	e0bffe17 	ldw	r2,-8(fp)
  80797c:	10da8060 	cmpeqi	r3,r2,27137
  807980:	1800031e 	bne	r3,zero,807990 <altera_avalon_jtag_uart_ioctl+0x38>
  807984:	109a80a0 	cmpeqi	r2,r2,27138
  807988:	1000181e 	bne	r2,zero,8079ec <altera_avalon_jtag_uart_ioctl+0x94>
      rc = 0;
    }
    break;

  default:
    break;
  80798c:	00002906 	br	807a34 <altera_avalon_jtag_uart_ioctl+0xdc>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
  807990:	e0bffd17 	ldw	r2,-12(fp)
  807994:	10c00117 	ldw	r3,4(r2)
  807998:	00a00034 	movhi	r2,32768
  80799c:	10bfffc4 	addi	r2,r2,-1
  8079a0:	18802126 	beq	r3,r2,807a28 <altera_avalon_jtag_uart_ioctl+0xd0>
    {
      int timeout = *((int *)arg);
  8079a4:	e0bfff17 	ldw	r2,-4(fp)
  8079a8:	10800017 	ldw	r2,0(r2)
  8079ac:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
  8079b0:	e0bffc17 	ldw	r2,-16(fp)
  8079b4:	10800090 	cmplti	r2,r2,2
  8079b8:	1000061e 	bne	r2,zero,8079d4 <altera_avalon_jtag_uart_ioctl+0x7c>
  8079bc:	e0fffc17 	ldw	r3,-16(fp)
  8079c0:	00a00034 	movhi	r2,32768
  8079c4:	10bfffc4 	addi	r2,r2,-1
  8079c8:	18800226 	beq	r3,r2,8079d4 <altera_avalon_jtag_uart_ioctl+0x7c>
  8079cc:	e0bffc17 	ldw	r2,-16(fp)
  8079d0:	00000206 	br	8079dc <altera_avalon_jtag_uart_ioctl+0x84>
  8079d4:	00a00034 	movhi	r2,32768
  8079d8:	10bfff84 	addi	r2,r2,-2
  8079dc:	e0fffd17 	ldw	r3,-12(fp)
  8079e0:	18800115 	stw	r2,4(r3)
      rc = 0;
  8079e4:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
  8079e8:	00000f06 	br	807a28 <altera_avalon_jtag_uart_ioctl+0xd0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
  8079ec:	e0bffd17 	ldw	r2,-12(fp)
  8079f0:	10c00117 	ldw	r3,4(r2)
  8079f4:	00a00034 	movhi	r2,32768
  8079f8:	10bfffc4 	addi	r2,r2,-1
  8079fc:	18800c26 	beq	r3,r2,807a30 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
  807a00:	e0bffd17 	ldw	r2,-12(fp)
  807a04:	10c00917 	ldw	r3,36(r2)
  807a08:	e0bffd17 	ldw	r2,-12(fp)
  807a0c:	10800117 	ldw	r2,4(r2)
  807a10:	1885803a 	cmpltu	r2,r3,r2
  807a14:	10c03fcc 	andi	r3,r2,255
  807a18:	e0bfff17 	ldw	r2,-4(fp)
  807a1c:	10c00015 	stw	r3,0(r2)
      rc = 0;
  807a20:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
  807a24:	00000206 	br	807a30 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
  807a28:	0001883a 	nop
  807a2c:	00000106 	br	807a34 <altera_avalon_jtag_uart_ioctl+0xdc>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
  807a30:	0001883a 	nop

  default:
    break;
  }

  return rc;
  807a34:	e0bffb17 	ldw	r2,-20(fp)
}
  807a38:	e037883a 	mov	sp,fp
  807a3c:	df000017 	ldw	fp,0(sp)
  807a40:	dec00104 	addi	sp,sp,4
  807a44:	f800283a 	ret

00807a48 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
  807a48:	defff304 	addi	sp,sp,-52
  807a4c:	dfc00c15 	stw	ra,48(sp)
  807a50:	df000b15 	stw	fp,44(sp)
  807a54:	df000b04 	addi	fp,sp,44
  807a58:	e13ffc15 	stw	r4,-16(fp)
  807a5c:	e17ffd15 	stw	r5,-12(fp)
  807a60:	e1bffe15 	stw	r6,-8(fp)
  807a64:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
  807a68:	e0bffd17 	ldw	r2,-12(fp)
  807a6c:	e0bff515 	stw	r2,-44(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
  807a70:	00004706 	br	807b90 <altera_avalon_jtag_uart_read+0x148>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
  807a74:	e0bffc17 	ldw	r2,-16(fp)
  807a78:	10800a17 	ldw	r2,40(r2)
  807a7c:	e0bff715 	stw	r2,-36(fp)
      out = sp->rx_out;
  807a80:	e0bffc17 	ldw	r2,-16(fp)
  807a84:	10800b17 	ldw	r2,44(r2)
  807a88:	e0bff815 	stw	r2,-32(fp)

      if (in >= out)
  807a8c:	e0fff717 	ldw	r3,-36(fp)
  807a90:	e0bff817 	ldw	r2,-32(fp)
  807a94:	18800536 	bltu	r3,r2,807aac <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
  807a98:	e0fff717 	ldw	r3,-36(fp)
  807a9c:	e0bff817 	ldw	r2,-32(fp)
  807aa0:	1885c83a 	sub	r2,r3,r2
  807aa4:	e0bff615 	stw	r2,-40(fp)
  807aa8:	00000406 	br	807abc <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
  807aac:	00c20004 	movi	r3,2048
  807ab0:	e0bff817 	ldw	r2,-32(fp)
  807ab4:	1885c83a 	sub	r2,r3,r2
  807ab8:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
  807abc:	e0bff617 	ldw	r2,-40(fp)
  807ac0:	10001e26 	beq	r2,zero,807b3c <altera_avalon_jtag_uart_read+0xf4>
        break; /* No more data available */

      if (n > space)
  807ac4:	e0fffe17 	ldw	r3,-8(fp)
  807ac8:	e0bff617 	ldw	r2,-40(fp)
  807acc:	1880022e 	bgeu	r3,r2,807ad8 <altera_avalon_jtag_uart_read+0x90>
        n = space;
  807ad0:	e0bffe17 	ldw	r2,-8(fp)
  807ad4:	e0bff615 	stw	r2,-40(fp)

      memcpy(ptr, sp->rx_buf + out, n);
  807ad8:	e0bffc17 	ldw	r2,-16(fp)
  807adc:	10c00e04 	addi	r3,r2,56
  807ae0:	e0bff817 	ldw	r2,-32(fp)
  807ae4:	1885883a 	add	r2,r3,r2
  807ae8:	e1bff617 	ldw	r6,-40(fp)
  807aec:	100b883a 	mov	r5,r2
  807af0:	e13ff517 	ldw	r4,-44(fp)
  807af4:	08065900 	call	806590 <memcpy>
      ptr   += n;
  807af8:	e0fff517 	ldw	r3,-44(fp)
  807afc:	e0bff617 	ldw	r2,-40(fp)
  807b00:	1885883a 	add	r2,r3,r2
  807b04:	e0bff515 	stw	r2,-44(fp)
      space -= n;
  807b08:	e0fffe17 	ldw	r3,-8(fp)
  807b0c:	e0bff617 	ldw	r2,-40(fp)
  807b10:	1885c83a 	sub	r2,r3,r2
  807b14:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  807b18:	e0fff817 	ldw	r3,-32(fp)
  807b1c:	e0bff617 	ldw	r2,-40(fp)
  807b20:	1885883a 	add	r2,r3,r2
  807b24:	10c1ffcc 	andi	r3,r2,2047
  807b28:	e0bffc17 	ldw	r2,-16(fp)
  807b2c:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
  807b30:	e0bffe17 	ldw	r2,-8(fp)
  807b34:	00bfcf16 	blt	zero,r2,807a74 <__alt_mem_onchip_memory2_0+0xff787a74>
  807b38:	00000106 	br	807b40 <altera_avalon_jtag_uart_read+0xf8>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
  807b3c:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
  807b40:	e0fff517 	ldw	r3,-44(fp)
  807b44:	e0bffd17 	ldw	r2,-12(fp)
  807b48:	1880141e 	bne	r3,r2,807b9c <altera_avalon_jtag_uart_read+0x154>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
  807b4c:	e0bfff17 	ldw	r2,-4(fp)
  807b50:	1090000c 	andi	r2,r2,16384
  807b54:	1000131e 	bne	r2,zero,807ba4 <altera_avalon_jtag_uart_read+0x15c>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
  807b58:	0001883a 	nop
  807b5c:	e0bffc17 	ldw	r2,-16(fp)
  807b60:	10c00a17 	ldw	r3,40(r2)
  807b64:	e0bff717 	ldw	r2,-36(fp)
  807b68:	1880051e 	bne	r3,r2,807b80 <altera_avalon_jtag_uart_read+0x138>
  807b6c:	e0bffc17 	ldw	r2,-16(fp)
  807b70:	10c00917 	ldw	r3,36(r2)
  807b74:	e0bffc17 	ldw	r2,-16(fp)
  807b78:	10800117 	ldw	r2,4(r2)
  807b7c:	18bff736 	bltu	r3,r2,807b5c <__alt_mem_onchip_memory2_0+0xff787b5c>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
  807b80:	e0bffc17 	ldw	r2,-16(fp)
  807b84:	10c00a17 	ldw	r3,40(r2)
  807b88:	e0bff717 	ldw	r2,-36(fp)
  807b8c:	18800726 	beq	r3,r2,807bac <altera_avalon_jtag_uart_read+0x164>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
  807b90:	e0bffe17 	ldw	r2,-8(fp)
  807b94:	00bfb716 	blt	zero,r2,807a74 <__alt_mem_onchip_memory2_0+0xff787a74>
  807b98:	00000506 	br	807bb0 <altera_avalon_jtag_uart_read+0x168>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
  807b9c:	0001883a 	nop
  807ba0:	00000306 	br	807bb0 <altera_avalon_jtag_uart_read+0x168>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
  807ba4:	0001883a 	nop
  807ba8:	00000106 	br	807bb0 <altera_avalon_jtag_uart_read+0x168>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
  807bac:	0001883a 	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
  807bb0:	e0fff517 	ldw	r3,-44(fp)
  807bb4:	e0bffd17 	ldw	r2,-12(fp)
  807bb8:	18801826 	beq	r3,r2,807c1c <altera_avalon_jtag_uart_read+0x1d4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  807bbc:	0005303a 	rdctl	r2,status
  807bc0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  807bc4:	e0fffb17 	ldw	r3,-20(fp)
  807bc8:	00bfff84 	movi	r2,-2
  807bcc:	1884703a 	and	r2,r3,r2
  807bd0:	1001703a 	wrctl	status,r2
  
  return context;
  807bd4:	e0bffb17 	ldw	r2,-20(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
  807bd8:	e0bffa15 	stw	r2,-24(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  807bdc:	e0bffc17 	ldw	r2,-16(fp)
  807be0:	10800817 	ldw	r2,32(r2)
  807be4:	10c00054 	ori	r3,r2,1
  807be8:	e0bffc17 	ldw	r2,-16(fp)
  807bec:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  807bf0:	e0bffc17 	ldw	r2,-16(fp)
  807bf4:	10800017 	ldw	r2,0(r2)
  807bf8:	10800104 	addi	r2,r2,4
  807bfc:	1007883a 	mov	r3,r2
  807c00:	e0bffc17 	ldw	r2,-16(fp)
  807c04:	10800817 	ldw	r2,32(r2)
  807c08:	18800035 	stwio	r2,0(r3)
  807c0c:	e0bffa17 	ldw	r2,-24(fp)
  807c10:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  807c14:	e0bff917 	ldw	r2,-28(fp)
  807c18:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
  807c1c:	e0fff517 	ldw	r3,-44(fp)
  807c20:	e0bffd17 	ldw	r2,-12(fp)
  807c24:	18800426 	beq	r3,r2,807c38 <altera_avalon_jtag_uart_read+0x1f0>
    return ptr - buffer;
  807c28:	e0fff517 	ldw	r3,-44(fp)
  807c2c:	e0bffd17 	ldw	r2,-12(fp)
  807c30:	1885c83a 	sub	r2,r3,r2
  807c34:	00000606 	br	807c50 <altera_avalon_jtag_uart_read+0x208>
  else if (flags & O_NONBLOCK)
  807c38:	e0bfff17 	ldw	r2,-4(fp)
  807c3c:	1090000c 	andi	r2,r2,16384
  807c40:	10000226 	beq	r2,zero,807c4c <altera_avalon_jtag_uart_read+0x204>
    return -EWOULDBLOCK;
  807c44:	00bffd44 	movi	r2,-11
  807c48:	00000106 	br	807c50 <altera_avalon_jtag_uart_read+0x208>
  else
    return -EIO;
  807c4c:	00bffec4 	movi	r2,-5
}
  807c50:	e037883a 	mov	sp,fp
  807c54:	dfc00117 	ldw	ra,4(sp)
  807c58:	df000017 	ldw	fp,0(sp)
  807c5c:	dec00204 	addi	sp,sp,8
  807c60:	f800283a 	ret

00807c64 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  807c64:	defff304 	addi	sp,sp,-52
  807c68:	dfc00c15 	stw	ra,48(sp)
  807c6c:	df000b15 	stw	fp,44(sp)
  807c70:	df000b04 	addi	fp,sp,44
  807c74:	e13ffc15 	stw	r4,-16(fp)
  807c78:	e17ffd15 	stw	r5,-12(fp)
  807c7c:	e1bffe15 	stw	r6,-8(fp)
  807c80:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
  807c84:	e03ff515 	stw	zero,-44(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
  807c88:	e0bffd17 	ldw	r2,-12(fp)
  807c8c:	e0bff715 	stw	r2,-36(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
  807c90:	00003706 	br	807d70 <altera_avalon_jtag_uart_write+0x10c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
  807c94:	e0bffc17 	ldw	r2,-16(fp)
  807c98:	10800c17 	ldw	r2,48(r2)
  807c9c:	e0bff915 	stw	r2,-28(fp)
      out = sp->tx_out;
  807ca0:	e0bffc17 	ldw	r2,-16(fp)
  807ca4:	10800d17 	ldw	r2,52(r2)
  807ca8:	e0bff515 	stw	r2,-44(fp)

      if (in < out)
  807cac:	e0fff917 	ldw	r3,-28(fp)
  807cb0:	e0bff517 	ldw	r2,-44(fp)
  807cb4:	1880062e 	bgeu	r3,r2,807cd0 <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
  807cb8:	e0fff517 	ldw	r3,-44(fp)
  807cbc:	e0bff917 	ldw	r2,-28(fp)
  807cc0:	1885c83a 	sub	r2,r3,r2
  807cc4:	10bfffc4 	addi	r2,r2,-1
  807cc8:	e0bff615 	stw	r2,-40(fp)
  807ccc:	00000b06 	br	807cfc <altera_avalon_jtag_uart_write+0x98>
      else if (out > 0)
  807cd0:	e0bff517 	ldw	r2,-44(fp)
  807cd4:	10000526 	beq	r2,zero,807cec <altera_avalon_jtag_uart_write+0x88>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
  807cd8:	00c20004 	movi	r3,2048
  807cdc:	e0bff917 	ldw	r2,-28(fp)
  807ce0:	1885c83a 	sub	r2,r3,r2
  807ce4:	e0bff615 	stw	r2,-40(fp)
  807ce8:	00000406 	br	807cfc <altera_avalon_jtag_uart_write+0x98>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
  807cec:	00c1ffc4 	movi	r3,2047
  807cf0:	e0bff917 	ldw	r2,-28(fp)
  807cf4:	1885c83a 	sub	r2,r3,r2
  807cf8:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
  807cfc:	e0bff617 	ldw	r2,-40(fp)
  807d00:	10001e26 	beq	r2,zero,807d7c <altera_avalon_jtag_uart_write+0x118>
        break;

      if (n > count)
  807d04:	e0fffe17 	ldw	r3,-8(fp)
  807d08:	e0bff617 	ldw	r2,-40(fp)
  807d0c:	1880022e 	bgeu	r3,r2,807d18 <altera_avalon_jtag_uart_write+0xb4>
        n = count;
  807d10:	e0bffe17 	ldw	r2,-8(fp)
  807d14:	e0bff615 	stw	r2,-40(fp)

      memcpy(sp->tx_buf + in, ptr, n);
  807d18:	e0bffc17 	ldw	r2,-16(fp)
  807d1c:	10c20e04 	addi	r3,r2,2104
  807d20:	e0bff917 	ldw	r2,-28(fp)
  807d24:	1885883a 	add	r2,r3,r2
  807d28:	e1bff617 	ldw	r6,-40(fp)
  807d2c:	e17ffd17 	ldw	r5,-12(fp)
  807d30:	1009883a 	mov	r4,r2
  807d34:	08065900 	call	806590 <memcpy>
      ptr   += n;
  807d38:	e0fffd17 	ldw	r3,-12(fp)
  807d3c:	e0bff617 	ldw	r2,-40(fp)
  807d40:	1885883a 	add	r2,r3,r2
  807d44:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
  807d48:	e0fffe17 	ldw	r3,-8(fp)
  807d4c:	e0bff617 	ldw	r2,-40(fp)
  807d50:	1885c83a 	sub	r2,r3,r2
  807d54:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  807d58:	e0fff917 	ldw	r3,-28(fp)
  807d5c:	e0bff617 	ldw	r2,-40(fp)
  807d60:	1885883a 	add	r2,r3,r2
  807d64:	10c1ffcc 	andi	r3,r2,2047
  807d68:	e0bffc17 	ldw	r2,-16(fp)
  807d6c:	10c00c15 	stw	r3,48(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
  807d70:	e0bffe17 	ldw	r2,-8(fp)
  807d74:	00bfc716 	blt	zero,r2,807c94 <__alt_mem_onchip_memory2_0+0xff787c94>
  807d78:	00000106 	br	807d80 <altera_avalon_jtag_uart_write+0x11c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
  807d7c:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  807d80:	0005303a 	rdctl	r2,status
  807d84:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  807d88:	e0fffb17 	ldw	r3,-20(fp)
  807d8c:	00bfff84 	movi	r2,-2
  807d90:	1884703a 	and	r2,r3,r2
  807d94:	1001703a 	wrctl	status,r2
  
  return context;
  807d98:	e0bffb17 	ldw	r2,-20(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
  807d9c:	e0bffa15 	stw	r2,-24(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
  807da0:	e0bffc17 	ldw	r2,-16(fp)
  807da4:	10800817 	ldw	r2,32(r2)
  807da8:	10c00094 	ori	r3,r2,2
  807dac:	e0bffc17 	ldw	r2,-16(fp)
  807db0:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  807db4:	e0bffc17 	ldw	r2,-16(fp)
  807db8:	10800017 	ldw	r2,0(r2)
  807dbc:	10800104 	addi	r2,r2,4
  807dc0:	1007883a 	mov	r3,r2
  807dc4:	e0bffc17 	ldw	r2,-16(fp)
  807dc8:	10800817 	ldw	r2,32(r2)
  807dcc:	18800035 	stwio	r2,0(r3)
  807dd0:	e0bffa17 	ldw	r2,-24(fp)
  807dd4:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  807dd8:	e0bff817 	ldw	r2,-32(fp)
  807ddc:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
  807de0:	e0bffe17 	ldw	r2,-8(fp)
  807de4:	0080100e 	bge	zero,r2,807e28 <altera_avalon_jtag_uart_write+0x1c4>
    {
      if (flags & O_NONBLOCK)
  807de8:	e0bfff17 	ldw	r2,-4(fp)
  807dec:	1090000c 	andi	r2,r2,16384
  807df0:	1000101e 	bne	r2,zero,807e34 <altera_avalon_jtag_uart_write+0x1d0>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
  807df4:	0001883a 	nop
  807df8:	e0bffc17 	ldw	r2,-16(fp)
  807dfc:	10c00d17 	ldw	r3,52(r2)
  807e00:	e0bff517 	ldw	r2,-44(fp)
  807e04:	1880051e 	bne	r3,r2,807e1c <altera_avalon_jtag_uart_write+0x1b8>
  807e08:	e0bffc17 	ldw	r2,-16(fp)
  807e0c:	10c00917 	ldw	r3,36(r2)
  807e10:	e0bffc17 	ldw	r2,-16(fp)
  807e14:	10800117 	ldw	r2,4(r2)
  807e18:	18bff736 	bltu	r3,r2,807df8 <__alt_mem_onchip_memory2_0+0xff787df8>
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
  807e1c:	e0bffc17 	ldw	r2,-16(fp)
  807e20:	10800917 	ldw	r2,36(r2)
  807e24:	1000051e 	bne	r2,zero,807e3c <altera_avalon_jtag_uart_write+0x1d8>
         break;
    }
  }
  while (count > 0);
  807e28:	e0bffe17 	ldw	r2,-8(fp)
  807e2c:	00bfd016 	blt	zero,r2,807d70 <__alt_mem_onchip_memory2_0+0xff787d70>
  807e30:	00000306 	br	807e40 <altera_avalon_jtag_uart_write+0x1dc>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
  807e34:	0001883a 	nop
  807e38:	00000106 	br	807e40 <altera_avalon_jtag_uart_write+0x1dc>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
  807e3c:	0001883a 	nop
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
  807e40:	e0fffd17 	ldw	r3,-12(fp)
  807e44:	e0bff717 	ldw	r2,-36(fp)
  807e48:	18800426 	beq	r3,r2,807e5c <altera_avalon_jtag_uart_write+0x1f8>
    return ptr - start;
  807e4c:	e0fffd17 	ldw	r3,-12(fp)
  807e50:	e0bff717 	ldw	r2,-36(fp)
  807e54:	1885c83a 	sub	r2,r3,r2
  807e58:	00000606 	br	807e74 <altera_avalon_jtag_uart_write+0x210>
  else if (flags & O_NONBLOCK)
  807e5c:	e0bfff17 	ldw	r2,-4(fp)
  807e60:	1090000c 	andi	r2,r2,16384
  807e64:	10000226 	beq	r2,zero,807e70 <altera_avalon_jtag_uart_write+0x20c>
    return -EWOULDBLOCK;
  807e68:	00bffd44 	movi	r2,-11
  807e6c:	00000106 	br	807e74 <altera_avalon_jtag_uart_write+0x210>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
  807e70:	00bffec4 	movi	r2,-5
}
  807e74:	e037883a 	mov	sp,fp
  807e78:	dfc00117 	ldw	ra,4(sp)
  807e7c:	df000017 	ldw	fp,0(sp)
  807e80:	dec00204 	addi	sp,sp,8
  807e84:	f800283a 	ret

00807e88 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
  807e88:	defff504 	addi	sp,sp,-44
  807e8c:	df000a15 	stw	fp,40(sp)
  807e90:	df000a04 	addi	fp,sp,40
  807e94:	e13ffc15 	stw	r4,-16(fp)
  807e98:	e17ffd15 	stw	r5,-12(fp)
  807e9c:	e1bffe15 	stw	r6,-8(fp)
  807ea0:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
  807ea4:	e03ff615 	stw	zero,-40(fp)
  807ea8:	00802074 	movhi	r2,129
  807eac:	10ad6604 	addi	r2,r2,-19048
  807eb0:	10800017 	ldw	r2,0(r2)
  
  if (alt_ticks_per_second ())
  807eb4:	10003f26 	beq	r2,zero,807fb4 <alt_alarm_start+0x12c>
  {
    if (alarm)
  807eb8:	e0bffc17 	ldw	r2,-16(fp)
  807ebc:	10003b26 	beq	r2,zero,807fac <alt_alarm_start+0x124>
    {
      alarm->callback = callback;
  807ec0:	e0bffc17 	ldw	r2,-16(fp)
  807ec4:	e0fffe17 	ldw	r3,-8(fp)
  807ec8:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
  807ecc:	e0bffc17 	ldw	r2,-16(fp)
  807ed0:	e0ffff17 	ldw	r3,-4(fp)
  807ed4:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  807ed8:	0005303a 	rdctl	r2,status
  807edc:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  807ee0:	e0fff917 	ldw	r3,-28(fp)
  807ee4:	00bfff84 	movi	r2,-2
  807ee8:	1884703a 	and	r2,r3,r2
  807eec:	1001703a 	wrctl	status,r2
  
  return context;
  807ef0:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
  807ef4:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
  807ef8:	00802074 	movhi	r2,129
  807efc:	10ad6704 	addi	r2,r2,-19044
  807f00:	10800017 	ldw	r2,0(r2)
      
      current_nticks = alt_nticks();
  807f04:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
  807f08:	e0fffd17 	ldw	r3,-12(fp)
  807f0c:	e0bff617 	ldw	r2,-40(fp)
  807f10:	1885883a 	add	r2,r3,r2
  807f14:	10c00044 	addi	r3,r2,1
  807f18:	e0bffc17 	ldw	r2,-16(fp)
  807f1c:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
  807f20:	e0bffc17 	ldw	r2,-16(fp)
  807f24:	10c00217 	ldw	r3,8(r2)
  807f28:	e0bff617 	ldw	r2,-40(fp)
  807f2c:	1880042e 	bgeu	r3,r2,807f40 <alt_alarm_start+0xb8>
      {
        alarm->rollover = 1;
  807f30:	e0bffc17 	ldw	r2,-16(fp)
  807f34:	00c00044 	movi	r3,1
  807f38:	10c00405 	stb	r3,16(r2)
  807f3c:	00000206 	br	807f48 <alt_alarm_start+0xc0>
      }
      else
      {
        alarm->rollover = 0;
  807f40:	e0bffc17 	ldw	r2,-16(fp)
  807f44:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
  807f48:	e0fffc17 	ldw	r3,-16(fp)
  807f4c:	00802074 	movhi	r2,129
  807f50:	10a88504 	addi	r2,r2,-24044
  807f54:	e0bffa15 	stw	r2,-24(fp)
  807f58:	e0fffb15 	stw	r3,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  807f5c:	e0bffb17 	ldw	r2,-20(fp)
  807f60:	e0fffa17 	ldw	r3,-24(fp)
  807f64:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
  807f68:	e0bffa17 	ldw	r2,-24(fp)
  807f6c:	10c00017 	ldw	r3,0(r2)
  807f70:	e0bffb17 	ldw	r2,-20(fp)
  807f74:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
  807f78:	e0bffa17 	ldw	r2,-24(fp)
  807f7c:	10800017 	ldw	r2,0(r2)
  807f80:	e0fffb17 	ldw	r3,-20(fp)
  807f84:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
  807f88:	e0bffa17 	ldw	r2,-24(fp)
  807f8c:	e0fffb17 	ldw	r3,-20(fp)
  807f90:	10c00015 	stw	r3,0(r2)
  807f94:	e0bff817 	ldw	r2,-32(fp)
  807f98:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  807f9c:	e0bff717 	ldw	r2,-36(fp)
  807fa0:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
  807fa4:	0005883a 	mov	r2,zero
  807fa8:	00000306 	br	807fb8 <alt_alarm_start+0x130>
    }
    else
    {
      return -EINVAL;
  807fac:	00bffa84 	movi	r2,-22
  807fb0:	00000106 	br	807fb8 <alt_alarm_start+0x130>
    }
  }
  else
  {
    return -ENOTSUP;
  807fb4:	00bfde84 	movi	r2,-134
  }
}
  807fb8:	e037883a 	mov	sp,fp
  807fbc:	df000017 	ldw	fp,0(sp)
  807fc0:	dec00104 	addi	sp,sp,4
  807fc4:	f800283a 	ret

00807fc8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  807fc8:	defffe04 	addi	sp,sp,-8
  807fcc:	dfc00115 	stw	ra,4(sp)
  807fd0:	df000015 	stw	fp,0(sp)
  807fd4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  807fd8:	00802074 	movhi	r2,129
  807fdc:	10a88404 	addi	r2,r2,-24048
  807fe0:	10800017 	ldw	r2,0(r2)
  807fe4:	10000526 	beq	r2,zero,807ffc <alt_get_errno+0x34>
  807fe8:	00802074 	movhi	r2,129
  807fec:	10a88404 	addi	r2,r2,-24048
  807ff0:	10800017 	ldw	r2,0(r2)
  807ff4:	103ee83a 	callr	r2
  807ff8:	00000206 	br	808004 <alt_get_errno+0x3c>
  807ffc:	00802074 	movhi	r2,129
  808000:	10ad6104 	addi	r2,r2,-19068
}
  808004:	e037883a 	mov	sp,fp
  808008:	dfc00117 	ldw	ra,4(sp)
  80800c:	df000017 	ldw	fp,0(sp)
  808010:	dec00204 	addi	sp,sp,8
  808014:	f800283a 	ret

00808018 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
  808018:	defffb04 	addi	sp,sp,-20
  80801c:	dfc00415 	stw	ra,16(sp)
  808020:	df000315 	stw	fp,12(sp)
  808024:	df000304 	addi	fp,sp,12
  808028:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
  80802c:	e0bfff17 	ldw	r2,-4(fp)
  808030:	10000616 	blt	r2,zero,80804c <close+0x34>
  808034:	e0bfff17 	ldw	r2,-4(fp)
  808038:	10c00324 	muli	r3,r2,12
  80803c:	00802074 	movhi	r2,129
  808040:	10a81c04 	addi	r2,r2,-24464
  808044:	1885883a 	add	r2,r3,r2
  808048:	00000106 	br	808050 <close+0x38>
  80804c:	0005883a 	mov	r2,zero
  808050:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
  808054:	e0bffd17 	ldw	r2,-12(fp)
  808058:	10001926 	beq	r2,zero,8080c0 <close+0xa8>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
  80805c:	e0bffd17 	ldw	r2,-12(fp)
  808060:	10800017 	ldw	r2,0(r2)
  808064:	10800417 	ldw	r2,16(r2)
  808068:	10000626 	beq	r2,zero,808084 <close+0x6c>
  80806c:	e0bffd17 	ldw	r2,-12(fp)
  808070:	10800017 	ldw	r2,0(r2)
  808074:	10800417 	ldw	r2,16(r2)
  808078:	e13ffd17 	ldw	r4,-12(fp)
  80807c:	103ee83a 	callr	r2
  808080:	00000106 	br	808088 <close+0x70>
  808084:	0005883a 	mov	r2,zero
  808088:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
  80808c:	e13fff17 	ldw	r4,-4(fp)
  808090:	08086380 	call	808638 <alt_release_fd>
    if (rval < 0)
  808094:	e0bffe17 	ldw	r2,-8(fp)
  808098:	1000070e 	bge	r2,zero,8080b8 <close+0xa0>
    {
      ALT_ERRNO = -rval;
  80809c:	0807fc80 	call	807fc8 <alt_get_errno>
  8080a0:	1007883a 	mov	r3,r2
  8080a4:	e0bffe17 	ldw	r2,-8(fp)
  8080a8:	0085c83a 	sub	r2,zero,r2
  8080ac:	18800015 	stw	r2,0(r3)
      return -1;
  8080b0:	00bfffc4 	movi	r2,-1
  8080b4:	00000706 	br	8080d4 <close+0xbc>
    }
    return 0;
  8080b8:	0005883a 	mov	r2,zero
  8080bc:	00000506 	br	8080d4 <close+0xbc>
  }
  else
  {
    ALT_ERRNO = EBADFD;
  8080c0:	0807fc80 	call	807fc8 <alt_get_errno>
  8080c4:	1007883a 	mov	r3,r2
  8080c8:	00801444 	movi	r2,81
  8080cc:	18800015 	stw	r2,0(r3)
    return -1;
  8080d0:	00bfffc4 	movi	r2,-1
  }
}
  8080d4:	e037883a 	mov	sp,fp
  8080d8:	dfc00117 	ldw	ra,4(sp)
  8080dc:	df000017 	ldw	fp,0(sp)
  8080e0:	dec00204 	addi	sp,sp,8
  8080e4:	f800283a 	ret

008080e8 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
  8080e8:	defffe04 	addi	sp,sp,-8
  8080ec:	df000115 	stw	fp,4(sp)
  8080f0:	df000104 	addi	fp,sp,4
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  8080f4:	e03fff15 	stw	zero,-4(fp)
  8080f8:	00000506 	br	808110 <alt_dcache_flush_all+0x28>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  8080fc:	e0bfff17 	ldw	r2,-4(fp)
  808100:	1000003b 	flushd	0(r2)
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  808104:	e0bfff17 	ldw	r2,-4(fp)
  808108:	10800804 	addi	r2,r2,32
  80810c:	e0bfff15 	stw	r2,-4(fp)
  808110:	e0bfff17 	ldw	r2,-4(fp)
  808114:	10820030 	cmpltui	r2,r2,2048
  808118:	103ff81e 	bne	r2,zero,8080fc <__alt_mem_onchip_memory2_0+0xff7880fc>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
  80811c:	0001883a 	nop
  808120:	e037883a 	mov	sp,fp
  808124:	df000017 	ldw	fp,0(sp)
  808128:	dec00104 	addi	sp,sp,4
  80812c:	f800283a 	ret

00808130 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
  808130:	defffc04 	addi	sp,sp,-16
  808134:	df000315 	stw	fp,12(sp)
  808138:	df000304 	addi	fp,sp,12
  80813c:	e13ffd15 	stw	r4,-12(fp)
  808140:	e17ffe15 	stw	r5,-8(fp)
  808144:	e1bfff15 	stw	r6,-4(fp)
  return len;
  808148:	e0bfff17 	ldw	r2,-4(fp)
}
  80814c:	e037883a 	mov	sp,fp
  808150:	df000017 	ldw	fp,0(sp)
  808154:	dec00104 	addi	sp,sp,4
  808158:	f800283a 	ret

0080815c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  80815c:	defffe04 	addi	sp,sp,-8
  808160:	dfc00115 	stw	ra,4(sp)
  808164:	df000015 	stw	fp,0(sp)
  808168:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  80816c:	00802074 	movhi	r2,129
  808170:	10a88404 	addi	r2,r2,-24048
  808174:	10800017 	ldw	r2,0(r2)
  808178:	10000526 	beq	r2,zero,808190 <alt_get_errno+0x34>
  80817c:	00802074 	movhi	r2,129
  808180:	10a88404 	addi	r2,r2,-24048
  808184:	10800017 	ldw	r2,0(r2)
  808188:	103ee83a 	callr	r2
  80818c:	00000206 	br	808198 <alt_get_errno+0x3c>
  808190:	00802074 	movhi	r2,129
  808194:	10ad6104 	addi	r2,r2,-19068
}
  808198:	e037883a 	mov	sp,fp
  80819c:	dfc00117 	ldw	ra,4(sp)
  8081a0:	df000017 	ldw	fp,0(sp)
  8081a4:	dec00204 	addi	sp,sp,8
  8081a8:	f800283a 	ret

008081ac <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
  8081ac:	defffa04 	addi	sp,sp,-24
  8081b0:	dfc00515 	stw	ra,20(sp)
  8081b4:	df000415 	stw	fp,16(sp)
  8081b8:	df000404 	addi	fp,sp,16
  8081bc:	e13ffe15 	stw	r4,-8(fp)
  8081c0:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  8081c4:	e0bffe17 	ldw	r2,-8(fp)
  8081c8:	10000326 	beq	r2,zero,8081d8 <alt_dev_llist_insert+0x2c>
  8081cc:	e0bffe17 	ldw	r2,-8(fp)
  8081d0:	10800217 	ldw	r2,8(r2)
  8081d4:	1000061e 	bne	r2,zero,8081f0 <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
  8081d8:	080815c0 	call	80815c <alt_get_errno>
  8081dc:	1007883a 	mov	r3,r2
  8081e0:	00800584 	movi	r2,22
  8081e4:	18800015 	stw	r2,0(r3)
    return -EINVAL;
  8081e8:	00bffa84 	movi	r2,-22
  8081ec:	00001306 	br	80823c <alt_dev_llist_insert+0x90>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
  8081f0:	e0bffe17 	ldw	r2,-8(fp)
  8081f4:	e0ffff17 	ldw	r3,-4(fp)
  8081f8:	e0fffc15 	stw	r3,-16(fp)
  8081fc:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  808200:	e0bffd17 	ldw	r2,-12(fp)
  808204:	e0fffc17 	ldw	r3,-16(fp)
  808208:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
  80820c:	e0bffc17 	ldw	r2,-16(fp)
  808210:	10c00017 	ldw	r3,0(r2)
  808214:	e0bffd17 	ldw	r2,-12(fp)
  808218:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
  80821c:	e0bffc17 	ldw	r2,-16(fp)
  808220:	10800017 	ldw	r2,0(r2)
  808224:	e0fffd17 	ldw	r3,-12(fp)
  808228:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
  80822c:	e0bffc17 	ldw	r2,-16(fp)
  808230:	e0fffd17 	ldw	r3,-12(fp)
  808234:	10c00015 	stw	r3,0(r2)

  return 0;  
  808238:	0005883a 	mov	r2,zero
}
  80823c:	e037883a 	mov	sp,fp
  808240:	dfc00117 	ldw	ra,4(sp)
  808244:	df000017 	ldw	fp,0(sp)
  808248:	dec00204 	addi	sp,sp,8
  80824c:	f800283a 	ret

00808250 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
  808250:	defffe04 	addi	sp,sp,-8
  808254:	dfc00115 	stw	ra,4(sp)
  808258:	df000015 	stw	fp,0(sp)
  80825c:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
  808260:	01440004 	movi	r5,4096
  808264:	0009883a 	mov	r4,zero
  808268:	0808abc0 	call	808abc <alt_icache_flush>
#endif
}
  80826c:	0001883a 	nop
  808270:	e037883a 	mov	sp,fp
  808274:	dfc00117 	ldw	ra,4(sp)
  808278:	df000017 	ldw	fp,0(sp)
  80827c:	dec00204 	addi	sp,sp,8
  808280:	f800283a 	ret

00808284 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
  808284:	defff904 	addi	sp,sp,-28
  808288:	dfc00615 	stw	ra,24(sp)
  80828c:	df000515 	stw	fp,20(sp)
  808290:	df000504 	addi	fp,sp,20
  808294:	e13ffc15 	stw	r4,-16(fp)
  808298:	e17ffd15 	stw	r5,-12(fp)
  80829c:	e1bffe15 	stw	r6,-8(fp)
  8082a0:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
  8082a4:	e1bfff17 	ldw	r6,-4(fp)
  8082a8:	e17ffe17 	ldw	r5,-8(fp)
  8082ac:	e13ffd17 	ldw	r4,-12(fp)
  8082b0:	08084e00 	call	8084e0 <open>
  8082b4:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
  8082b8:	e0bffb17 	ldw	r2,-20(fp)
  8082bc:	10001c16 	blt	r2,zero,808330 <alt_open_fd+0xac>
  {
    fd->dev      = alt_fd_list[old].dev;
  8082c0:	00802074 	movhi	r2,129
  8082c4:	10a81c04 	addi	r2,r2,-24464
  8082c8:	e0fffb17 	ldw	r3,-20(fp)
  8082cc:	18c00324 	muli	r3,r3,12
  8082d0:	10c5883a 	add	r2,r2,r3
  8082d4:	10c00017 	ldw	r3,0(r2)
  8082d8:	e0bffc17 	ldw	r2,-16(fp)
  8082dc:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
  8082e0:	00802074 	movhi	r2,129
  8082e4:	10a81c04 	addi	r2,r2,-24464
  8082e8:	e0fffb17 	ldw	r3,-20(fp)
  8082ec:	18c00324 	muli	r3,r3,12
  8082f0:	10c5883a 	add	r2,r2,r3
  8082f4:	10800104 	addi	r2,r2,4
  8082f8:	10c00017 	ldw	r3,0(r2)
  8082fc:	e0bffc17 	ldw	r2,-16(fp)
  808300:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
  808304:	00802074 	movhi	r2,129
  808308:	10a81c04 	addi	r2,r2,-24464
  80830c:	e0fffb17 	ldw	r3,-20(fp)
  808310:	18c00324 	muli	r3,r3,12
  808314:	10c5883a 	add	r2,r2,r3
  808318:	10800204 	addi	r2,r2,8
  80831c:	10c00017 	ldw	r3,0(r2)
  808320:	e0bffc17 	ldw	r2,-16(fp)
  808324:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
  808328:	e13ffb17 	ldw	r4,-20(fp)
  80832c:	08086380 	call	808638 <alt_release_fd>
  }
} 
  808330:	0001883a 	nop
  808334:	e037883a 	mov	sp,fp
  808338:	dfc00117 	ldw	ra,4(sp)
  80833c:	df000017 	ldw	fp,0(sp)
  808340:	dec00204 	addi	sp,sp,8
  808344:	f800283a 	ret

00808348 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
  808348:	defffb04 	addi	sp,sp,-20
  80834c:	dfc00415 	stw	ra,16(sp)
  808350:	df000315 	stw	fp,12(sp)
  808354:	df000304 	addi	fp,sp,12
  808358:	e13ffd15 	stw	r4,-12(fp)
  80835c:	e17ffe15 	stw	r5,-8(fp)
  808360:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
  808364:	01c07fc4 	movi	r7,511
  808368:	01800044 	movi	r6,1
  80836c:	e17ffd17 	ldw	r5,-12(fp)
  808370:	01002074 	movhi	r4,129
  808374:	21281f04 	addi	r4,r4,-24452
  808378:	08082840 	call	808284 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
  80837c:	01c07fc4 	movi	r7,511
  808380:	000d883a 	mov	r6,zero
  808384:	e17ffe17 	ldw	r5,-8(fp)
  808388:	01002074 	movhi	r4,129
  80838c:	21281c04 	addi	r4,r4,-24464
  808390:	08082840 	call	808284 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
  808394:	01c07fc4 	movi	r7,511
  808398:	01800044 	movi	r6,1
  80839c:	e17fff17 	ldw	r5,-4(fp)
  8083a0:	01002074 	movhi	r4,129
  8083a4:	21282204 	addi	r4,r4,-24440
  8083a8:	08082840 	call	808284 <alt_open_fd>
}  
  8083ac:	0001883a 	nop
  8083b0:	e037883a 	mov	sp,fp
  8083b4:	dfc00117 	ldw	ra,4(sp)
  8083b8:	df000017 	ldw	fp,0(sp)
  8083bc:	dec00204 	addi	sp,sp,8
  8083c0:	f800283a 	ret

008083c4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  8083c4:	defffe04 	addi	sp,sp,-8
  8083c8:	dfc00115 	stw	ra,4(sp)
  8083cc:	df000015 	stw	fp,0(sp)
  8083d0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  8083d4:	00802074 	movhi	r2,129
  8083d8:	10a88404 	addi	r2,r2,-24048
  8083dc:	10800017 	ldw	r2,0(r2)
  8083e0:	10000526 	beq	r2,zero,8083f8 <alt_get_errno+0x34>
  8083e4:	00802074 	movhi	r2,129
  8083e8:	10a88404 	addi	r2,r2,-24048
  8083ec:	10800017 	ldw	r2,0(r2)
  8083f0:	103ee83a 	callr	r2
  8083f4:	00000206 	br	808400 <alt_get_errno+0x3c>
  8083f8:	00802074 	movhi	r2,129
  8083fc:	10ad6104 	addi	r2,r2,-19068
}
  808400:	e037883a 	mov	sp,fp
  808404:	dfc00117 	ldw	ra,4(sp)
  808408:	df000017 	ldw	fp,0(sp)
  80840c:	dec00204 	addi	sp,sp,8
  808410:	f800283a 	ret

00808414 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
  808414:	defffd04 	addi	sp,sp,-12
  808418:	df000215 	stw	fp,8(sp)
  80841c:	df000204 	addi	fp,sp,8
  808420:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
  808424:	e0bfff17 	ldw	r2,-4(fp)
  808428:	10800217 	ldw	r2,8(r2)
  80842c:	10d00034 	orhi	r3,r2,16384
  808430:	e0bfff17 	ldw	r2,-4(fp)
  808434:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  808438:	e03ffe15 	stw	zero,-8(fp)
  80843c:	00001d06 	br	8084b4 <alt_file_locked+0xa0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
  808440:	00802074 	movhi	r2,129
  808444:	10a81c04 	addi	r2,r2,-24464
  808448:	e0fffe17 	ldw	r3,-8(fp)
  80844c:	18c00324 	muli	r3,r3,12
  808450:	10c5883a 	add	r2,r2,r3
  808454:	10c00017 	ldw	r3,0(r2)
  808458:	e0bfff17 	ldw	r2,-4(fp)
  80845c:	10800017 	ldw	r2,0(r2)
  808460:	1880111e 	bne	r3,r2,8084a8 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
  808464:	00802074 	movhi	r2,129
  808468:	10a81c04 	addi	r2,r2,-24464
  80846c:	e0fffe17 	ldw	r3,-8(fp)
  808470:	18c00324 	muli	r3,r3,12
  808474:	10c5883a 	add	r2,r2,r3
  808478:	10800204 	addi	r2,r2,8
  80847c:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
  808480:	1000090e 	bge	r2,zero,8084a8 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
  808484:	e0bffe17 	ldw	r2,-8(fp)
  808488:	10c00324 	muli	r3,r2,12
  80848c:	00802074 	movhi	r2,129
  808490:	10a81c04 	addi	r2,r2,-24464
  808494:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
  808498:	e0bfff17 	ldw	r2,-4(fp)
  80849c:	18800226 	beq	r3,r2,8084a8 <alt_file_locked+0x94>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
  8084a0:	00bffcc4 	movi	r2,-13
  8084a4:	00000a06 	br	8084d0 <alt_file_locked+0xbc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  8084a8:	e0bffe17 	ldw	r2,-8(fp)
  8084ac:	10800044 	addi	r2,r2,1
  8084b0:	e0bffe15 	stw	r2,-8(fp)
  8084b4:	00802074 	movhi	r2,129
  8084b8:	10a88304 	addi	r2,r2,-24052
  8084bc:	10800017 	ldw	r2,0(r2)
  8084c0:	1007883a 	mov	r3,r2
  8084c4:	e0bffe17 	ldw	r2,-8(fp)
  8084c8:	18bfdd2e 	bgeu	r3,r2,808440 <__alt_mem_onchip_memory2_0+0xff788440>
    }
  }
  
  /* The device is not locked */
 
  return 0;
  8084cc:	0005883a 	mov	r2,zero
}
  8084d0:	e037883a 	mov	sp,fp
  8084d4:	df000017 	ldw	fp,0(sp)
  8084d8:	dec00104 	addi	sp,sp,4
  8084dc:	f800283a 	ret

008084e0 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
  8084e0:	defff604 	addi	sp,sp,-40
  8084e4:	dfc00915 	stw	ra,36(sp)
  8084e8:	df000815 	stw	fp,32(sp)
  8084ec:	df000804 	addi	fp,sp,32
  8084f0:	e13ffd15 	stw	r4,-12(fp)
  8084f4:	e17ffe15 	stw	r5,-8(fp)
  8084f8:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
  8084fc:	00bfffc4 	movi	r2,-1
  808500:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
  808504:	00bffb44 	movi	r2,-19
  808508:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
  80850c:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
  808510:	01402074 	movhi	r5,129
  808514:	29688104 	addi	r5,r5,-24060
  808518:	e13ffd17 	ldw	r4,-12(fp)
  80851c:	08088640 	call	808864 <alt_find_dev>
  808520:	e0bff815 	stw	r2,-32(fp)
  808524:	e0bff817 	ldw	r2,-32(fp)
  808528:	1000051e 	bne	r2,zero,808540 <open+0x60>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
  80852c:	e13ffd17 	ldw	r4,-12(fp)
  808530:	08088f40 	call	8088f4 <alt_find_file>
  808534:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
  808538:	00800044 	movi	r2,1
  80853c:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
  808540:	e0bff817 	ldw	r2,-32(fp)
  808544:	10002926 	beq	r2,zero,8085ec <open+0x10c>
  {
    if ((index = alt_get_fd (dev)) < 0)
  808548:	e13ff817 	ldw	r4,-32(fp)
  80854c:	0808a080 	call	808a08 <alt_get_fd>
  808550:	e0bff915 	stw	r2,-28(fp)
  808554:	e0bff917 	ldw	r2,-28(fp)
  808558:	1000030e 	bge	r2,zero,808568 <open+0x88>
    {
      status = index;
  80855c:	e0bff917 	ldw	r2,-28(fp)
  808560:	e0bffa15 	stw	r2,-24(fp)
  808564:	00002306 	br	8085f4 <open+0x114>
    }
    else
    {
      fd = &alt_fd_list[index];
  808568:	e0bff917 	ldw	r2,-28(fp)
  80856c:	10c00324 	muli	r3,r2,12
  808570:	00802074 	movhi	r2,129
  808574:	10a81c04 	addi	r2,r2,-24464
  808578:	1885883a 	add	r2,r3,r2
  80857c:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
  808580:	e0fffe17 	ldw	r3,-8(fp)
  808584:	00900034 	movhi	r2,16384
  808588:	10bfffc4 	addi	r2,r2,-1
  80858c:	1886703a 	and	r3,r3,r2
  808590:	e0bffc17 	ldw	r2,-16(fp)
  808594:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
  808598:	e0bffb17 	ldw	r2,-20(fp)
  80859c:	1000051e 	bne	r2,zero,8085b4 <open+0xd4>
  8085a0:	e13ffc17 	ldw	r4,-16(fp)
  8085a4:	08084140 	call	808414 <alt_file_locked>
  8085a8:	e0bffa15 	stw	r2,-24(fp)
  8085ac:	e0bffa17 	ldw	r2,-24(fp)
  8085b0:	10001016 	blt	r2,zero,8085f4 <open+0x114>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
  8085b4:	e0bff817 	ldw	r2,-32(fp)
  8085b8:	10800317 	ldw	r2,12(r2)
  8085bc:	10000826 	beq	r2,zero,8085e0 <open+0x100>
  8085c0:	e0bff817 	ldw	r2,-32(fp)
  8085c4:	10800317 	ldw	r2,12(r2)
  8085c8:	e1ffff17 	ldw	r7,-4(fp)
  8085cc:	e1bffe17 	ldw	r6,-8(fp)
  8085d0:	e17ffd17 	ldw	r5,-12(fp)
  8085d4:	e13ffc17 	ldw	r4,-16(fp)
  8085d8:	103ee83a 	callr	r2
  8085dc:	00000106 	br	8085e4 <open+0x104>
  8085e0:	0005883a 	mov	r2,zero
  8085e4:	e0bffa15 	stw	r2,-24(fp)
  8085e8:	00000206 	br	8085f4 <open+0x114>
      }
    }
  }
  else
  {
    status = -ENODEV;
  8085ec:	00bffb44 	movi	r2,-19
  8085f0:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
  8085f4:	e0bffa17 	ldw	r2,-24(fp)
  8085f8:	1000090e 	bge	r2,zero,808620 <open+0x140>
  {
    alt_release_fd (index);  
  8085fc:	e13ff917 	ldw	r4,-28(fp)
  808600:	08086380 	call	808638 <alt_release_fd>
    ALT_ERRNO = -status;
  808604:	08083c40 	call	8083c4 <alt_get_errno>
  808608:	1007883a 	mov	r3,r2
  80860c:	e0bffa17 	ldw	r2,-24(fp)
  808610:	0085c83a 	sub	r2,zero,r2
  808614:	18800015 	stw	r2,0(r3)
    return -1;
  808618:	00bfffc4 	movi	r2,-1
  80861c:	00000106 	br	808624 <open+0x144>
  }
  
  /* return the reference upon success */

  return index;
  808620:	e0bff917 	ldw	r2,-28(fp)
}
  808624:	e037883a 	mov	sp,fp
  808628:	dfc00117 	ldw	ra,4(sp)
  80862c:	df000017 	ldw	fp,0(sp)
  808630:	dec00204 	addi	sp,sp,8
  808634:	f800283a 	ret

00808638 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
  808638:	defffe04 	addi	sp,sp,-8
  80863c:	df000115 	stw	fp,4(sp)
  808640:	df000104 	addi	fp,sp,4
  808644:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
  808648:	e0bfff17 	ldw	r2,-4(fp)
  80864c:	108000d0 	cmplti	r2,r2,3
  808650:	10000d1e 	bne	r2,zero,808688 <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
  808654:	00802074 	movhi	r2,129
  808658:	10a81c04 	addi	r2,r2,-24464
  80865c:	e0ffff17 	ldw	r3,-4(fp)
  808660:	18c00324 	muli	r3,r3,12
  808664:	10c5883a 	add	r2,r2,r3
  808668:	10800204 	addi	r2,r2,8
  80866c:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
  808670:	00802074 	movhi	r2,129
  808674:	10a81c04 	addi	r2,r2,-24464
  808678:	e0ffff17 	ldw	r3,-4(fp)
  80867c:	18c00324 	muli	r3,r3,12
  808680:	10c5883a 	add	r2,r2,r3
  808684:	10000015 	stw	zero,0(r2)
  }
}
  808688:	0001883a 	nop
  80868c:	e037883a 	mov	sp,fp
  808690:	df000017 	ldw	fp,0(sp)
  808694:	dec00104 	addi	sp,sp,4
  808698:	f800283a 	ret

0080869c <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
  80869c:	defffa04 	addi	sp,sp,-24
  8086a0:	df000515 	stw	fp,20(sp)
  8086a4:	df000504 	addi	fp,sp,20
  8086a8:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  8086ac:	0005303a 	rdctl	r2,status
  8086b0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  8086b4:	e0fffc17 	ldw	r3,-16(fp)
  8086b8:	00bfff84 	movi	r2,-2
  8086bc:	1884703a 	and	r2,r3,r2
  8086c0:	1001703a 	wrctl	status,r2
  
  return context;
  8086c4:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
  8086c8:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
  8086cc:	e0bfff17 	ldw	r2,-4(fp)
  8086d0:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
  8086d4:	e0bffd17 	ldw	r2,-12(fp)
  8086d8:	10800017 	ldw	r2,0(r2)
  8086dc:	e0fffd17 	ldw	r3,-12(fp)
  8086e0:	18c00117 	ldw	r3,4(r3)
  8086e4:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
  8086e8:	e0bffd17 	ldw	r2,-12(fp)
  8086ec:	10800117 	ldw	r2,4(r2)
  8086f0:	e0fffd17 	ldw	r3,-12(fp)
  8086f4:	18c00017 	ldw	r3,0(r3)
  8086f8:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
  8086fc:	e0bffd17 	ldw	r2,-12(fp)
  808700:	e0fffd17 	ldw	r3,-12(fp)
  808704:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
  808708:	e0bffd17 	ldw	r2,-12(fp)
  80870c:	e0fffd17 	ldw	r3,-12(fp)
  808710:	10c00015 	stw	r3,0(r2)
  808714:	e0bffb17 	ldw	r2,-20(fp)
  808718:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  80871c:	e0bffe17 	ldw	r2,-8(fp)
  808720:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
  808724:	0001883a 	nop
  808728:	e037883a 	mov	sp,fp
  80872c:	df000017 	ldw	fp,0(sp)
  808730:	dec00104 	addi	sp,sp,4
  808734:	f800283a 	ret

00808738 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
  808738:	defffb04 	addi	sp,sp,-20
  80873c:	dfc00415 	stw	ra,16(sp)
  808740:	df000315 	stw	fp,12(sp)
  808744:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
  808748:	d0a00917 	ldw	r2,-32732(gp)
  80874c:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
  808750:	d0a4eb17 	ldw	r2,-27732(gp)
  808754:	10800044 	addi	r2,r2,1
  808758:	d0a4eb15 	stw	r2,-27732(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  80875c:	00002e06 	br	808818 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
  808760:	e0bffd17 	ldw	r2,-12(fp)
  808764:	10800017 	ldw	r2,0(r2)
  808768:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
  80876c:	e0bffd17 	ldw	r2,-12(fp)
  808770:	10800403 	ldbu	r2,16(r2)
  808774:	10803fcc 	andi	r2,r2,255
  808778:	10000426 	beq	r2,zero,80878c <alt_tick+0x54>
  80877c:	d0a4eb17 	ldw	r2,-27732(gp)
  808780:	1000021e 	bne	r2,zero,80878c <alt_tick+0x54>
    {
      alarm->rollover = 0;
  808784:	e0bffd17 	ldw	r2,-12(fp)
  808788:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
  80878c:	e0bffd17 	ldw	r2,-12(fp)
  808790:	10800217 	ldw	r2,8(r2)
  808794:	d0e4eb17 	ldw	r3,-27732(gp)
  808798:	18801d36 	bltu	r3,r2,808810 <alt_tick+0xd8>
  80879c:	e0bffd17 	ldw	r2,-12(fp)
  8087a0:	10800403 	ldbu	r2,16(r2)
  8087a4:	10803fcc 	andi	r2,r2,255
  8087a8:	1000191e 	bne	r2,zero,808810 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
  8087ac:	e0bffd17 	ldw	r2,-12(fp)
  8087b0:	10800317 	ldw	r2,12(r2)
  8087b4:	e0fffd17 	ldw	r3,-12(fp)
  8087b8:	18c00517 	ldw	r3,20(r3)
  8087bc:	1809883a 	mov	r4,r3
  8087c0:	103ee83a 	callr	r2
  8087c4:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
  8087c8:	e0bfff17 	ldw	r2,-4(fp)
  8087cc:	1000031e 	bne	r2,zero,8087dc <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
  8087d0:	e13ffd17 	ldw	r4,-12(fp)
  8087d4:	080869c0 	call	80869c <alt_alarm_stop>
  8087d8:	00000d06 	br	808810 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
  8087dc:	e0bffd17 	ldw	r2,-12(fp)
  8087e0:	10c00217 	ldw	r3,8(r2)
  8087e4:	e0bfff17 	ldw	r2,-4(fp)
  8087e8:	1887883a 	add	r3,r3,r2
  8087ec:	e0bffd17 	ldw	r2,-12(fp)
  8087f0:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
  8087f4:	e0bffd17 	ldw	r2,-12(fp)
  8087f8:	10c00217 	ldw	r3,8(r2)
  8087fc:	d0a4eb17 	ldw	r2,-27732(gp)
  808800:	1880032e 	bgeu	r3,r2,808810 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
  808804:	e0bffd17 	ldw	r2,-12(fp)
  808808:	00c00044 	movi	r3,1
  80880c:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
  808810:	e0bffe17 	ldw	r2,-8(fp)
  808814:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  808818:	e0fffd17 	ldw	r3,-12(fp)
  80881c:	d0a00904 	addi	r2,gp,-32732
  808820:	18bfcf1e 	bne	r3,r2,808760 <__alt_mem_onchip_memory2_0+0xff788760>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
  808824:	0001883a 	nop
}
  808828:	0001883a 	nop
  80882c:	e037883a 	mov	sp,fp
  808830:	dfc00117 	ldw	ra,4(sp)
  808834:	df000017 	ldw	fp,0(sp)
  808838:	dec00204 	addi	sp,sp,8
  80883c:	f800283a 	ret

00808840 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
  808840:	deffff04 	addi	sp,sp,-4
  808844:	df000015 	stw	fp,0(sp)
  808848:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
  80884c:	000170fa 	wrctl	ienable,zero
}
  808850:	0001883a 	nop
  808854:	e037883a 	mov	sp,fp
  808858:	df000017 	ldw	fp,0(sp)
  80885c:	dec00104 	addi	sp,sp,4
  808860:	f800283a 	ret

00808864 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
  808864:	defffa04 	addi	sp,sp,-24
  808868:	dfc00515 	stw	ra,20(sp)
  80886c:	df000415 	stw	fp,16(sp)
  808870:	df000404 	addi	fp,sp,16
  808874:	e13ffe15 	stw	r4,-8(fp)
  808878:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
  80887c:	e0bfff17 	ldw	r2,-4(fp)
  808880:	10800017 	ldw	r2,0(r2)
  808884:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
  808888:	e13ffe17 	ldw	r4,-8(fp)
  80888c:	080666c0 	call	80666c <strlen>
  808890:	10800044 	addi	r2,r2,1
  808894:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  808898:	00000d06 	br	8088d0 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
  80889c:	e0bffc17 	ldw	r2,-16(fp)
  8088a0:	10800217 	ldw	r2,8(r2)
  8088a4:	e0fffd17 	ldw	r3,-12(fp)
  8088a8:	180d883a 	mov	r6,r3
  8088ac:	e17ffe17 	ldw	r5,-8(fp)
  8088b0:	1009883a 	mov	r4,r2
  8088b4:	0808bc40 	call	808bc4 <memcmp>
  8088b8:	1000021e 	bne	r2,zero,8088c4 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
  8088bc:	e0bffc17 	ldw	r2,-16(fp)
  8088c0:	00000706 	br	8088e0 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
  8088c4:	e0bffc17 	ldw	r2,-16(fp)
  8088c8:	10800017 	ldw	r2,0(r2)
  8088cc:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  8088d0:	e0fffc17 	ldw	r3,-16(fp)
  8088d4:	e0bfff17 	ldw	r2,-4(fp)
  8088d8:	18bff01e 	bne	r3,r2,80889c <__alt_mem_onchip_memory2_0+0xff78889c>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
  8088dc:	0005883a 	mov	r2,zero
}
  8088e0:	e037883a 	mov	sp,fp
  8088e4:	dfc00117 	ldw	ra,4(sp)
  8088e8:	df000017 	ldw	fp,0(sp)
  8088ec:	dec00204 	addi	sp,sp,8
  8088f0:	f800283a 	ret

008088f4 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
  8088f4:	defffb04 	addi	sp,sp,-20
  8088f8:	dfc00415 	stw	ra,16(sp)
  8088fc:	df000315 	stw	fp,12(sp)
  808900:	df000304 	addi	fp,sp,12
  808904:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
  808908:	00802074 	movhi	r2,129
  80890c:	10a87f04 	addi	r2,r2,-24068
  808910:	10800017 	ldw	r2,0(r2)
  808914:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
  808918:	00003106 	br	8089e0 <alt_find_file+0xec>
  {
    len = strlen(next->name);
  80891c:	e0bffd17 	ldw	r2,-12(fp)
  808920:	10800217 	ldw	r2,8(r2)
  808924:	1009883a 	mov	r4,r2
  808928:	080666c0 	call	80666c <strlen>
  80892c:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
  808930:	e0bffd17 	ldw	r2,-12(fp)
  808934:	10c00217 	ldw	r3,8(r2)
  808938:	e0bffe17 	ldw	r2,-8(fp)
  80893c:	10bfffc4 	addi	r2,r2,-1
  808940:	1885883a 	add	r2,r3,r2
  808944:	10800003 	ldbu	r2,0(r2)
  808948:	10803fcc 	andi	r2,r2,255
  80894c:	1080201c 	xori	r2,r2,128
  808950:	10bfe004 	addi	r2,r2,-128
  808954:	10800bd8 	cmpnei	r2,r2,47
  808958:	1000031e 	bne	r2,zero,808968 <alt_find_file+0x74>
    {
      len -= 1;
  80895c:	e0bffe17 	ldw	r2,-8(fp)
  808960:	10bfffc4 	addi	r2,r2,-1
  808964:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
  808968:	e0bffe17 	ldw	r2,-8(fp)
  80896c:	e0ffff17 	ldw	r3,-4(fp)
  808970:	1885883a 	add	r2,r3,r2
  808974:	10800003 	ldbu	r2,0(r2)
  808978:	10803fcc 	andi	r2,r2,255
  80897c:	1080201c 	xori	r2,r2,128
  808980:	10bfe004 	addi	r2,r2,-128
  808984:	10800be0 	cmpeqi	r2,r2,47
  808988:	1000081e 	bne	r2,zero,8089ac <alt_find_file+0xb8>
  80898c:	e0bffe17 	ldw	r2,-8(fp)
  808990:	e0ffff17 	ldw	r3,-4(fp)
  808994:	1885883a 	add	r2,r3,r2
  808998:	10800003 	ldbu	r2,0(r2)
  80899c:	10803fcc 	andi	r2,r2,255
  8089a0:	1080201c 	xori	r2,r2,128
  8089a4:	10bfe004 	addi	r2,r2,-128
  8089a8:	10000a1e 	bne	r2,zero,8089d4 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
  8089ac:	e0bffd17 	ldw	r2,-12(fp)
  8089b0:	10800217 	ldw	r2,8(r2)
  8089b4:	e0fffe17 	ldw	r3,-8(fp)
  8089b8:	180d883a 	mov	r6,r3
  8089bc:	e17fff17 	ldw	r5,-4(fp)
  8089c0:	1009883a 	mov	r4,r2
  8089c4:	0808bc40 	call	808bc4 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
  8089c8:	1000021e 	bne	r2,zero,8089d4 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
  8089cc:	e0bffd17 	ldw	r2,-12(fp)
  8089d0:	00000806 	br	8089f4 <alt_find_file+0x100>
    }
    next = (alt_dev*) next->llist.next;
  8089d4:	e0bffd17 	ldw	r2,-12(fp)
  8089d8:	10800017 	ldw	r2,0(r2)
  8089dc:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
  8089e0:	e0fffd17 	ldw	r3,-12(fp)
  8089e4:	00802074 	movhi	r2,129
  8089e8:	10a87f04 	addi	r2,r2,-24068
  8089ec:	18bfcb1e 	bne	r3,r2,80891c <__alt_mem_onchip_memory2_0+0xff78891c>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
  8089f0:	0005883a 	mov	r2,zero
}
  8089f4:	e037883a 	mov	sp,fp
  8089f8:	dfc00117 	ldw	ra,4(sp)
  8089fc:	df000017 	ldw	fp,0(sp)
  808a00:	dec00204 	addi	sp,sp,8
  808a04:	f800283a 	ret

00808a08 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
  808a08:	defffc04 	addi	sp,sp,-16
  808a0c:	df000315 	stw	fp,12(sp)
  808a10:	df000304 	addi	fp,sp,12
  808a14:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
  808a18:	00bffa04 	movi	r2,-24
  808a1c:	e0bffe15 	stw	r2,-8(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
  808a20:	e03ffd15 	stw	zero,-12(fp)
  808a24:	00001d06 	br	808a9c <alt_get_fd+0x94>
  {
    if (!alt_fd_list[i].dev)
  808a28:	00802074 	movhi	r2,129
  808a2c:	10a81c04 	addi	r2,r2,-24464
  808a30:	e0fffd17 	ldw	r3,-12(fp)
  808a34:	18c00324 	muli	r3,r3,12
  808a38:	10c5883a 	add	r2,r2,r3
  808a3c:	10800017 	ldw	r2,0(r2)
  808a40:	1000131e 	bne	r2,zero,808a90 <alt_get_fd+0x88>
    {
      alt_fd_list[i].dev = dev;
  808a44:	00802074 	movhi	r2,129
  808a48:	10a81c04 	addi	r2,r2,-24464
  808a4c:	e0fffd17 	ldw	r3,-12(fp)
  808a50:	18c00324 	muli	r3,r3,12
  808a54:	10c5883a 	add	r2,r2,r3
  808a58:	e0ffff17 	ldw	r3,-4(fp)
  808a5c:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
  808a60:	00802074 	movhi	r2,129
  808a64:	10a88304 	addi	r2,r2,-24052
  808a68:	10c00017 	ldw	r3,0(r2)
  808a6c:	e0bffd17 	ldw	r2,-12(fp)
  808a70:	1880040e 	bge	r3,r2,808a84 <alt_get_fd+0x7c>
      {
        alt_max_fd = i;
  808a74:	00802074 	movhi	r2,129
  808a78:	10a88304 	addi	r2,r2,-24052
  808a7c:	e0fffd17 	ldw	r3,-12(fp)
  808a80:	10c00015 	stw	r3,0(r2)
      }
      rc = i;
  808a84:	e0bffd17 	ldw	r2,-12(fp)
  808a88:	e0bffe15 	stw	r2,-8(fp)
      goto alt_get_fd_exit;
  808a8c:	00000606 	br	808aa8 <alt_get_fd+0xa0>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
  808a90:	e0bffd17 	ldw	r2,-12(fp)
  808a94:	10800044 	addi	r2,r2,1
  808a98:	e0bffd15 	stw	r2,-12(fp)
  808a9c:	e0bffd17 	ldw	r2,-12(fp)
  808aa0:	10800810 	cmplti	r2,r2,32
  808aa4:	103fe01e 	bne	r2,zero,808a28 <__alt_mem_onchip_memory2_0+0xff788a28>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
  808aa8:	e0bffe17 	ldw	r2,-8(fp)
}
  808aac:	e037883a 	mov	sp,fp
  808ab0:	df000017 	ldw	fp,0(sp)
  808ab4:	dec00104 	addi	sp,sp,4
  808ab8:	f800283a 	ret

00808abc <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
  808abc:	defffb04 	addi	sp,sp,-20
  808ac0:	df000415 	stw	fp,16(sp)
  808ac4:	df000404 	addi	fp,sp,16
  808ac8:	e13ffe15 	stw	r4,-8(fp)
  808acc:	e17fff15 	stw	r5,-4(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
  808ad0:	e0bfff17 	ldw	r2,-4(fp)
  808ad4:	10840070 	cmpltui	r2,r2,4097
  808ad8:	1000021e 	bne	r2,zero,808ae4 <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
  808adc:	00840004 	movi	r2,4096
  808ae0:	e0bfff15 	stw	r2,-4(fp)
  }

  end = ((char*) start) + len;
  808ae4:	e0fffe17 	ldw	r3,-8(fp)
  808ae8:	e0bfff17 	ldw	r2,-4(fp)
  808aec:	1885883a 	add	r2,r3,r2
  808af0:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
  808af4:	e0bffe17 	ldw	r2,-8(fp)
  808af8:	e0bffc15 	stw	r2,-16(fp)
  808afc:	00000506 	br	808b14 <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
  808b00:	e0bffc17 	ldw	r2,-16(fp)
  808b04:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
  808b08:	e0bffc17 	ldw	r2,-16(fp)
  808b0c:	10800804 	addi	r2,r2,32
  808b10:	e0bffc15 	stw	r2,-16(fp)
  808b14:	e0fffc17 	ldw	r3,-16(fp)
  808b18:	e0bffd17 	ldw	r2,-12(fp)
  808b1c:	18bff836 	bltu	r3,r2,808b00 <__alt_mem_onchip_memory2_0+0xff788b00>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
  808b20:	e0bffe17 	ldw	r2,-8(fp)
  808b24:	108007cc 	andi	r2,r2,31
  808b28:	10000226 	beq	r2,zero,808b34 <alt_icache_flush+0x78>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
  808b2c:	e0bffc17 	ldw	r2,-16(fp)
  808b30:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
  808b34:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
  808b38:	0001883a 	nop
  808b3c:	e037883a 	mov	sp,fp
  808b40:	df000017 	ldw	fp,0(sp)
  808b44:	dec00104 	addi	sp,sp,4
  808b48:	f800283a 	ret

00808b4c <exit>:
  808b4c:	defffe04 	addi	sp,sp,-8
  808b50:	000b883a 	mov	r5,zero
  808b54:	dc000015 	stw	r16,0(sp)
  808b58:	dfc00115 	stw	ra,4(sp)
  808b5c:	2021883a 	mov	r16,r4
  808b60:	0808bf40 	call	808bf4 <__call_exitprocs>
  808b64:	8009883a 	mov	r4,r16
  808b68:	0808d840 	call	808d84 <_exit>

00808b6c <fputs>:
  808b6c:	defffd04 	addi	sp,sp,-12
  808b70:	dfc00215 	stw	ra,8(sp)
  808b74:	dc000115 	stw	r16,4(sp)
  808b78:	d9400015 	stw	r5,0(sp)
  808b7c:	2021883a 	mov	r16,r4
  808b80:	080666c0 	call	80666c <strlen>
  808b84:	100f883a 	mov	r7,r2
  808b88:	00802074 	movhi	r2,129
  808b8c:	d9400017 	ldw	r5,0(sp)
  808b90:	10a87d04 	addi	r2,r2,-24076
  808b94:	11000017 	ldw	r4,0(r2)
  808b98:	00c02034 	movhi	r3,128
  808b9c:	18d9c004 	addi	r3,r3,26368
  808ba0:	28c00115 	stw	r3,4(r5)
  808ba4:	800d883a 	mov	r6,r16
  808ba8:	08067000 	call	806700 <__sfvwrite_small_dev>
  808bac:	10bfffe0 	cmpeqi	r2,r2,-1
  808bb0:	0085c83a 	sub	r2,zero,r2
  808bb4:	dfc00217 	ldw	ra,8(sp)
  808bb8:	dc000117 	ldw	r16,4(sp)
  808bbc:	dec00304 	addi	sp,sp,12
  808bc0:	f800283a 	ret

00808bc4 <memcmp>:
  808bc4:	218d883a 	add	r6,r4,r6
  808bc8:	21800826 	beq	r4,r6,808bec <memcmp+0x28>
  808bcc:	20800003 	ldbu	r2,0(r4)
  808bd0:	28c00003 	ldbu	r3,0(r5)
  808bd4:	10c00226 	beq	r2,r3,808be0 <memcmp+0x1c>
  808bd8:	10c5c83a 	sub	r2,r2,r3
  808bdc:	f800283a 	ret
  808be0:	21000044 	addi	r4,r4,1
  808be4:	29400044 	addi	r5,r5,1
  808be8:	003ff706 	br	808bc8 <__alt_mem_onchip_memory2_0+0xff788bc8>
  808bec:	0005883a 	mov	r2,zero
  808bf0:	f800283a 	ret

00808bf4 <__call_exitprocs>:
  808bf4:	defff504 	addi	sp,sp,-44
  808bf8:	dd000515 	stw	r20,20(sp)
  808bfc:	05002074 	movhi	r20,129
  808c00:	dc800315 	stw	r18,12(sp)
  808c04:	dfc00a15 	stw	ra,40(sp)
  808c08:	df000915 	stw	fp,36(sp)
  808c0c:	ddc00815 	stw	r23,32(sp)
  808c10:	dd800715 	stw	r22,28(sp)
  808c14:	dd400615 	stw	r21,24(sp)
  808c18:	dcc00415 	stw	r19,16(sp)
  808c1c:	dc400215 	stw	r17,8(sp)
  808c20:	dc000115 	stw	r16,4(sp)
  808c24:	d9000015 	stw	r4,0(sp)
  808c28:	2825883a 	mov	r18,r5
  808c2c:	a5287c04 	addi	r20,r20,-24080
  808c30:	a4400017 	ldw	r17,0(r20)
  808c34:	8cc00c17 	ldw	r19,48(r17)
  808c38:	8c400c04 	addi	r17,r17,48
  808c3c:	98004526 	beq	r19,zero,808d54 <__call_exitprocs+0x160>
  808c40:	9c000117 	ldw	r16,4(r19)
  808c44:	00900034 	movhi	r2,16384
  808c48:	10bfffc4 	addi	r2,r2,-1
  808c4c:	9d402217 	ldw	r21,136(r19)
  808c50:	85bfffc4 	addi	r22,r16,-1
  808c54:	80a1883a 	add	r16,r16,r2
  808c58:	8421883a 	add	r16,r16,r16
  808c5c:	8421883a 	add	r16,r16,r16
  808c60:	ac2f883a 	add	r23,r21,r16
  808c64:	84000204 	addi	r16,r16,8
  808c68:	9c21883a 	add	r16,r19,r16
  808c6c:	b0002716 	blt	r22,zero,808d0c <__call_exitprocs+0x118>
  808c70:	90000726 	beq	r18,zero,808c90 <__call_exitprocs+0x9c>
  808c74:	a800041e 	bne	r21,zero,808c88 <__call_exitprocs+0x94>
  808c78:	b5bfffc4 	addi	r22,r22,-1
  808c7c:	bdffff04 	addi	r23,r23,-4
  808c80:	843fff04 	addi	r16,r16,-4
  808c84:	003ff906 	br	808c6c <__alt_mem_onchip_memory2_0+0xff788c6c>
  808c88:	b9002017 	ldw	r4,128(r23)
  808c8c:	913ffa1e 	bne	r18,r4,808c78 <__alt_mem_onchip_memory2_0+0xff788c78>
  808c90:	99000117 	ldw	r4,4(r19)
  808c94:	82000017 	ldw	r8,0(r16)
  808c98:	213fffc4 	addi	r4,r4,-1
  808c9c:	b100021e 	bne	r22,r4,808ca8 <__call_exitprocs+0xb4>
  808ca0:	9d800115 	stw	r22,4(r19)
  808ca4:	00000106 	br	808cac <__call_exitprocs+0xb8>
  808ca8:	80000015 	stw	zero,0(r16)
  808cac:	403ff226 	beq	r8,zero,808c78 <__alt_mem_onchip_memory2_0+0xff788c78>
  808cb0:	9f000117 	ldw	fp,4(r19)
  808cb4:	a8000526 	beq	r21,zero,808ccc <__call_exitprocs+0xd8>
  808cb8:	00800044 	movi	r2,1
  808cbc:	1592983a 	sll	r9,r2,r22
  808cc0:	a9404017 	ldw	r5,256(r21)
  808cc4:	494a703a 	and	r5,r9,r5
  808cc8:	2800021e 	bne	r5,zero,808cd4 <__call_exitprocs+0xe0>
  808ccc:	403ee83a 	callr	r8
  808cd0:	00000906 	br	808cf8 <__call_exitprocs+0x104>
  808cd4:	a9004117 	ldw	r4,260(r21)
  808cd8:	4908703a 	and	r4,r9,r4
  808cdc:	2000041e 	bne	r4,zero,808cf0 <__call_exitprocs+0xfc>
  808ce0:	b9400017 	ldw	r5,0(r23)
  808ce4:	d9000017 	ldw	r4,0(sp)
  808ce8:	403ee83a 	callr	r8
  808cec:	00000206 	br	808cf8 <__call_exitprocs+0x104>
  808cf0:	b9000017 	ldw	r4,0(r23)
  808cf4:	403ee83a 	callr	r8
  808cf8:	99000117 	ldw	r4,4(r19)
  808cfc:	e13fcc1e 	bne	fp,r4,808c30 <__alt_mem_onchip_memory2_0+0xff788c30>
  808d00:	89000017 	ldw	r4,0(r17)
  808d04:	993fdc26 	beq	r19,r4,808c78 <__alt_mem_onchip_memory2_0+0xff788c78>
  808d08:	003fc906 	br	808c30 <__alt_mem_onchip_memory2_0+0xff788c30>
  808d0c:	00800034 	movhi	r2,0
  808d10:	10800004 	addi	r2,r2,0
  808d14:	10000f26 	beq	r2,zero,808d54 <__call_exitprocs+0x160>
  808d18:	99400117 	ldw	r5,4(r19)
  808d1c:	99000017 	ldw	r4,0(r19)
  808d20:	2800091e 	bne	r5,zero,808d48 <__call_exitprocs+0x154>
  808d24:	20000826 	beq	r4,zero,808d48 <__call_exitprocs+0x154>
  808d28:	89000015 	stw	r4,0(r17)
  808d2c:	a8000226 	beq	r21,zero,808d38 <__call_exitprocs+0x144>
  808d30:	a809883a 	mov	r4,r21
  808d34:	00000000 	call	0 <__reset-0x800000>
  808d38:	9809883a 	mov	r4,r19
  808d3c:	00000000 	call	0 <__reset-0x800000>
  808d40:	8cc00017 	ldw	r19,0(r17)
  808d44:	003fbd06 	br	808c3c <__alt_mem_onchip_memory2_0+0xff788c3c>
  808d48:	9823883a 	mov	r17,r19
  808d4c:	2027883a 	mov	r19,r4
  808d50:	003fba06 	br	808c3c <__alt_mem_onchip_memory2_0+0xff788c3c>
  808d54:	dfc00a17 	ldw	ra,40(sp)
  808d58:	df000917 	ldw	fp,36(sp)
  808d5c:	ddc00817 	ldw	r23,32(sp)
  808d60:	dd800717 	ldw	r22,28(sp)
  808d64:	dd400617 	ldw	r21,24(sp)
  808d68:	dd000517 	ldw	r20,20(sp)
  808d6c:	dcc00417 	ldw	r19,16(sp)
  808d70:	dc800317 	ldw	r18,12(sp)
  808d74:	dc400217 	ldw	r17,8(sp)
  808d78:	dc000117 	ldw	r16,4(sp)
  808d7c:	dec00b04 	addi	sp,sp,44
  808d80:	f800283a 	ret

00808d84 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
  808d84:	defffd04 	addi	sp,sp,-12
  808d88:	df000215 	stw	fp,8(sp)
  808d8c:	df000204 	addi	fp,sp,8
  808d90:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
  808d94:	0001883a 	nop
  808d98:	e0bfff17 	ldw	r2,-4(fp)
  808d9c:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
  808da0:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
  808da4:	10000226 	beq	r2,zero,808db0 <_exit+0x2c>
    ALT_SIM_FAIL();
  808da8:	002af070 	cmpltui	zero,zero,43969
  808dac:	00000106 	br	808db4 <_exit+0x30>
  } else {
    ALT_SIM_PASS();
  808db0:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
  808db4:	003fff06 	br	808db4 <__alt_mem_onchip_memory2_0+0xff788db4>
