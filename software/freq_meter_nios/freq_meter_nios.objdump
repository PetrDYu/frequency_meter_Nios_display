
freq_meter_nios.elf:     file format elf32-littlenios2
freq_meter_nios.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00800254

Program Header:
    LOAD off    0x00001000 vaddr 0x00800000 paddr 0x00800000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00800020 paddr 0x00800020 align 2**12
         filesz 0x00009798 memsz 0x00009798 flags r-x
    LOAD off    0x0000a7b8 vaddr 0x008097b8 paddr 0x0080ab98 align 2**12
         filesz 0x000013e0 memsz 0x000013e0 flags rw-
    LOAD off    0x0000bf78 vaddr 0x0080bf78 paddr 0x0080bf78 align 2**12
         filesz 0x00000000 memsz 0x0003d2c8 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00800000  00800000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000234  00800020  00800020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         000093f8  00800254  00800254  00001254  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       0000016c  0080964c  0080964c  0000a64c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       000013e0  008097b8  0080ab98  0000a7b8  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0003d372  0080bf78  0080bf78  0000bf78  2**2
                  ALLOC, SMALL_DATA
  6 .sdram        00000000  00849240  00849240  0000bb98  2**0
                  CONTENTS
  7 .onchip_memory2_0 00000000  01080000  01080000  0000bb98  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  0000bb98  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00000800  00000000  00000000  0000bbc0  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0000f5ad  00000000  00000000  0000c3c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 000045f4  00000000  00000000  0001b96d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00005f53  00000000  00000000  0001ff61  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  000023d8  00000000  00000000  00025eb4  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00003729  00000000  00000000  0002828c  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    0000257e  00000000  00000000  0002b9b5  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000030  00000000  00000000  0002df34  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 000003f8  00000000  00000000  0002df68  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000003  00000000  00000000  00031a6e  2**0
                  CONTENTS, READONLY
 19 .cpu          0000000c  00000000  00000000  00031a71  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  00031a7d  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  00031a7e  2**0
                  CONTENTS, READONLY
 22 .sysid_hash   00000004  00000000  00000000  00031a7f  2**0
                  CONTENTS, READONLY
 23 .sysid_base   00000004  00000000  00000000  00031a83  2**0
                  CONTENTS, READONLY
 24 .sysid_time   00000004  00000000  00000000  00031a87  2**0
                  CONTENTS, READONLY
 25 .stderr_dev   0000000b  00000000  00000000  00031a8b  2**0
                  CONTENTS, READONLY
 26 .stdin_dev    0000000b  00000000  00000000  00031a96  2**0
                  CONTENTS, READONLY
 27 .stdout_dev   0000000b  00000000  00000000  00031aa1  2**0
                  CONTENTS, READONLY
 28 .sopc_system_name 00000013  00000000  00000000  00031aac  2**0
                  CONTENTS, READONLY
 29 .quartus_project_dir 00000045  00000000  00000000  00031abf  2**0
                  CONTENTS, READONLY
 30 .jdi          0000483f  00000000  00000000  00031b04  2**0
                  CONTENTS, READONLY
 31 .sopcinfo     00077244  00000000  00000000  00036343  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00800000 l    d  .entry	00000000 .entry
00800020 l    d  .exceptions	00000000 .exceptions
00800254 l    d  .text	00000000 .text
0080964c l    d  .rodata	00000000 .rodata
008097b8 l    d  .rwdata	00000000 .rwdata
0080bf78 l    d  .bss	00000000 .bss
00849240 l    d  .sdram	00000000 .sdram
01080000 l    d  .onchip_memory2_0	00000000 .onchip_memory2_0
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../freq_meter_nios_bsp//obj/HAL/src/crt0.o
0080029c l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 obj/default/Source/portable/GCC/NiosII/port_asm.o
00800020 l       .exceptions	00000000 save_context
0080009c l       .exceptions	00000000 save_sp_to_pxCurrentTCB
008000ac l       .exceptions	00000000 hw_irq_test
00800150 l       .exceptions	00000000 soft_exceptions
008000c0 l       .exceptions	00000000 hw_irq_handler
008000d4 l       .exceptions	00000000 restore_context
0080016c l       .exceptions	00000000 call_scheduler
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 croutine.c
00000000 l    df *ABS*	00000000 event_groups.c
00800930 l     F .text	00000070 prvTestWaitCondition
00000000 l    df *ABS*	00000000 list.c
00000000 l    df *ABS*	00000000 port.c
00800c30 l     F .text	0000002c prvReadGp
00800d94 l     F .text	0000009c prvSetupTimerInterrupt
00000000 l    df *ABS*	00000000 heap_1.c
0080bfe8 l     O .bss	0003d090 ucHeap
0080bf78 l     O .bss	00000004 xNextFreeByte
0080bf7c l     O .bss	00000004 pucAlignedHeap.2618
00000000 l    df *ABS*	00000000 queue.c
008012fc l     F .text	00000084 prvInitialiseNewQueue
00801380 l     F .text	00000060 prvInitialiseMutex
00802164 l     F .text	0000018c prvCopyDataToQueue
00802518 l     F .text	00000058 prvIsQueueFull
0080238c l     F .text	000000f4 prvUnlockQueue
008022f0 l     F .text	0000009c prvCopyDataFromQueue
00802480 l     F .text	00000050 prvIsQueueEmpty
00802114 l     F .text	00000050 prvGetDisinheritPriorityAfterTimeout
00000000 l    df *ABS*	00000000 stream_buffer.c
008033e4 l     F .text	00000080 prvInitialiseNewStreamBuffer
00803370 l     F .text	00000074 prvBytesInBuffer
00802b18 l     F .text	000000d4 prvWriteMessageToBuffer
00803168 l     F .text	000000f4 prvWriteBytesToBuffer
00802ed0 l     F .text	000000bc prvReadMessageFromBuffer
0080325c l     F .text	00000114 prvReadBytesFromBuffer
00000000 l    df *ABS*	00000000 tasks.c
00849078 l     O .bss	00000064 pxReadyTasksLists
008490dc l     O .bss	00000014 xDelayedTaskList1
008490f0 l     O .bss	00000014 xDelayedTaskList2
0080bf84 l     O .bss	00000004 pxDelayedTaskList
0080bf88 l     O .bss	00000004 pxOverflowDelayedTaskList
00849104 l     O .bss	00000014 xPendingReadyList
00849118 l     O .bss	00000014 xTasksWaitingTermination
0080bf8c l     O .bss	00000004 uxDeletedTasksWaitingCleanUp
0084912c l     O .bss	00000014 xSuspendedTaskList
0080bf90 l     O .bss	00000004 uxCurrentNumberOfTasks
0080bf94 l     O .bss	00000004 xTickCount
0080bf98 l     O .bss	00000004 uxTopReadyPriority
0080bf9c l     O .bss	00000004 xSchedulerRunning
0080bfa0 l     O .bss	00000004 xPendedTicks
0080bfa4 l     O .bss	00000004 xYieldPending
0080bfa8 l     O .bss	00000004 xNumOfOverflows
0080bfac l     O .bss	00000004 uxTaskNumber
0080bfb0 l     O .bss	00000004 xNextTaskUnblockTime
0080bfb4 l     O .bss	00000004 xIdleTaskHandle
0080bfb8 l     O .bss	00000004 uxSchedulerSuspended
0080354c l     F .text	000001e4 prvInitialiseNewTask
00803730 l     F .text	000000fc prvAddNewTaskToReadyList
008049bc l     F .text	000000b8 prvInitialiseTaskLists
00804bb8 l     F .text	00000044 prvDeleteTCB
00804bfc l     F .text	00000054 prvResetNextTaskUnblockTime
00805868 l     F .text	000000e8 prvAddCurrentTaskToDelayedList
00803da4 l     F .text	0000006c prvTaskIsTaskSuspended
008049a0 l     F .text	0000001c prvIdleTask
00804a74 l     F .text	00000080 prvCheckTasksWaitingTermination
00804af4 l     F .text	00000064 prvTaskCheckFreeStackSpace
00000000 l    df *ABS*	00000000 timers.c
00000000 l    df *ABS*	00000000 main.c
00805950 l     F .text	0000004c set_output
0080599c l     F .text	00000064 enable
00805a00 l     F .text	00000094 read_busy
00805a94 l     F .text	00000080 hd44780_write
00000000 l    df *ABS*	00000000 itoa.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 utoa.c
00000000 l    df *ABS*	00000000 vfprintf.c
00806970 l     F .text	0000006c print_repeat
00000000 l    df *ABS*	00000000 vsprintf.c
00000000 l    df *ABS*	00000000 fvwrite_small_dev.c
00000000 l    df *ABS*	00000000 fvwrite_small_str.c
00000000 l    df *ABS*	00000000 impure.c
00809884 l     O .rwdata	000000e0 impure_data
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 vfprintf.c
00807154 l     F .text	0000006c print_repeat
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_load.c
0080790c l     F .text	00000068 alt_load_section
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_putstr.c
00000000 l    df *ABS*	00000000 alt_write.c
00807aa8 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
00807bf0 l     F .text	00000038 alt_dev_reg
00809964 l     O .rwdata	00001060 jtag_uart_0
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
00807ecc l     F .text	00000210 altera_avalon_jtag_uart_irq
008080dc l     F .text	000000a8 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_close.c
0080885c l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
008089c4 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
008089f0 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
00808b18 l     F .text	000000c4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_open.c
00808c58 l     F .text	00000050 alt_get_errno
00808ca8 l     F .text	000000cc alt_file_locked
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 fputs.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
008079f8 g     F .text	0000006c alt_main
008067c0 g     F .text	00000080 _puts_r
00849140 g     O .bss	00000100 alt_irq
008000c4 g       .exceptions	00000000 restore_sp_from_pxCurrentTCB
008045f0 g     F .text	00000064 vTaskPlaceOnUnorderedEventList
00801124 g     F .text	0000002c xPortGetFreeHeapSize
00800688 g     F .text	0000003c xEventGroupGetBitsFromISR
0080ab98 g       *ABS*	00000000 __flash_rwdata_start
00803a60 g     F .text	00000058 uxTaskPriorityGet
00806774 g     F .text	0000004c printf
00806f78 g     F .text	0000001c vsprintf
00802bec g     F .text	00000158 xStreamBufferReceive
00805ba8 g     F .text	00000094 hd44780_home
008002f4 g     F .text	00000184 xEventGroupSync
008070f4 g     F .text	00000060 memmove
00804ff4 g     F .text	00000054 vTaskEnterCritical
00801774 g     F .text	000000f4 xQueueGenericSendFromISR
0080428c g     F .text	00000040 pcTaskGetName
0080bfbc g     O .bss	00000004 n
0080bfc0 g     O .bss	00000004 Queue_lcd_rs
008027d8 g     F .text	00000088 xStreamBufferSpacesAvailable
00807a64 g     F .text	00000044 alt_putstr
008090d4 g     F .text	00000024 altera_nios2_gen2_irq_init
008026d0 g     F .text	0000009c xStreamBufferReset
0080704c g     F .text	000000a8 __sfvwrite_small_str
00800000 g     F .entry	0000001c __reset
0080143c g     F .text	00000090 xQueueGiveMutexRecursive
0080bf80 g     O .bss	00000004 pxCurrentTCB
00800020 g       *ABS*	00000000 __flash_exceptions_start
0080bfcc g     O .bss	00000004 errno
00802a28 g     F .text	000000f0 xStreamBufferSendFromISR
0080bfd8 g     O .bss	00000004 alt_argv
00812b6c g       *ABS*	00000000 _gp
00803b04 g     F .text	000001a4 vTaskPrioritySet
0080485c g     F .text	0000003c vTaskInternalSetTimeOutState
00800478 g     F .text	000001a8 xEventGroupWaitBits
0080611c g     F .text	00000174 hd44780_init
0080a9ec g     O .rwdata	00000180 alt_fd_list
00805c3c g     F .text	000000d4 hd44780_display
00800d3c g     F .text	00000038 xPortStartScheduler
008057f0 g     F .text	00000078 ulTaskNotifyValueClear
0080404c g     F .text	00000048 vTaskEndScheduler
008090f8 g     F .text	00000090 alt_find_dev
008066f0 g     F .text	00000028 memcpy
008045a0 g     F .text	00000050 vTaskPlaceOnEventList
00804748 g     F .text	000000c8 vTaskRemoveFromUnorderedEventList
00808bdc g     F .text	0000007c alt_io_redirect
00801f90 g     F .text	0000007c xQueuePeekFromISR
00806840 g     F .text	00000014 puts
008010dc g     F .text	00000024 vPortFree
00801aec g     F .text	00000210 xQueueSemaphoreTake
008082dc g     F .text	0000021c altera_avalon_jtag_uart_read
00806738 g     F .text	0000003c _printf_r
00805fc4 g     F .text	0000009c hd44780_print
01080000 g       *ABS*	00000000 __alt_mem_onchip_memory2_0
00807850 g     F .text	00000064 .hidden __udivsi3
00804b58 g     F .text	00000060 uxTaskGetStackHighWaterMark
00800a34 g     F .text	0000008c vListInsertEnd
00809350 g     F .text	00000090 alt_icache_flush
00806388 g     F .text	000001cc freq_to_lcd
008002a0 g     F .text	00000054 xEventGroupCreate
008066ec g     F .text	00000004 itoa
008008b8 g     F .text	0000003c vEventGroupSetBitsCallback
00803edc g     F .text	000000e0 xTaskResumeFromISR
008097b8 g     O .rwdata	00000042 rus_code_mas
00800a08 g     F .text	0000002c vListInitialiseItem
0080ab88 g     O .rwdata	00000004 alt_max_fd
00800e30 g     F .text	0000004c vPortSysTickHandler
00801944 g     F .text	000001a8 xQueueReceive
00803ab8 g     F .text	0000004c uxTaskPriorityGetFromISR
00800e7c g     F .text	000001a0 alt_irq_register
0080ab6c g     O .rwdata	00000004 _global_impure_ptr
008006c4 g     F .text	00000180 xEventGroupSetBits
00849240 g       *ABS*	00000000 __bss_end
00808fcc g     F .text	00000108 alt_tick
008062bc g     F .text	0000002c sayInBitween
0080101c g     F .text	000000c0 pvPortMalloc
008020d8 g     F .text	0000003c vQueueDelete
00800d74 g     F .text	00000020 vPortEndScheduler
008009a0 g     F .text	00000068 vListInitialise
00802f8c g     F .text	00000058 xStreamBufferIsEmpty
00808f30 g     F .text	0000009c alt_alarm_stop
0080bfd0 g     O .bss	00000004 alt_irq_active
0080017c g     F .exceptions	000000d8 alt_irq_handler
0080a9c4 g     O .rwdata	00000028 alt_dev_null
00804218 g     F .text	00000028 xTaskGetTickCount
008015c0 g     F .text	000001b4 xQueueGenericSend
008028a0 g     F .text	00000188 xStreamBufferSend
008030e4 g     F .text	00000084 xStreamBufferReceiveCompletedFromISR
00805b14 g     F .text	00000094 hd44780_clear
0080897c g     F .text	00000048 alt_dcache_flush_all
0080696c g     F .text	00000004 utoa
00802d44 g     F .text	000000a8 xStreamBufferNextMessageLengthBytes
00804db8 g     F .text	000000fc xTaskPriorityDisinherit
0080ab98 g       *ABS*	00000000 __ram_rwdata_end
0080ab80 g     O .rwdata	00000008 alt_dev_list
00807af8 g     F .text	000000f8 write
00804654 g     F .text	000000f4 xTaskRemoveFromEventList
008097b8 g       *ABS*	00000000 __ram_rodata_end
00800620 g     F .text	00000068 xEventGroupClearBits
00801cfc g     F .text	000001b0 xQueuePeek
008078b4 g     F .text	00000058 .hidden __umodsi3
00849240 g       *ABS*	00000000 end
00802dec g     F .text	000000e4 xStreamBufferReceiveFromISR
0080382c g     F .text	000000e8 vTaskDelete
00806684 g     F .text	00000068 __itoa
00807e10 g     F .text	000000bc altera_avalon_jtag_uart_init
008050ec g     F .text	00000038 pvTaskIncrementMutexHeldCount
01000000 g       *ABS*	00000000 __alt_stack_pointer
008084f8 g     F .text	00000224 altera_avalon_jtag_uart_write
008069dc g     F .text	00000524 ___vfprintf_internal_r
00804898 g     F .text	000000e0 xTaskCheckForTimeOut
00804c78 g     F .text	00000140 xTaskPriorityInherit
00809488 g     F .text	00000190 __call_exitprocs
0080266c g     F .text	00000064 vStreamBufferDelete
00805124 g     F .text	000000b0 ulTaskNotifyTake
00800254 g     F .text	0000004c _start
00805dfc g     F .text	00000130 hd44780_cgram
0080bfe0 g     O .bss	00000004 _alt_tick_rate
00804094 g     F .text	0000002c vTaskSuspendAll
00802fe4 g     F .text	0000007c xStreamBufferIsFull
00804240 g     F .text	0000002c xTaskGetTickCountFromISR
008097fc g     O .rwdata	00000085 rus_letter_mas
0080bfe4 g     O .bss	00000004 _alt_nticks
00807c60 g     F .text	0000004c alt_sys_init
00800b98 g     F .text	00000098 uxListRemove
008025c0 g     F .text	000000ac xStreamBufferGenericCreate
00808184 g     F .text	00000068 altera_avalon_jtag_uart_close
008097b8 g       *ABS*	00000000 __ram_rwdata_start
0080964c g       *ABS*	00000000 __ram_rodata_start
00805778 g     F .text	00000078 xTaskNotifyStateClear
00803e10 g     F .text	000000cc vTaskResume
008044c8 g     F .text	000000d8 vTaskSwitchContext
00807cac g     F .text	00000060 altera_avalon_jtag_uart_read_fd
0080929c g     F .text	000000b4 alt_get_fd
008051d4 g     F .text	000000f4 xTaskNotifyWait
00809458 g     F .text	00000030 memcmp
00807d6c g     F .text	00000050 altera_avalon_jtag_uart_close_fd
00849240 g       *ABS*	00000000 __alt_stack_base
00807dbc g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
00803ca8 g     F .text	000000fc vTaskSuspend
008042cc g     F .text	0000004c xTaskCatchUpTicks
0080426c g     F .text	00000020 uxTaskGetNumberOfTasks
00809188 g     F .text	00000114 alt_find_file
00808a40 g     F .text	000000a4 alt_dev_llist_insert
008071c0 g     F .text	00000524 ___svfprintf_internal_r
008014cc g     F .text	0000009c xQueueTakeMutexRecursive
00800844 g     F .text	00000074 vEventGroupDelete
00806870 g     F .text	000000fc __utoa
008052c8 g     F .text	000001ac xTaskGenericNotify
0080bfc4 g     O .bss	00000004 Queue_lcd_data
00806f94 g     F .text	000000b8 __sfvwrite_small_dev
0080bf78 g       *ABS*	00000000 __bss_start
00805f2c g     F .text	00000098 hd44780_put
00806290 g     F .text	0000002c sayHello
00806718 g     F .text	00000020 memset
00806554 g     F .text	00000130 main
0080bfdc g     O .bss	00000004 alt_envp
00807d0c g     F .text	00000060 altera_avalon_jtag_uart_write_fd
00800ac0 g     F .text	000000d8 vListInsert
0080ab8c g     O .rwdata	00000004 alt_errno
00803914 g     F .text	000000f0 vTaskDelayUntil
00801eac g     F .text	000000e4 xQueueReceiveFromISR
00804c50 g     F .text	00000028 xTaskGetCurrentTaskHandle
00807758 g     F .text	00000084 .hidden __divsi3
00801264 g     F .text	00000098 xQueueGenericCreate
00801568 g     F .text	00000058 xQueueCreateCountingSemaphore
0080964c g       *ABS*	00000000 __flash_rodata_start
0080276c g     F .text	0000006c xStreamBufferSetTriggerLevel
00805474 g     F .text	000001e4 xTaskGenericNotifyFromISR
00807c28 g     F .text	00000038 alt_irq_init
00808ecc g     F .text	00000064 alt_release_fd
008040c0 g     F .text	00000158 xTaskResumeAll
0080204c g     F .text	00000054 uxQueueSpacesAvailable
00803fbc g     F .text	00000090 vTaskStartScheduler
00807700 g     F .text	00000058 _write_r
00806f1c g     F .text	0000005c _vsprintf_r
00802570 g     F .text	00000050 xQueueIsQueueFullFromISR
0080ab70 g     O .rwdata	00000004 _impure_ptr
0080bfd4 g     O .bss	00000004 alt_argc
00804978 g     F .text	00000028 vTaskMissedYield
0080ab78 g     O .rwdata	00000008 alt_fs_list
008076e4 g     F .text	0000001c __vfprintf_internal_unused
0080200c g     F .text	00000040 uxQueueMessagesWaiting
00804318 g     F .text	000001b0 xTaskIncrementTick
00800020 g       *ABS*	00000000 __ram_exceptions_start
00806060 g     F .text	000000bc hd44780_printf
00801150 g     F .text	00000114 xQueueGenericReset
0080ab98 g       *ABS*	00000000 _edata
00849240 g       *ABS*	00000000 _end
00800254 g       *ABS*	00000000 __ram_exceptions_end
008081ec g     F .text	000000f0 altera_avalon_jtag_uart_ioctl
00803464 g     F .text	000000e8 xTaskCreate
00801100 g     F .text	00000024 vPortInitialiseBlocks
008093e0 g     F .text	00000020 exit
008077dc g     F .text	00000074 .hidden __modsi3
00803a04 g     F .text	0000005c vTaskDelay
01000000 g       *ABS*	00000000 __alt_data_end
00800000 g       *ABS*	00000000 __alt_mem_sdram
00804eb4 g     F .text	00000140 vTaskPriorityDisinheritAfterTimeout
00809618 g     F .text	00000034 _exit
0080871c g     F .text	00000140 alt_alarm_start
008062e8 g     F .text	000000a0 task_lcd_write
00805048 g     F .text	00000060 vTaskExitCritical
00806854 g     F .text	0000001c strlen
00800c5c g     F .text	000000e0 pxPortInitialiseStack
00808d74 g     F .text	00000158 open
00805d10 g     F .text	000000ec hd44780_position
00808ae4 g     F .text	00000034 alt_icache_flush_all
00804810 g     F .text	0000004c vTaskSetTimeOutState
00809400 g     F .text	00000058 fputs
0080ab74 g     O .rwdata	00000004 alt_priority_mask
0080bfc8 g     O .bss	00000004 Mutex_write_lcd
00806f00 g     F .text	0000001c __vfprintf_internal
008020a0 g     F .text	00000038 uxQueueMessagesWaitingFromISR
008024d0 g     F .text	00000048 xQueueIsQueueEmptyFromISR
00802860 g     F .text	00000040 xStreamBufferBytesAvailable
0080ab90 g     O .rwdata	00000008 alt_alarm_list
008050a8 g     F .text	00000044 uxTaskResetEventItemValue
008013e0 g     F .text	0000005c xQueueCreateMutex
008088ac g     F .text	000000d0 close
00805658 g     F .text	00000120 vTaskNotifyGiveFromISR
00807974 g     F .text	00000084 alt_load
008008f4 g     F .text	0000003c vEventGroupClearBitsCallback
00803060 g     F .text	00000084 xStreamBufferSendCompletedFromISR
00801868 g     F .text	000000dc xQueueGiveFromISR



Disassembly of section .entry:

00800000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && (!defined(ALT_SIM_OPTIMIZE) || defined(NIOS2_ECC_PRESENT))
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
  800000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
  800004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
  800008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
  80000c:	00bffd16 	blt	zero,r2,800004 <__alt_mem_onchip_memory2_0+0xff780004>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
  800010:	00402034 	movhi	at,128
    ori r1, r1, %lo(_start)
  800014:	08409514 	ori	at,at,596
    jmp r1
  800018:	0800683a 	jmp	at
  80001c:	00000000 	call	0 <__alt_mem_sdram-0x800000>

Disassembly of section .exceptions:

00800020 <save_context>:
# Entry point for exceptions.
.section .exceptions.entry, "xa"		

# Save the entire context of a task.
save_context:
	addi	ea, ea, -4			# Point to the next instruction.
  800020:	ef7fff04 	addi	ea,ea,-4
	addi	sp,	sp, -116		# Create space on the stack.
  800024:	deffe304 	addi	sp,sp,-116
	stw		ra, 0(sp)
  800028:	dfc00015 	stw	ra,0(sp)
								# Leave a gap for muldiv 0
	stw		at, 8(sp)		 
  80002c:	d8400215 	stw	at,8(sp)
	stw		r2, 12(sp)
  800030:	d8800315 	stw	r2,12(sp)
	stw		r3, 16(sp)
  800034:	d8c00415 	stw	r3,16(sp)
	stw		r4, 20(sp)
  800038:	d9000515 	stw	r4,20(sp)
	stw		r5, 24(sp) 
  80003c:	d9400615 	stw	r5,24(sp)
	stw		r6, 28(sp) 
  800040:	d9800715 	stw	r6,28(sp)
	stw		r7, 32(sp) 
  800044:	d9c00815 	stw	r7,32(sp)
	stw		r8, 36(sp) 
  800048:	da000915 	stw	r8,36(sp)
	stw		r9, 40(sp) 
  80004c:	da400a15 	stw	r9,40(sp)
	stw		r10, 44(sp)
  800050:	da800b15 	stw	r10,44(sp)
	stw		r11, 48(sp)
  800054:	dac00c15 	stw	r11,48(sp)
	stw		r12, 52(sp)
  800058:	db000d15 	stw	r12,52(sp)
	stw		r13, 56(sp)
  80005c:	db400e15 	stw	r13,56(sp)
	stw		r14, 60(sp)
  800060:	db800f15 	stw	r14,60(sp)
	stw		r15, 64(sp)
  800064:	dbc01015 	stw	r15,64(sp)
	rdctl	r5, estatus 		# Save the eStatus
  800068:	000b307a 	rdctl	r5,estatus
	stw		r5, 68(sp)
  80006c:	d9401115 	stw	r5,68(sp)
	stw		ea, 72(sp)			# Save the PC
  800070:	df401215 	stw	ea,72(sp)
	stw		r16, 76(sp)			# Save the remaining registers
  800074:	dc001315 	stw	r16,76(sp)
	stw		r17, 80(sp)
  800078:	dc401415 	stw	r17,80(sp)
	stw		r18, 84(sp)
  80007c:	dc801515 	stw	r18,84(sp)
	stw		r19, 88(sp)
  800080:	dcc01615 	stw	r19,88(sp)
	stw		r20, 92(sp)
  800084:	dd001715 	stw	r20,92(sp)
	stw		r21, 96(sp)
  800088:	dd401815 	stw	r21,96(sp)
	stw		r22, 100(sp)
  80008c:	dd801915 	stw	r22,100(sp)
	stw		r23, 104(sp)
  800090:	ddc01a15 	stw	r23,104(sp)
	stw		gp, 108(sp)
  800094:	de801b15 	stw	gp,108(sp)
	stw		fp, 112(sp)
  800098:	df001c15 	stw	fp,112(sp)

0080009c <save_sp_to_pxCurrentTCB>:
  80009c:	06002074 	movhi	et,129

save_sp_to_pxCurrentTCB:
	movia	et, pxCurrentTCB	# Load the address of the pxCurrentTCB pointer
  8000a0:	c62fe004 	addi	et,et,-16512
	ldw		et, (et)			# Load the value of the pxCurrentTCB pointer
  8000a4:	c6000017 	ldw	et,0(et)
	stw		sp, (et)			# Store the stack pointer into the top of the TCB
  8000a8:	c6c00015 	stw	sp,0(et)

008000ac <hw_irq_test>:
hw_irq_test:
	/*
     * Test to see if the exception was a software exception or caused 
     * by an external interrupt, and vector accordingly.
     */
    rdctl	r4, ipending		# Load the Pending Interrupts indication
  8000ac:	0009313a 	rdctl	r4,ipending
	rdctl	r5, estatus 		# Load the eStatus (enabled interrupts).
  8000b0:	000b307a 	rdctl	r5,estatus
    andi	r2, r5, 1			# Are interrupts enabled globally.
  8000b4:	2880004c 	andi	r2,r5,1
    beq		r2, zero, soft_exceptions		# Interrupts are not enabled.
  8000b8:	10002526 	beq	r2,zero,800150 <soft_exceptions>
    beq		r4, zero, soft_exceptions		# There are no interrupts triggered.
  8000bc:	20002426 	beq	r4,zero,800150 <soft_exceptions>

008000c0 <hw_irq_handler>:

	.section .exceptions.irqhandler, "xa"
hw_irq_handler:
	call	alt_irq_handler					# Call the alt_irq_handler to deliver to the registered interrupt handler.
  8000c0:	080017c0 	call	80017c <alt_irq_handler>

008000c4 <restore_sp_from_pxCurrentTCB>:
  8000c4:	06002074 	movhi	et,129

    .section .exceptions.irqreturn, "xa"
restore_sp_from_pxCurrentTCB:
	movia	et, pxCurrentTCB		# Load the address of the pxCurrentTCB pointer
  8000c8:	c62fe004 	addi	et,et,-16512
	ldw		et, (et)				# Load the value of the pxCurrentTCB pointer
  8000cc:	c6000017 	ldw	et,0(et)
	ldw		sp, (et)				# Load the stack pointer with the top value of the TCB
  8000d0:	c6c00017 	ldw	sp,0(et)

008000d4 <restore_context>:

restore_context:
	ldw		ra, 0(sp)		# Restore the registers.
  8000d4:	dfc00017 	ldw	ra,0(sp)
							# Leave a gap for muldiv 0.
	ldw		at, 8(sp)
  8000d8:	d8400217 	ldw	at,8(sp)
	ldw		r2, 12(sp)
  8000dc:	d8800317 	ldw	r2,12(sp)
	ldw		r3, 16(sp)
  8000e0:	d8c00417 	ldw	r3,16(sp)
	ldw		r4, 20(sp)
  8000e4:	d9000517 	ldw	r4,20(sp)
	ldw		r5, 24(sp) 
  8000e8:	d9400617 	ldw	r5,24(sp)
	ldw		r6, 28(sp) 
  8000ec:	d9800717 	ldw	r6,28(sp)
	ldw		r7, 32(sp) 
  8000f0:	d9c00817 	ldw	r7,32(sp)
	ldw		r8, 36(sp) 
  8000f4:	da000917 	ldw	r8,36(sp)
	ldw		r9, 40(sp) 
  8000f8:	da400a17 	ldw	r9,40(sp)
	ldw		r10, 44(sp)
  8000fc:	da800b17 	ldw	r10,44(sp)
	ldw		r11, 48(sp)
  800100:	dac00c17 	ldw	r11,48(sp)
	ldw		r12, 52(sp)
  800104:	db000d17 	ldw	r12,52(sp)
	ldw		r13, 56(sp)
  800108:	db400e17 	ldw	r13,56(sp)
	ldw		r14, 60(sp)
  80010c:	db800f17 	ldw	r14,60(sp)
	ldw		r15, 64(sp)
  800110:	dbc01017 	ldw	r15,64(sp)
	ldw		et, 68(sp)		# Load the eStatus
  800114:	de001117 	ldw	et,68(sp)
	wrctl	estatus, et 	# Write the eStatus
  800118:	c001707a 	wrctl	estatus,et
	ldw		ea, 72(sp)		# Load the Program Counter
  80011c:	df401217 	ldw	ea,72(sp)
	ldw		r16, 76(sp)
  800120:	dc001317 	ldw	r16,76(sp)
	ldw		r17, 80(sp)
  800124:	dc401417 	ldw	r17,80(sp)
	ldw		r18, 84(sp)
  800128:	dc801517 	ldw	r18,84(sp)
	ldw		r19, 88(sp)
  80012c:	dcc01617 	ldw	r19,88(sp)
	ldw		r20, 92(sp)
  800130:	dd001717 	ldw	r20,92(sp)
	ldw		r21, 96(sp)
  800134:	dd401817 	ldw	r21,96(sp)
	ldw		r22, 100(sp)
  800138:	dd801917 	ldw	r22,100(sp)
	ldw		r23, 104(sp)
  80013c:	ddc01a17 	ldw	r23,104(sp)
	ldw		gp, 108(sp)
  800140:	de801b17 	ldw	gp,108(sp)
	ldw		fp, 112(sp)
  800144:	df001c17 	ldw	fp,112(sp)
	addi	sp,	sp, 116		# Release stack space
  800148:	dec01d04 	addi	sp,sp,116

    eret					# Return to address ea, loading eStatus into Status.
  80014c:	ef80083a 	eret

00800150 <soft_exceptions>:
   
	.section .exceptions.soft, "xa"
soft_exceptions:
	ldw		et, 0(ea)				# Load the instruction where the interrupt occured.
  800150:	ee000017 	ldw	et,0(ea)
	movhi	at, %hi(0x003B683A)		# Load the registers with the trap instruction code
  800154:	00400ef4 	movhi	at,59
	ori		at, at, %lo(0x003B683A)
  800158:	085a0e94 	ori	at,at,26682
   	cmpne	et, et, at				# Compare the trap instruction code to the last excuted instruction
  80015c:	c070c03a 	cmpne	et,et,at
  	beq		et, r0, call_scheduler	# its a trap so switchcontext
  800160:	c0000226 	beq	et,zero,80016c <call_scheduler>
  	break							# This is an un-implemented instruction or muldiv problem.
  800164:	003da03a 	break	0
  	br		restore_context			# its something else
  800168:	003fda06 	br	8000d4 <__alt_mem_onchip_memory2_0+0xff7800d4>

0080016c <call_scheduler>:

call_scheduler:
	addi	ea, ea, 4						# A trap was called, increment the program counter so it is not called again.
  80016c:	ef400104 	addi	ea,ea,4
	stw		ea, 72(sp)						# Save the new program counter to the context.
  800170:	df401215 	stw	ea,72(sp)
	call	vTaskSwitchContext				# Pick the next context.
  800174:	08044c80 	call	8044c8 <vTaskSwitchContext>
	br		restore_sp_from_pxCurrentTCB	# Switch in the task context and restore. 
  800178:	003fd206 	br	8000c4 <__alt_mem_onchip_memory2_0+0xff7800c4>

0080017c <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
  80017c:	defff904 	addi	sp,sp,-28
  800180:	dfc00615 	stw	ra,24(sp)
  800184:	df000515 	stw	fp,20(sp)
  800188:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
  80018c:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  800190:	0005313a 	rdctl	r2,ipending
  800194:	e0bffe15 	stw	r2,-8(fp)

  return active;
  800198:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
  80019c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
  8001a0:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
  8001a4:	00800044 	movi	r2,1
  8001a8:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
  8001ac:	e0fffb17 	ldw	r3,-20(fp)
  8001b0:	e0bffc17 	ldw	r2,-16(fp)
  8001b4:	1884703a 	and	r2,r3,r2
  8001b8:	10001526 	beq	r2,zero,800210 <alt_irq_handler+0x94>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
  8001bc:	00802174 	movhi	r2,133
  8001c0:	10a45004 	addi	r2,r2,-28352
  8001c4:	e0fffd17 	ldw	r3,-12(fp)
  8001c8:	180690fa 	slli	r3,r3,3
  8001cc:	10c5883a 	add	r2,r2,r3
  8001d0:	10c00017 	ldw	r3,0(r2)
  8001d4:	00802174 	movhi	r2,133
  8001d8:	10a45004 	addi	r2,r2,-28352
  8001dc:	e13ffd17 	ldw	r4,-12(fp)
  8001e0:	200890fa 	slli	r4,r4,3
  8001e4:	1105883a 	add	r2,r2,r4
  8001e8:	10800104 	addi	r2,r2,4
  8001ec:	10800017 	ldw	r2,0(r2)
  8001f0:	e17ffd17 	ldw	r5,-12(fp)
  8001f4:	1009883a 	mov	r4,r2
  8001f8:	183ee83a 	callr	r3
#endif
        break;
  8001fc:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  800200:	0005313a 	rdctl	r2,ipending
  800204:	e0bfff15 	stw	r2,-4(fp)

  return active;
  800208:	e0bfff17 	ldw	r2,-4(fp)
  80020c:	00000706 	br	80022c <alt_irq_handler+0xb0>
      }
      mask <<= 1;
  800210:	e0bffc17 	ldw	r2,-16(fp)
  800214:	1085883a 	add	r2,r2,r2
  800218:	e0bffc15 	stw	r2,-16(fp)
      i++;
  80021c:	e0bffd17 	ldw	r2,-12(fp)
  800220:	10800044 	addi	r2,r2,1
  800224:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
  800228:	003fe006 	br	8001ac <__alt_mem_onchip_memory2_0+0xff7801ac>

    active = alt_irq_pending ();
  80022c:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
  800230:	e0bffb17 	ldw	r2,-20(fp)
  800234:	103fda1e 	bne	r2,zero,8001a0 <__alt_mem_onchip_memory2_0+0xff7801a0>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
  800238:	0001883a 	nop
}
  80023c:	0001883a 	nop
  800240:	e037883a 	mov	sp,fp
  800244:	dfc00117 	ldw	ra,4(sp)
  800248:	df000017 	ldw	fp,0(sp)
  80024c:	dec00204 	addi	sp,sp,8
  800250:	f800283a 	ret

Disassembly of section .text:

00800254 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
  800254:	00820014 	movui	r2,2048
#endif

0:
    initd 0(r2)
  800258:	10000033 	initd	0(r2)
#ifdef NIOS2_ECC_PRESENT
    addi r2, r2, -4
#else
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
  80025c:	10bff804 	addi	r2,r2,-32
#endif
    bgt r2, zero, 0b
  800260:	00bffd16 	blt	zero,r2,800258 <__alt_mem_onchip_memory2_0+0xff780258>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
  800264:	06c04034 	movhi	sp,256
    ori sp, sp, %lo(__alt_stack_pointer)
  800268:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
  80026c:	06802074 	movhi	gp,129
    ori gp, gp, %lo(_gp)
  800270:	d68adb14 	ori	gp,gp,11116
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
  800274:	00802034 	movhi	r2,128
    ori r2, r2, %lo(__bss_start)
  800278:	10afde14 	ori	r2,r2,49016

    movhi r3, %hi(__bss_end)
  80027c:	00c02134 	movhi	r3,132
    ori r3, r3, %lo(__bss_end)
  800280:	18e49014 	ori	r3,r3,37440

    beq r2, r3, 1f
  800284:	10c00326 	beq	r2,r3,800294 <_start+0x40>

0:
    stw zero, (r2)
  800288:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
  80028c:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
  800290:	10fffd36 	bltu	r2,r3,800288 <__alt_mem_onchip_memory2_0+0xff780288>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
  800294:	08079740 	call	807974 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
  800298:	08079f80 	call	8079f8 <alt_main>

0080029c <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
  80029c:	003fff06 	br	80029c <__alt_mem_onchip_memory2_0+0xff78029c>

008002a0 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
  8002a0:	defffd04 	addi	sp,sp,-12
  8002a4:	dfc00215 	stw	ra,8(sp)
  8002a8:	df000115 	stw	fp,4(sp)
  8002ac:	df000104 	addi	fp,sp,4
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
  8002b0:	01000604 	movi	r4,24
  8002b4:	080101c0 	call	80101c <pvPortMalloc>
  8002b8:	e0bfff15 	stw	r2,-4(fp)

		if( pxEventBits != NULL )
  8002bc:	e0bfff17 	ldw	r2,-4(fp)
  8002c0:	10000626 	beq	r2,zero,8002dc <xEventGroupCreate+0x3c>
		{
			pxEventBits->uxEventBits = 0;
  8002c4:	e0bfff17 	ldw	r2,-4(fp)
  8002c8:	10000015 	stw	zero,0(r2)
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
  8002cc:	e0bfff17 	ldw	r2,-4(fp)
  8002d0:	10800104 	addi	r2,r2,4
  8002d4:	1009883a 	mov	r4,r2
  8002d8:	08009a00 	call	8009a0 <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
  8002dc:	e0bfff17 	ldw	r2,-4(fp)
	}
  8002e0:	e037883a 	mov	sp,fp
  8002e4:	dfc00117 	ldw	ra,4(sp)
  8002e8:	df000017 	ldw	fp,0(sp)
  8002ec:	dec00204 	addi	sp,sp,8
  8002f0:	f800283a 	ret

008002f4 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
  8002f4:	defff504 	addi	sp,sp,-44
  8002f8:	dfc00a15 	stw	ra,40(sp)
  8002fc:	df000915 	stw	fp,36(sp)
  800300:	df000904 	addi	fp,sp,36
  800304:	e13ffc15 	stw	r4,-16(fp)
  800308:	e17ffd15 	stw	r5,-12(fp)
  80030c:	e1bffe15 	stw	r6,-8(fp)
  800310:	e1ffff15 	stw	r7,-4(fp)
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
  800314:	e0bffc17 	ldw	r2,-16(fp)
  800318:	e0bff815 	stw	r2,-32(fp)
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
  80031c:	e03ff915 	stw	zero,-28(fp)
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
  800320:	08040940 	call	804094 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
  800324:	e0bff817 	ldw	r2,-32(fp)
  800328:	10800017 	ldw	r2,0(r2)
  80032c:	e0bffa15 	stw	r2,-24(fp)

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
  800330:	e17ffd17 	ldw	r5,-12(fp)
  800334:	e13ffc17 	ldw	r4,-16(fp)
  800338:	08006c40 	call	8006c4 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
  80033c:	e0fffa17 	ldw	r3,-24(fp)
  800340:	e0bffd17 	ldw	r2,-12(fp)
  800344:	1886b03a 	or	r3,r3,r2
  800348:	e0bffe17 	ldw	r2,-8(fp)
  80034c:	1886703a 	and	r3,r3,r2
  800350:	e0bffe17 	ldw	r2,-8(fp)
  800354:	18800d1e 	bne	r3,r2,80038c <xEventGroupSync+0x98>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
  800358:	e0fffa17 	ldw	r3,-24(fp)
  80035c:	e0bffd17 	ldw	r2,-12(fp)
  800360:	1884b03a 	or	r2,r3,r2
  800364:	e0bff715 	stw	r2,-36(fp)

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
  800368:	e0bff817 	ldw	r2,-32(fp)
  80036c:	10c00017 	ldw	r3,0(r2)
  800370:	e0bffe17 	ldw	r2,-8(fp)
  800374:	0084303a 	nor	r2,zero,r2
  800378:	1886703a 	and	r3,r3,r2
  80037c:	e0bff817 	ldw	r2,-32(fp)
  800380:	10c00015 	stw	r3,0(r2)

			xTicksToWait = 0;
  800384:	e03fff15 	stw	zero,-4(fp)
  800388:	00001106 	br	8003d0 <xEventGroupSync+0xdc>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
  80038c:	e0bfff17 	ldw	r2,-4(fp)
  800390:	10000a26 	beq	r2,zero,8003bc <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
  800394:	e0bff817 	ldw	r2,-32(fp)
  800398:	10c00104 	addi	r3,r2,4
  80039c:	e0bffe17 	ldw	r2,-8(fp)
  8003a0:	10814034 	orhi	r2,r2,1280
  8003a4:	e1bfff17 	ldw	r6,-4(fp)
  8003a8:	100b883a 	mov	r5,r2
  8003ac:	1809883a 	mov	r4,r3
  8003b0:	08045f00 	call	8045f0 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
  8003b4:	e03ff715 	stw	zero,-36(fp)
  8003b8:	00000506 	br	8003d0 <xEventGroupSync+0xdc>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
  8003bc:	e0bff817 	ldw	r2,-32(fp)
  8003c0:	10800017 	ldw	r2,0(r2)
  8003c4:	e0bff715 	stw	r2,-36(fp)
				xTimeoutOccurred = pdTRUE;
  8003c8:	00800044 	movi	r2,1
  8003cc:	e0bff915 	stw	r2,-28(fp)
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
  8003d0:	08040c00 	call	8040c0 <xTaskResumeAll>
  8003d4:	e0bffb15 	stw	r2,-20(fp)

	if( xTicksToWait != ( TickType_t ) 0 )
  8003d8:	e0bfff17 	ldw	r2,-4(fp)
  8003dc:	10002026 	beq	r2,zero,800460 <xEventGroupSync+0x16c>
	{
		if( xAlreadyYielded == pdFALSE )
  8003e0:	e0bffb17 	ldw	r2,-20(fp)
  8003e4:	1000011e 	bne	r2,zero,8003ec <xEventGroupSync+0xf8>
		{
			portYIELD_WITHIN_API();
  8003e8:	003b683a 	trap	0

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
  8003ec:	08050a80 	call	8050a8 <uxTaskResetEventItemValue>
  8003f0:	e0bff715 	stw	r2,-36(fp)

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
  8003f4:	e0bff717 	ldw	r2,-36(fp)
  8003f8:	1080802c 	andhi	r2,r2,512
  8003fc:	1000131e 	bne	r2,zero,80044c <xEventGroupSync+0x158>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
  800400:	0804ff40 	call	804ff4 <vTaskEnterCritical>
			{
				uxReturn = pxEventBits->uxEventBits;
  800404:	e0bff817 	ldw	r2,-32(fp)
  800408:	10800017 	ldw	r2,0(r2)
  80040c:	e0bff715 	stw	r2,-36(fp)

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
  800410:	e0fff717 	ldw	r3,-36(fp)
  800414:	e0bffe17 	ldw	r2,-8(fp)
  800418:	1886703a 	and	r3,r3,r2
  80041c:	e0bffe17 	ldw	r2,-8(fp)
  800420:	1880071e 	bne	r3,r2,800440 <xEventGroupSync+0x14c>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
  800424:	e0bff817 	ldw	r2,-32(fp)
  800428:	10c00017 	ldw	r3,0(r2)
  80042c:	e0bffe17 	ldw	r2,-8(fp)
  800430:	0084303a 	nor	r2,zero,r2
  800434:	1886703a 	and	r3,r3,r2
  800438:	e0bff817 	ldw	r2,-32(fp)
  80043c:	10c00015 	stw	r3,0(r2)
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
  800440:	08050480 	call	805048 <vTaskExitCritical>

			xTimeoutOccurred = pdTRUE;
  800444:	00800044 	movi	r2,1
  800448:	e0bff915 	stw	r2,-28(fp)
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
  80044c:	e0fff717 	ldw	r3,-36(fp)
  800450:	00804034 	movhi	r2,256
  800454:	10bfffc4 	addi	r2,r2,-1
  800458:	1884703a 	and	r2,r3,r2
  80045c:	e0bff715 	stw	r2,-36(fp)
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
  800460:	e0bff717 	ldw	r2,-36(fp)
}
  800464:	e037883a 	mov	sp,fp
  800468:	dfc00117 	ldw	ra,4(sp)
  80046c:	df000017 	ldw	fp,0(sp)
  800470:	dec00204 	addi	sp,sp,8
  800474:	f800283a 	ret

00800478 <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
  800478:	defff304 	addi	sp,sp,-52
  80047c:	dfc00c15 	stw	ra,48(sp)
  800480:	df000b15 	stw	fp,44(sp)
  800484:	df000b04 	addi	fp,sp,44
  800488:	e13ffc15 	stw	r4,-16(fp)
  80048c:	e17ffd15 	stw	r5,-12(fp)
  800490:	e1bffe15 	stw	r6,-8(fp)
  800494:	e1ffff15 	stw	r7,-4(fp)
EventGroup_t *pxEventBits = xEventGroup;
  800498:	e0bffc17 	ldw	r2,-16(fp)
  80049c:	e0bff715 	stw	r2,-36(fp)
EventBits_t uxReturn, uxControlBits = 0;
  8004a0:	e03ff615 	stw	zero,-40(fp)
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
  8004a4:	e03ff815 	stw	zero,-32(fp)
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
  8004a8:	08040940 	call	804094 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
  8004ac:	e0bff717 	ldw	r2,-36(fp)
  8004b0:	10800017 	ldw	r2,0(r2)
  8004b4:	e0bff915 	stw	r2,-28(fp)

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
  8004b8:	e1bfff17 	ldw	r6,-4(fp)
  8004bc:	e17ffd17 	ldw	r5,-12(fp)
  8004c0:	e13ff917 	ldw	r4,-28(fp)
  8004c4:	08009300 	call	800930 <prvTestWaitCondition>
  8004c8:	e0bffa15 	stw	r2,-24(fp)

		if( xWaitConditionMet != pdFALSE )
  8004cc:	e0bffa17 	ldw	r2,-24(fp)
  8004d0:	10000d26 	beq	r2,zero,800508 <xEventGroupWaitBits+0x90>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
  8004d4:	e0bff917 	ldw	r2,-28(fp)
  8004d8:	e0bff515 	stw	r2,-44(fp)
			xTicksToWait = ( TickType_t ) 0;
  8004dc:	e0000215 	stw	zero,8(fp)

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
  8004e0:	e0bffe17 	ldw	r2,-8(fp)
  8004e4:	10002226 	beq	r2,zero,800570 <xEventGroupWaitBits+0xf8>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
  8004e8:	e0bff717 	ldw	r2,-36(fp)
  8004ec:	10c00017 	ldw	r3,0(r2)
  8004f0:	e0bffd17 	ldw	r2,-12(fp)
  8004f4:	0084303a 	nor	r2,zero,r2
  8004f8:	1886703a 	and	r3,r3,r2
  8004fc:	e0bff717 	ldw	r2,-36(fp)
  800500:	10c00015 	stw	r3,0(r2)
  800504:	00001a06 	br	800570 <xEventGroupWaitBits+0xf8>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
  800508:	e0800217 	ldw	r2,8(fp)
  80050c:	1000051e 	bne	r2,zero,800524 <xEventGroupWaitBits+0xac>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
  800510:	e0bff917 	ldw	r2,-28(fp)
  800514:	e0bff515 	stw	r2,-44(fp)
			xTimeoutOccurred = pdTRUE;
  800518:	00800044 	movi	r2,1
  80051c:	e0bff815 	stw	r2,-32(fp)
  800520:	00001306 	br	800570 <xEventGroupWaitBits+0xf8>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
  800524:	e0bffe17 	ldw	r2,-8(fp)
  800528:	10000326 	beq	r2,zero,800538 <xEventGroupWaitBits+0xc0>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
  80052c:	e0bff617 	ldw	r2,-40(fp)
  800530:	10804034 	orhi	r2,r2,256
  800534:	e0bff615 	stw	r2,-40(fp)
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
  800538:	e0bfff17 	ldw	r2,-4(fp)
  80053c:	10000326 	beq	r2,zero,80054c <xEventGroupWaitBits+0xd4>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
  800540:	e0bff617 	ldw	r2,-40(fp)
  800544:	10810034 	orhi	r2,r2,1024
  800548:	e0bff615 	stw	r2,-40(fp)
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
  80054c:	e0bff717 	ldw	r2,-36(fp)
  800550:	11000104 	addi	r4,r2,4
  800554:	e0fffd17 	ldw	r3,-12(fp)
  800558:	e0bff617 	ldw	r2,-40(fp)
  80055c:	1884b03a 	or	r2,r3,r2
  800560:	e1800217 	ldw	r6,8(fp)
  800564:	100b883a 	mov	r5,r2
  800568:	08045f00 	call	8045f0 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
  80056c:	e03ff515 	stw	zero,-44(fp)

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
  800570:	08040c00 	call	8040c0 <xTaskResumeAll>
  800574:	e0bffb15 	stw	r2,-20(fp)

	if( xTicksToWait != ( TickType_t ) 0 )
  800578:	e0800217 	ldw	r2,8(fp)
  80057c:	10002226 	beq	r2,zero,800608 <xEventGroupWaitBits+0x190>
	{
		if( xAlreadyYielded == pdFALSE )
  800580:	e0bffb17 	ldw	r2,-20(fp)
  800584:	1000011e 	bne	r2,zero,80058c <xEventGroupWaitBits+0x114>
		{
			portYIELD_WITHIN_API();
  800588:	003b683a 	trap	0

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
  80058c:	08050a80 	call	8050a8 <uxTaskResetEventItemValue>
  800590:	e0bff515 	stw	r2,-44(fp)

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
  800594:	e0bff517 	ldw	r2,-44(fp)
  800598:	1080802c 	andhi	r2,r2,512
  80059c:	1000151e 	bne	r2,zero,8005f4 <xEventGroupWaitBits+0x17c>
		{
			taskENTER_CRITICAL();
  8005a0:	0804ff40 	call	804ff4 <vTaskEnterCritical>
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
  8005a4:	e0bff717 	ldw	r2,-36(fp)
  8005a8:	10800017 	ldw	r2,0(r2)
  8005ac:	e0bff515 	stw	r2,-44(fp)

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
  8005b0:	e1bfff17 	ldw	r6,-4(fp)
  8005b4:	e17ffd17 	ldw	r5,-12(fp)
  8005b8:	e13ff517 	ldw	r4,-44(fp)
  8005bc:	08009300 	call	800930 <prvTestWaitCondition>
  8005c0:	10000926 	beq	r2,zero,8005e8 <xEventGroupWaitBits+0x170>
				{
					if( xClearOnExit != pdFALSE )
  8005c4:	e0bffe17 	ldw	r2,-8(fp)
  8005c8:	10000726 	beq	r2,zero,8005e8 <xEventGroupWaitBits+0x170>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
  8005cc:	e0bff717 	ldw	r2,-36(fp)
  8005d0:	10c00017 	ldw	r3,0(r2)
  8005d4:	e0bffd17 	ldw	r2,-12(fp)
  8005d8:	0084303a 	nor	r2,zero,r2
  8005dc:	1886703a 	and	r3,r3,r2
  8005e0:	e0bff717 	ldw	r2,-36(fp)
  8005e4:	10c00015 	stw	r3,0(r2)
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
  8005e8:	00800044 	movi	r2,1
  8005ec:	e0bff815 	stw	r2,-32(fp)
			}
			taskEXIT_CRITICAL();
  8005f0:	08050480 	call	805048 <vTaskExitCritical>
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
  8005f4:	e0fff517 	ldw	r3,-44(fp)
  8005f8:	00804034 	movhi	r2,256
  8005fc:	10bfffc4 	addi	r2,r2,-1
  800600:	1884703a 	and	r2,r3,r2
  800604:	e0bff515 	stw	r2,-44(fp)
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
  800608:	e0bff517 	ldw	r2,-44(fp)
}
  80060c:	e037883a 	mov	sp,fp
  800610:	dfc00117 	ldw	ra,4(sp)
  800614:	df000017 	ldw	fp,0(sp)
  800618:	dec00204 	addi	sp,sp,8
  80061c:	f800283a 	ret

00800620 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
  800620:	defffa04 	addi	sp,sp,-24
  800624:	dfc00515 	stw	ra,20(sp)
  800628:	df000415 	stw	fp,16(sp)
  80062c:	df000404 	addi	fp,sp,16
  800630:	e13ffe15 	stw	r4,-8(fp)
  800634:	e17fff15 	stw	r5,-4(fp)
EventGroup_t *pxEventBits = xEventGroup;
  800638:	e0bffe17 	ldw	r2,-8(fp)
  80063c:	e0bffc15 	stw	r2,-16(fp)
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
  800640:	0804ff40 	call	804ff4 <vTaskEnterCritical>
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
  800644:	e0bffc17 	ldw	r2,-16(fp)
  800648:	10800017 	ldw	r2,0(r2)
  80064c:	e0bffd15 	stw	r2,-12(fp)

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
  800650:	e0bffc17 	ldw	r2,-16(fp)
  800654:	10c00017 	ldw	r3,0(r2)
  800658:	e0bfff17 	ldw	r2,-4(fp)
  80065c:	0084303a 	nor	r2,zero,r2
  800660:	1886703a 	and	r3,r3,r2
  800664:	e0bffc17 	ldw	r2,-16(fp)
  800668:	10c00015 	stw	r3,0(r2)
	}
	taskEXIT_CRITICAL();
  80066c:	08050480 	call	805048 <vTaskExitCritical>

	return uxReturn;
  800670:	e0bffd17 	ldw	r2,-12(fp)
}
  800674:	e037883a 	mov	sp,fp
  800678:	dfc00117 	ldw	ra,4(sp)
  80067c:	df000017 	ldw	fp,0(sp)
  800680:	dec00204 	addi	sp,sp,8
  800684:	f800283a 	ret

00800688 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
  800688:	defffb04 	addi	sp,sp,-20
  80068c:	df000415 	stw	fp,16(sp)
  800690:	df000404 	addi	fp,sp,16
  800694:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
  800698:	e0bfff17 	ldw	r2,-4(fp)
  80069c:	e0bffc15 	stw	r2,-16(fp)
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  8006a0:	e03ffd15 	stw	zero,-12(fp)
	{
		uxReturn = pxEventBits->uxEventBits;
  8006a4:	e0bffc17 	ldw	r2,-16(fp)
  8006a8:	10800017 	ldw	r2,0(r2)
  8006ac:	e0bffe15 	stw	r2,-8(fp)
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
  8006b0:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
  8006b4:	e037883a 	mov	sp,fp
  8006b8:	df000017 	ldw	fp,0(sp)
  8006bc:	dec00104 	addi	sp,sp,4
  8006c0:	f800283a 	ret

008006c4 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
  8006c4:	defff304 	addi	sp,sp,-52
  8006c8:	dfc00c15 	stw	ra,48(sp)
  8006cc:	df000b15 	stw	fp,44(sp)
  8006d0:	df000b04 	addi	fp,sp,44
  8006d4:	e13ffe15 	stw	r4,-8(fp)
  8006d8:	e17fff15 	stw	r5,-4(fp)
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
  8006dc:	e03ff615 	stw	zero,-40(fp)
EventGroup_t *pxEventBits = xEventGroup;
  8006e0:	e0bffe17 	ldw	r2,-8(fp)
  8006e4:	e0bff815 	stw	r2,-32(fp)
BaseType_t xMatchFound = pdFALSE;
  8006e8:	e03ff715 	stw	zero,-36(fp)
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
  8006ec:	e0bff817 	ldw	r2,-32(fp)
  8006f0:	10800104 	addi	r2,r2,4
  8006f4:	e0bff915 	stw	r2,-28(fp)
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  8006f8:	e0bff917 	ldw	r2,-28(fp)
  8006fc:	10800204 	addi	r2,r2,8
  800700:	e0bffa15 	stw	r2,-24(fp)
	vTaskSuspendAll();
  800704:	08040940 	call	804094 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
  800708:	e0bff917 	ldw	r2,-28(fp)
  80070c:	10800317 	ldw	r2,12(r2)
  800710:	e0bff515 	stw	r2,-44(fp)

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
  800714:	e0bff817 	ldw	r2,-32(fp)
  800718:	10c00017 	ldw	r3,0(r2)
  80071c:	e0bfff17 	ldw	r2,-4(fp)
  800720:	1886b03a 	or	r3,r3,r2
  800724:	e0bff817 	ldw	r2,-32(fp)
  800728:	10c00015 	stw	r3,0(r2)

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
  80072c:	00003306 	br	8007fc <xEventGroupSetBits+0x138>
		{
			pxNext = listGET_NEXT( pxListItem );
  800730:	e0bff517 	ldw	r2,-44(fp)
  800734:	10800117 	ldw	r2,4(r2)
  800738:	e0bffb15 	stw	r2,-20(fp)
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
  80073c:	e0bff517 	ldw	r2,-44(fp)
  800740:	10800017 	ldw	r2,0(r2)
  800744:	e0bffc15 	stw	r2,-16(fp)
			xMatchFound = pdFALSE;
  800748:	e03ff715 	stw	zero,-36(fp)

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
  80074c:	e0bffc17 	ldw	r2,-16(fp)
  800750:	10bfc02c 	andhi	r2,r2,65280
  800754:	e0bffd15 	stw	r2,-12(fp)
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
  800758:	e0fffc17 	ldw	r3,-16(fp)
  80075c:	00804034 	movhi	r2,256
  800760:	10bfffc4 	addi	r2,r2,-1
  800764:	1884703a 	and	r2,r3,r2
  800768:	e0bffc15 	stw	r2,-16(fp)

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
  80076c:	e0bffd17 	ldw	r2,-12(fp)
  800770:	1081002c 	andhi	r2,r2,1024
  800774:	1000081e 	bne	r2,zero,800798 <xEventGroupSetBits+0xd4>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
  800778:	e0bff817 	ldw	r2,-32(fp)
  80077c:	10c00017 	ldw	r3,0(r2)
  800780:	e0bffc17 	ldw	r2,-16(fp)
  800784:	1884703a 	and	r2,r3,r2
  800788:	10000b26 	beq	r2,zero,8007b8 <xEventGroupSetBits+0xf4>
				{
					xMatchFound = pdTRUE;
  80078c:	00800044 	movi	r2,1
  800790:	e0bff715 	stw	r2,-36(fp)
  800794:	00000806 	br	8007b8 <xEventGroupSetBits+0xf4>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
  800798:	e0bff817 	ldw	r2,-32(fp)
  80079c:	10c00017 	ldw	r3,0(r2)
  8007a0:	e0bffc17 	ldw	r2,-16(fp)
  8007a4:	1886703a 	and	r3,r3,r2
  8007a8:	e0bffc17 	ldw	r2,-16(fp)
  8007ac:	1880021e 	bne	r3,r2,8007b8 <xEventGroupSetBits+0xf4>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
  8007b0:	00800044 	movi	r2,1
  8007b4:	e0bff715 	stw	r2,-36(fp)
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
  8007b8:	e0bff717 	ldw	r2,-36(fp)
  8007bc:	10000d26 	beq	r2,zero,8007f4 <xEventGroupSetBits+0x130>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
  8007c0:	e0bffd17 	ldw	r2,-12(fp)
  8007c4:	1080402c 	andhi	r2,r2,256
  8007c8:	10000426 	beq	r2,zero,8007dc <xEventGroupSetBits+0x118>
				{
					uxBitsToClear |= uxBitsWaitedFor;
  8007cc:	e0fff617 	ldw	r3,-40(fp)
  8007d0:	e0bffc17 	ldw	r2,-16(fp)
  8007d4:	1884b03a 	or	r2,r3,r2
  8007d8:	e0bff615 	stw	r2,-40(fp)
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
  8007dc:	e0bff817 	ldw	r2,-32(fp)
  8007e0:	10800017 	ldw	r2,0(r2)
  8007e4:	10808034 	orhi	r2,r2,512
  8007e8:	100b883a 	mov	r5,r2
  8007ec:	e13ff517 	ldw	r4,-44(fp)
  8007f0:	08047480 	call	804748 <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
  8007f4:	e0bffb17 	ldw	r2,-20(fp)
  8007f8:	e0bff515 	stw	r2,-44(fp)

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
  8007fc:	e0fff517 	ldw	r3,-44(fp)
  800800:	e0bffa17 	ldw	r2,-24(fp)
  800804:	18bfca1e 	bne	r3,r2,800730 <__alt_mem_onchip_memory2_0+0xff780730>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
  800808:	e0bff817 	ldw	r2,-32(fp)
  80080c:	10c00017 	ldw	r3,0(r2)
  800810:	e0bff617 	ldw	r2,-40(fp)
  800814:	0084303a 	nor	r2,zero,r2
  800818:	1886703a 	and	r3,r3,r2
  80081c:	e0bff817 	ldw	r2,-32(fp)
  800820:	10c00015 	stw	r3,0(r2)
	}
	( void ) xTaskResumeAll();
  800824:	08040c00 	call	8040c0 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
  800828:	e0bff817 	ldw	r2,-32(fp)
  80082c:	10800017 	ldw	r2,0(r2)
}
  800830:	e037883a 	mov	sp,fp
  800834:	dfc00117 	ldw	ra,4(sp)
  800838:	df000017 	ldw	fp,0(sp)
  80083c:	dec00204 	addi	sp,sp,8
  800840:	f800283a 	ret

00800844 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
  800844:	defffb04 	addi	sp,sp,-20
  800848:	dfc00415 	stw	ra,16(sp)
  80084c:	df000315 	stw	fp,12(sp)
  800850:	df000304 	addi	fp,sp,12
  800854:	e13fff15 	stw	r4,-4(fp)
EventGroup_t *pxEventBits = xEventGroup;
  800858:	e0bfff17 	ldw	r2,-4(fp)
  80085c:	e0bffd15 	stw	r2,-12(fp)
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
  800860:	e0bffd17 	ldw	r2,-12(fp)
  800864:	10800104 	addi	r2,r2,4
  800868:	e0bffe15 	stw	r2,-8(fp)

	vTaskSuspendAll();
  80086c:	08040940 	call	804094 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
  800870:	00000506 	br	800888 <vEventGroupDelete+0x44>
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
  800874:	e0bffe17 	ldw	r2,-8(fp)
  800878:	10800317 	ldw	r2,12(r2)
  80087c:	01408034 	movhi	r5,512
  800880:	1009883a 	mov	r4,r2
  800884:	08047480 	call	804748 <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
  800888:	e0bffe17 	ldw	r2,-8(fp)
  80088c:	10800017 	ldw	r2,0(r2)
  800890:	103ff81e 	bne	r2,zero,800874 <__alt_mem_onchip_memory2_0+0xff780874>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
  800894:	e13ffd17 	ldw	r4,-12(fp)
  800898:	08010dc0 	call	8010dc <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
  80089c:	08040c00 	call	8040c0 <xTaskResumeAll>
}
  8008a0:	0001883a 	nop
  8008a4:	e037883a 	mov	sp,fp
  8008a8:	dfc00117 	ldw	ra,4(sp)
  8008ac:	df000017 	ldw	fp,0(sp)
  8008b0:	dec00204 	addi	sp,sp,8
  8008b4:	f800283a 	ret

008008b8 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
  8008b8:	defffc04 	addi	sp,sp,-16
  8008bc:	dfc00315 	stw	ra,12(sp)
  8008c0:	df000215 	stw	fp,8(sp)
  8008c4:	df000204 	addi	fp,sp,8
  8008c8:	e13ffe15 	stw	r4,-8(fp)
  8008cc:	e17fff15 	stw	r5,-4(fp)
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
  8008d0:	e17fff17 	ldw	r5,-4(fp)
  8008d4:	e13ffe17 	ldw	r4,-8(fp)
  8008d8:	08006c40 	call	8006c4 <xEventGroupSetBits>
}
  8008dc:	0001883a 	nop
  8008e0:	e037883a 	mov	sp,fp
  8008e4:	dfc00117 	ldw	ra,4(sp)
  8008e8:	df000017 	ldw	fp,0(sp)
  8008ec:	dec00204 	addi	sp,sp,8
  8008f0:	f800283a 	ret

008008f4 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
  8008f4:	defffc04 	addi	sp,sp,-16
  8008f8:	dfc00315 	stw	ra,12(sp)
  8008fc:	df000215 	stw	fp,8(sp)
  800900:	df000204 	addi	fp,sp,8
  800904:	e13ffe15 	stw	r4,-8(fp)
  800908:	e17fff15 	stw	r5,-4(fp)
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
  80090c:	e17fff17 	ldw	r5,-4(fp)
  800910:	e13ffe17 	ldw	r4,-8(fp)
  800914:	08006200 	call	800620 <xEventGroupClearBits>
}
  800918:	0001883a 	nop
  80091c:	e037883a 	mov	sp,fp
  800920:	dfc00117 	ldw	ra,4(sp)
  800924:	df000017 	ldw	fp,0(sp)
  800928:	dec00204 	addi	sp,sp,8
  80092c:	f800283a 	ret

00800930 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
  800930:	defffb04 	addi	sp,sp,-20
  800934:	df000415 	stw	fp,16(sp)
  800938:	df000404 	addi	fp,sp,16
  80093c:	e13ffd15 	stw	r4,-12(fp)
  800940:	e17ffe15 	stw	r5,-8(fp)
  800944:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xWaitConditionMet = pdFALSE;
  800948:	e03ffc15 	stw	zero,-16(fp)

	if( xWaitForAllBits == pdFALSE )
  80094c:	e0bfff17 	ldw	r2,-4(fp)
  800950:	1000071e 	bne	r2,zero,800970 <prvTestWaitCondition+0x40>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
  800954:	e0fffd17 	ldw	r3,-12(fp)
  800958:	e0bffe17 	ldw	r2,-8(fp)
  80095c:	1884703a 	and	r2,r3,r2
  800960:	10000a26 	beq	r2,zero,80098c <prvTestWaitCondition+0x5c>
		{
			xWaitConditionMet = pdTRUE;
  800964:	00800044 	movi	r2,1
  800968:	e0bffc15 	stw	r2,-16(fp)
  80096c:	00000706 	br	80098c <prvTestWaitCondition+0x5c>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
  800970:	e0fffd17 	ldw	r3,-12(fp)
  800974:	e0bffe17 	ldw	r2,-8(fp)
  800978:	1886703a 	and	r3,r3,r2
  80097c:	e0bffe17 	ldw	r2,-8(fp)
  800980:	1880021e 	bne	r3,r2,80098c <prvTestWaitCondition+0x5c>
		{
			xWaitConditionMet = pdTRUE;
  800984:	00800044 	movi	r2,1
  800988:	e0bffc15 	stw	r2,-16(fp)
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
  80098c:	e0bffc17 	ldw	r2,-16(fp)
}
  800990:	e037883a 	mov	sp,fp
  800994:	df000017 	ldw	fp,0(sp)
  800998:	dec00104 	addi	sp,sp,4
  80099c:	f800283a 	ret

008009a0 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
  8009a0:	defffe04 	addi	sp,sp,-8
  8009a4:	df000115 	stw	fp,4(sp)
  8009a8:	df000104 	addi	fp,sp,4
  8009ac:	e13fff15 	stw	r4,-4(fp)
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  8009b0:	e0bfff17 	ldw	r2,-4(fp)
  8009b4:	10c00204 	addi	r3,r2,8
  8009b8:	e0bfff17 	ldw	r2,-4(fp)
  8009bc:	10c00115 	stw	r3,4(r2)

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
  8009c0:	e0bfff17 	ldw	r2,-4(fp)
  8009c4:	00ffffc4 	movi	r3,-1
  8009c8:	10c00215 	stw	r3,8(r2)

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  8009cc:	e0bfff17 	ldw	r2,-4(fp)
  8009d0:	10c00204 	addi	r3,r2,8
  8009d4:	e0bfff17 	ldw	r2,-4(fp)
  8009d8:	10c00315 	stw	r3,12(r2)
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  8009dc:	e0bfff17 	ldw	r2,-4(fp)
  8009e0:	10c00204 	addi	r3,r2,8
  8009e4:	e0bfff17 	ldw	r2,-4(fp)
  8009e8:	10c00415 	stw	r3,16(r2)

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
  8009ec:	e0bfff17 	ldw	r2,-4(fp)
  8009f0:	10000015 	stw	zero,0(r2)

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
  8009f4:	0001883a 	nop
  8009f8:	e037883a 	mov	sp,fp
  8009fc:	df000017 	ldw	fp,0(sp)
  800a00:	dec00104 	addi	sp,sp,4
  800a04:	f800283a 	ret

00800a08 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
  800a08:	defffe04 	addi	sp,sp,-8
  800a0c:	df000115 	stw	fp,4(sp)
  800a10:	df000104 	addi	fp,sp,4
  800a14:	e13fff15 	stw	r4,-4(fp)
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
  800a18:	e0bfff17 	ldw	r2,-4(fp)
  800a1c:	10000415 	stw	zero,16(r2)

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
  800a20:	0001883a 	nop
  800a24:	e037883a 	mov	sp,fp
  800a28:	df000017 	ldw	fp,0(sp)
  800a2c:	dec00104 	addi	sp,sp,4
  800a30:	f800283a 	ret

00800a34 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
  800a34:	defffc04 	addi	sp,sp,-16
  800a38:	df000315 	stw	fp,12(sp)
  800a3c:	df000304 	addi	fp,sp,12
  800a40:	e13ffe15 	stw	r4,-8(fp)
  800a44:	e17fff15 	stw	r5,-4(fp)
ListItem_t * const pxIndex = pxList->pxIndex;
  800a48:	e0bffe17 	ldw	r2,-8(fp)
  800a4c:	10800117 	ldw	r2,4(r2)
  800a50:	e0bffd15 	stw	r2,-12(fp)
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
  800a54:	e0bfff17 	ldw	r2,-4(fp)
  800a58:	e0fffd17 	ldw	r3,-12(fp)
  800a5c:	10c00115 	stw	r3,4(r2)
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
  800a60:	e0bffd17 	ldw	r2,-12(fp)
  800a64:	10c00217 	ldw	r3,8(r2)
  800a68:	e0bfff17 	ldw	r2,-4(fp)
  800a6c:	10c00215 	stw	r3,8(r2)

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
  800a70:	e0bffd17 	ldw	r2,-12(fp)
  800a74:	10800217 	ldw	r2,8(r2)
  800a78:	e0ffff17 	ldw	r3,-4(fp)
  800a7c:	10c00115 	stw	r3,4(r2)
	pxIndex->pxPrevious = pxNewListItem;
  800a80:	e0bffd17 	ldw	r2,-12(fp)
  800a84:	e0ffff17 	ldw	r3,-4(fp)
  800a88:	10c00215 	stw	r3,8(r2)

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
  800a8c:	e0bfff17 	ldw	r2,-4(fp)
  800a90:	e0fffe17 	ldw	r3,-8(fp)
  800a94:	10c00415 	stw	r3,16(r2)

	( pxList->uxNumberOfItems )++;
  800a98:	e0bffe17 	ldw	r2,-8(fp)
  800a9c:	10800017 	ldw	r2,0(r2)
  800aa0:	10c00044 	addi	r3,r2,1
  800aa4:	e0bffe17 	ldw	r2,-8(fp)
  800aa8:	10c00015 	stw	r3,0(r2)
}
  800aac:	0001883a 	nop
  800ab0:	e037883a 	mov	sp,fp
  800ab4:	df000017 	ldw	fp,0(sp)
  800ab8:	dec00104 	addi	sp,sp,4
  800abc:	f800283a 	ret

00800ac0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
  800ac0:	defffb04 	addi	sp,sp,-20
  800ac4:	df000415 	stw	fp,16(sp)
  800ac8:	df000404 	addi	fp,sp,16
  800acc:	e13ffe15 	stw	r4,-8(fp)
  800ad0:	e17fff15 	stw	r5,-4(fp)
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
  800ad4:	e0bfff17 	ldw	r2,-4(fp)
  800ad8:	10800017 	ldw	r2,0(r2)
  800adc:	e0bffd15 	stw	r2,-12(fp)
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
  800ae0:	e0bffd17 	ldw	r2,-12(fp)
  800ae4:	10bfffd8 	cmpnei	r2,r2,-1
  800ae8:	1000041e 	bne	r2,zero,800afc <vListInsert+0x3c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
  800aec:	e0bffe17 	ldw	r2,-8(fp)
  800af0:	10800417 	ldw	r2,16(r2)
  800af4:	e0bffc15 	stw	r2,-16(fp)
  800af8:	00000c06 	br	800b2c <vListInsert+0x6c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
  800afc:	e0bffe17 	ldw	r2,-8(fp)
  800b00:	10800204 	addi	r2,r2,8
  800b04:	e0bffc15 	stw	r2,-16(fp)
  800b08:	00000306 	br	800b18 <vListInsert+0x58>
  800b0c:	e0bffc17 	ldw	r2,-16(fp)
  800b10:	10800117 	ldw	r2,4(r2)
  800b14:	e0bffc15 	stw	r2,-16(fp)
  800b18:	e0bffc17 	ldw	r2,-16(fp)
  800b1c:	10800117 	ldw	r2,4(r2)
  800b20:	10800017 	ldw	r2,0(r2)
  800b24:	e0fffd17 	ldw	r3,-12(fp)
  800b28:	18bff82e 	bgeu	r3,r2,800b0c <__alt_mem_onchip_memory2_0+0xff780b0c>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
  800b2c:	e0bffc17 	ldw	r2,-16(fp)
  800b30:	10c00117 	ldw	r3,4(r2)
  800b34:	e0bfff17 	ldw	r2,-4(fp)
  800b38:	10c00115 	stw	r3,4(r2)
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
  800b3c:	e0bfff17 	ldw	r2,-4(fp)
  800b40:	10800117 	ldw	r2,4(r2)
  800b44:	e0ffff17 	ldw	r3,-4(fp)
  800b48:	10c00215 	stw	r3,8(r2)
	pxNewListItem->pxPrevious = pxIterator;
  800b4c:	e0bfff17 	ldw	r2,-4(fp)
  800b50:	e0fffc17 	ldw	r3,-16(fp)
  800b54:	10c00215 	stw	r3,8(r2)
	pxIterator->pxNext = pxNewListItem;
  800b58:	e0bffc17 	ldw	r2,-16(fp)
  800b5c:	e0ffff17 	ldw	r3,-4(fp)
  800b60:	10c00115 	stw	r3,4(r2)

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
  800b64:	e0bfff17 	ldw	r2,-4(fp)
  800b68:	e0fffe17 	ldw	r3,-8(fp)
  800b6c:	10c00415 	stw	r3,16(r2)

	( pxList->uxNumberOfItems )++;
  800b70:	e0bffe17 	ldw	r2,-8(fp)
  800b74:	10800017 	ldw	r2,0(r2)
  800b78:	10c00044 	addi	r3,r2,1
  800b7c:	e0bffe17 	ldw	r2,-8(fp)
  800b80:	10c00015 	stw	r3,0(r2)
}
  800b84:	0001883a 	nop
  800b88:	e037883a 	mov	sp,fp
  800b8c:	df000017 	ldw	fp,0(sp)
  800b90:	dec00104 	addi	sp,sp,4
  800b94:	f800283a 	ret

00800b98 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
  800b98:	defffd04 	addi	sp,sp,-12
  800b9c:	df000215 	stw	fp,8(sp)
  800ba0:	df000204 	addi	fp,sp,8
  800ba4:	e13fff15 	stw	r4,-4(fp)
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
  800ba8:	e0bfff17 	ldw	r2,-4(fp)
  800bac:	10800417 	ldw	r2,16(r2)
  800bb0:	e0bffe15 	stw	r2,-8(fp)

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
  800bb4:	e0bfff17 	ldw	r2,-4(fp)
  800bb8:	10800117 	ldw	r2,4(r2)
  800bbc:	e0ffff17 	ldw	r3,-4(fp)
  800bc0:	18c00217 	ldw	r3,8(r3)
  800bc4:	10c00215 	stw	r3,8(r2)
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
  800bc8:	e0bfff17 	ldw	r2,-4(fp)
  800bcc:	10800217 	ldw	r2,8(r2)
  800bd0:	e0ffff17 	ldw	r3,-4(fp)
  800bd4:	18c00117 	ldw	r3,4(r3)
  800bd8:	10c00115 	stw	r3,4(r2)

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
  800bdc:	e0bffe17 	ldw	r2,-8(fp)
  800be0:	10c00117 	ldw	r3,4(r2)
  800be4:	e0bfff17 	ldw	r2,-4(fp)
  800be8:	1880041e 	bne	r3,r2,800bfc <uxListRemove+0x64>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
  800bec:	e0bfff17 	ldw	r2,-4(fp)
  800bf0:	10c00217 	ldw	r3,8(r2)
  800bf4:	e0bffe17 	ldw	r2,-8(fp)
  800bf8:	10c00115 	stw	r3,4(r2)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
  800bfc:	e0bfff17 	ldw	r2,-4(fp)
  800c00:	10000415 	stw	zero,16(r2)
	( pxList->uxNumberOfItems )--;
  800c04:	e0bffe17 	ldw	r2,-8(fp)
  800c08:	10800017 	ldw	r2,0(r2)
  800c0c:	10ffffc4 	addi	r3,r2,-1
  800c10:	e0bffe17 	ldw	r2,-8(fp)
  800c14:	10c00015 	stw	r3,0(r2)

	return pxList->uxNumberOfItems;
  800c18:	e0bffe17 	ldw	r2,-8(fp)
  800c1c:	10800017 	ldw	r2,0(r2)
}
  800c20:	e037883a 	mov	sp,fp
  800c24:	df000017 	ldw	fp,0(sp)
  800c28:	dec00104 	addi	sp,sp,4
  800c2c:	f800283a 	ret

00800c30 <prvReadGp>:
void vPortSysTickHandler( void * context, alt_u32 id );

/*-----------------------------------------------------------*/

static void prvReadGp( uint32_t *ulValue )
{
  800c30:	defffe04 	addi	sp,sp,-8
  800c34:	df000115 	stw	fp,4(sp)
  800c38:	df000104 	addi	fp,sp,4
  800c3c:	e13fff15 	stw	r4,-4(fp)
	asm( "stw gp, (%0)" :: "r"(ulValue) );
  800c40:	e0bfff17 	ldw	r2,-4(fp)
  800c44:	16800015 	stw	gp,0(r2)
}
  800c48:	0001883a 	nop
  800c4c:	e037883a 	mov	sp,fp
  800c50:	df000017 	ldw	fp,0(sp)
  800c54:	dec00104 	addi	sp,sp,4
  800c58:	f800283a 	ret

00800c5c <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{    
  800c5c:	defff904 	addi	sp,sp,-28
  800c60:	dfc00615 	stw	ra,24(sp)
  800c64:	df000515 	stw	fp,20(sp)
  800c68:	df000504 	addi	fp,sp,20
  800c6c:	e13ffd15 	stw	r4,-12(fp)
  800c70:	e17ffe15 	stw	r5,-8(fp)
  800c74:	e1bfff15 	stw	r6,-4(fp)
StackType_t *pxFramePointer = pxTopOfStack - 1;
  800c78:	e0bffd17 	ldw	r2,-12(fp)
  800c7c:	10bfff04 	addi	r2,r2,-4
  800c80:	e0bffb15 	stw	r2,-20(fp)
StackType_t xGlobalPointer;

    prvReadGp( &xGlobalPointer ); 
  800c84:	e0bffc04 	addi	r2,fp,-16
  800c88:	1009883a 	mov	r4,r2
  800c8c:	0800c300 	call	800c30 <prvReadGp>

    /* End of stack marker. */
    *pxTopOfStack = 0xdeadbeef;
  800c90:	e0fffd17 	ldw	r3,-12(fp)
  800c94:	00b7abb4 	movhi	r2,57006
  800c98:	10afbbc4 	addi	r2,r2,-16657
  800c9c:	18800015 	stw	r2,0(r3)
    pxTopOfStack--;
  800ca0:	e0bffd17 	ldw	r2,-12(fp)
  800ca4:	10bfff04 	addi	r2,r2,-4
  800ca8:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = ( StackType_t ) pxFramePointer; 
  800cac:	e0fffb17 	ldw	r3,-20(fp)
  800cb0:	e0bffd17 	ldw	r2,-12(fp)
  800cb4:	10c00015 	stw	r3,0(r2)
    pxTopOfStack--;
  800cb8:	e0bffd17 	ldw	r2,-12(fp)
  800cbc:	10bfff04 	addi	r2,r2,-4
  800cc0:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = xGlobalPointer; 
  800cc4:	e0fffc17 	ldw	r3,-16(fp)
  800cc8:	e0bffd17 	ldw	r2,-12(fp)
  800ccc:	10c00015 	stw	r3,0(r2)
    
    /* Space for R23 to R16. */
    pxTopOfStack -= 9;
  800cd0:	e0bffd17 	ldw	r2,-12(fp)
  800cd4:	10bff704 	addi	r2,r2,-36
  800cd8:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = ( StackType_t ) pxCode; 
  800cdc:	e0fffe17 	ldw	r3,-8(fp)
  800ce0:	e0bffd17 	ldw	r2,-12(fp)
  800ce4:	10c00015 	stw	r3,0(r2)
    pxTopOfStack--;
  800ce8:	e0bffd17 	ldw	r2,-12(fp)
  800cec:	10bfff04 	addi	r2,r2,-4
  800cf0:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = portINITIAL_ESTATUS; 
  800cf4:	e0bffd17 	ldw	r2,-12(fp)
  800cf8:	00c00044 	movi	r3,1
  800cfc:	10c00015 	stw	r3,0(r2)

    /* Space for R15 to R5. */    
    pxTopOfStack -= 12;
  800d00:	e0bffd17 	ldw	r2,-12(fp)
  800d04:	10bff404 	addi	r2,r2,-48
  800d08:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = ( StackType_t ) pvParameters; 
  800d0c:	e0ffff17 	ldw	r3,-4(fp)
  800d10:	e0bffd17 	ldw	r2,-12(fp)
  800d14:	10c00015 	stw	r3,0(r2)

    /* Space for R3 to R1, muldiv and RA. */
    pxTopOfStack -= 5;
  800d18:	e0bffd17 	ldw	r2,-12(fp)
  800d1c:	10bffb04 	addi	r2,r2,-20
  800d20:	e0bffd15 	stw	r2,-12(fp)
    
    return pxTopOfStack;
  800d24:	e0bffd17 	ldw	r2,-12(fp)
}
  800d28:	e037883a 	mov	sp,fp
  800d2c:	dfc00117 	ldw	ra,4(sp)
  800d30:	df000017 	ldw	fp,0(sp)
  800d34:	dec00204 	addi	sp,sp,8
  800d38:	f800283a 	ret

00800d3c <xPortStartScheduler>:

/* 
 * See header file for description. 
 */
BaseType_t xPortStartScheduler( void )
{
  800d3c:	defffe04 	addi	sp,sp,-8
  800d40:	dfc00115 	stw	ra,4(sp)
  800d44:	df000015 	stw	fp,0(sp)
  800d48:	d839883a 	mov	fp,sp
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
  800d4c:	0800d940 	call	800d94 <prvSetupTimerInterrupt>
  800d50:	00802034 	movhi	r2,128
	
	/* Start the first task. */
    asm volatile (  " movia r2, restore_sp_from_pxCurrentTCB        \n"
  800d54:	10803104 	addi	r2,r2,196
  800d58:	1000683a 	jmp	r2
                    " jmp r2                                          " );

	/* Should not get here! */
	return 0;
  800d5c:	0005883a 	mov	r2,zero
}
  800d60:	e037883a 	mov	sp,fp
  800d64:	dfc00117 	ldw	ra,4(sp)
  800d68:	df000017 	ldw	fp,0(sp)
  800d6c:	dec00204 	addi	sp,sp,8
  800d70:	f800283a 	ret

00800d74 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
  800d74:	deffff04 	addi	sp,sp,-4
  800d78:	df000015 	stw	fp,0(sp)
  800d7c:	d839883a 	mov	fp,sp
	/* It is unlikely that the NIOS2 port will require this function as there
	is nothing to return to.  */
}
  800d80:	0001883a 	nop
  800d84:	e037883a 	mov	sp,fp
  800d88:	df000017 	ldw	fp,0(sp)
  800d8c:	dec00104 	addi	sp,sp,4
  800d90:	f800283a 	ret

00800d94 <prvSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
  800d94:	defffe04 	addi	sp,sp,-8
  800d98:	dfc00115 	stw	ra,4(sp)
  800d9c:	df000015 	stw	fp,0(sp)
  800da0:	d839883a 	mov	fp,sp
	/* Try to register the interrupt handler. */
	if ( -EINVAL == alt_irq_register( TIMER_0_IRQ, 0x0, vPortSysTickHandler ) )
  800da4:	01802034 	movhi	r6,128
  800da8:	31838c04 	addi	r6,r6,3632
  800dac:	000b883a 	mov	r5,zero
  800db0:	01000044 	movi	r4,1
  800db4:	0800e7c0 	call	800e7c <alt_irq_register>
  800db8:	10bffa98 	cmpnei	r2,r2,-22
  800dbc:	1000021e 	bne	r2,zero,800dc8 <prvSetupTimerInterrupt+0x34>
	{ 
		/* Failed to install the Interrupt Handler. */
		asm( "break" );
  800dc0:	003da03a 	break	0
  800dc4:	00001006 	br	800e08 <prvSetupTimerInterrupt+0x74>
	}
	else
	{
		/* Configure SysTick to interrupt at the requested rate. */
		IOWR_ALTERA_AVALON_TIMER_CONTROL( TIMER_0_BASE, ALTERA_AVALON_TIMER_CONTROL_STOP_MSK );
  800dc8:	00c00204 	movi	r3,8
  800dcc:	00804434 	movhi	r2,272
  800dd0:	10840104 	addi	r2,r2,4100
  800dd4:	10c00035 	stwio	r3,0(r2)
		IOWR_ALTERA_AVALON_TIMER_PERIODL( TIMER_0_BASE, ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) & 0xFFFF );
  800dd8:	00f0d414 	movui	r3,50000
  800ddc:	00804434 	movhi	r2,272
  800de0:	10840204 	addi	r2,r2,4104
  800de4:	10c00035 	stwio	r3,0(r2)
		IOWR_ALTERA_AVALON_TIMER_PERIODH( TIMER_0_BASE, ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) >> 16 );
  800de8:	0007883a 	mov	r3,zero
  800dec:	00804434 	movhi	r2,272
  800df0:	10840304 	addi	r2,r2,4108
  800df4:	10c00035 	stwio	r3,0(r2)
		IOWR_ALTERA_AVALON_TIMER_CONTROL( TIMER_0_BASE, ALTERA_AVALON_TIMER_CONTROL_CONT_MSK | ALTERA_AVALON_TIMER_CONTROL_START_MSK | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK );	
  800df8:	00c001c4 	movi	r3,7
  800dfc:	00804434 	movhi	r2,272
  800e00:	10840104 	addi	r2,r2,4100
  800e04:	10c00035 	stwio	r3,0(r2)
	} 

	/* Clear any already pending interrupts generated by the Timer. */
	IOWR_ALTERA_AVALON_TIMER_STATUS( TIMER_0_BASE, ~ALTERA_AVALON_TIMER_STATUS_TO_MSK );
  800e08:	00ffff84 	movi	r3,-2
  800e0c:	00804434 	movhi	r2,272
  800e10:	10840004 	addi	r2,r2,4096
  800e14:	10c00035 	stwio	r3,0(r2)
}
  800e18:	0001883a 	nop
  800e1c:	e037883a 	mov	sp,fp
  800e20:	dfc00117 	ldw	ra,4(sp)
  800e24:	df000017 	ldw	fp,0(sp)
  800e28:	dec00204 	addi	sp,sp,8
  800e2c:	f800283a 	ret

00800e30 <vPortSysTickHandler>:
/*-----------------------------------------------------------*/

void vPortSysTickHandler( void * context, alt_u32 id )
{
  800e30:	defffc04 	addi	sp,sp,-16
  800e34:	dfc00315 	stw	ra,12(sp)
  800e38:	df000215 	stw	fp,8(sp)
  800e3c:	df000204 	addi	fp,sp,8
  800e40:	e13ffe15 	stw	r4,-8(fp)
  800e44:	e17fff15 	stw	r5,-4(fp)
	/* Increment the kernel tick. */
	if( xTaskIncrementTick() != pdFALSE )
  800e48:	08043180 	call	804318 <xTaskIncrementTick>
  800e4c:	10000126 	beq	r2,zero,800e54 <vPortSysTickHandler+0x24>
	{
        vTaskSwitchContext();
  800e50:	08044c80 	call	8044c8 <vTaskSwitchContext>
	}
		
	/* Clear the interrupt. */
	IOWR_ALTERA_AVALON_TIMER_STATUS( TIMER_0_BASE, ~ALTERA_AVALON_TIMER_STATUS_TO_MSK );
  800e54:	00ffff84 	movi	r3,-2
  800e58:	00804434 	movhi	r2,272
  800e5c:	10840004 	addi	r2,r2,4096
  800e60:	10c00035 	stwio	r3,0(r2)
}
  800e64:	0001883a 	nop
  800e68:	e037883a 	mov	sp,fp
  800e6c:	dfc00117 	ldw	ra,4(sp)
  800e70:	df000017 	ldw	fp,0(sp)
  800e74:	dec00204 	addi	sp,sp,8
  800e78:	f800283a 	ret

00800e7c <alt_irq_register>:
 * when it is registered. Interrupts should only be enabled after the FreeRTOS.org
 * kernel has its scheduler started so that contexts are saved and switched 
 * correctly.
 */
int alt_irq_register( alt_u32 id, void* context, void (*handler)(void*, alt_u32) )
{
  800e7c:	defff104 	addi	sp,sp,-60
  800e80:	df000e15 	stw	fp,56(sp)
  800e84:	df000e04 	addi	fp,sp,56
  800e88:	e13ffd15 	stw	r4,-12(fp)
  800e8c:	e17ffe15 	stw	r5,-8(fp)
  800e90:	e1bfff15 	stw	r6,-4(fp)
	int rc = -EINVAL;  
  800e94:	00bffa84 	movi	r2,-22
  800e98:	e0bff215 	stw	r2,-56(fp)
	alt_irq_context status;

	if (id < ALT_NIRQ)
  800e9c:	e0bffd17 	ldw	r2,-12(fp)
  800ea0:	10800828 	cmpgeui	r2,r2,32
  800ea4:	1000581e 	bne	r2,zero,801008 <alt_irq_register+0x18c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  800ea8:	0005303a 	rdctl	r2,status
  800eac:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  800eb0:	e0fff617 	ldw	r3,-40(fp)
  800eb4:	00bfff84 	movi	r2,-2
  800eb8:	1884703a 	and	r2,r3,r2
  800ebc:	1001703a 	wrctl	status,r2
  
  return context;
  800ec0:	e0bff617 	ldw	r2,-40(fp)
		 * interrupts are disabled while the handler tables are updated to ensure
		 * that an interrupt doesn't occur while the tables are in an inconsistent
		 * state.
		 */
	
		status = alt_irq_disable_all ();
  800ec4:	e0bff415 	stw	r2,-48(fp)
	
		alt_irq[id].handler = handler;
  800ec8:	00802174 	movhi	r2,133
  800ecc:	10a45004 	addi	r2,r2,-28352
  800ed0:	e0fffd17 	ldw	r3,-12(fp)
  800ed4:	180690fa 	slli	r3,r3,3
  800ed8:	10c5883a 	add	r2,r2,r3
  800edc:	e0ffff17 	ldw	r3,-4(fp)
  800ee0:	10c00015 	stw	r3,0(r2)
		alt_irq[id].context = context;
  800ee4:	00802174 	movhi	r2,133
  800ee8:	10a45004 	addi	r2,r2,-28352
  800eec:	e0fffd17 	ldw	r3,-12(fp)
  800ef0:	180690fa 	slli	r3,r3,3
  800ef4:	10c5883a 	add	r2,r2,r3
  800ef8:	10800104 	addi	r2,r2,4
  800efc:	e0fffe17 	ldw	r3,-8(fp)
  800f00:	10c00015 	stw	r3,0(r2)
	
		rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
  800f04:	e0bfff17 	ldw	r2,-4(fp)
  800f08:	10001f26 	beq	r2,zero,800f88 <alt_irq_register+0x10c>
  800f0c:	e0bffd17 	ldw	r2,-12(fp)
  800f10:	e0bff315 	stw	r2,-52(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  800f14:	0005303a 	rdctl	r2,status
  800f18:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  800f1c:	e0fff717 	ldw	r3,-36(fp)
  800f20:	00bfff84 	movi	r2,-2
  800f24:	1884703a 	and	r2,r3,r2
  800f28:	1001703a 	wrctl	status,r2
  
  return context;
  800f2c:	e0bff717 	ldw	r2,-36(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  800f30:	e0bff815 	stw	r2,-32(fp)

  alt_irq_active |= (1 << id);
  800f34:	00c00044 	movi	r3,1
  800f38:	e0bff317 	ldw	r2,-52(fp)
  800f3c:	1884983a 	sll	r2,r3,r2
  800f40:	1007883a 	mov	r3,r2
  800f44:	00802074 	movhi	r2,129
  800f48:	10aff404 	addi	r2,r2,-16432
  800f4c:	10800017 	ldw	r2,0(r2)
  800f50:	1886b03a 	or	r3,r3,r2
  800f54:	00802074 	movhi	r2,129
  800f58:	10aff404 	addi	r2,r2,-16432
  800f5c:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  800f60:	00802074 	movhi	r2,129
  800f64:	10aff404 	addi	r2,r2,-16432
  800f68:	10800017 	ldw	r2,0(r2)
  800f6c:	100170fa 	wrctl	ienable,r2
  800f70:	e0bff817 	ldw	r2,-32(fp)
  800f74:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  800f78:	e0bff917 	ldw	r2,-28(fp)
  800f7c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  800f80:	0005883a 	mov	r2,zero
  800f84:	00001f06 	br	801004 <alt_irq_register+0x188>
  800f88:	e0bffd17 	ldw	r2,-12(fp)
  800f8c:	e0bff515 	stw	r2,-44(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  800f90:	0005303a 	rdctl	r2,status
  800f94:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  800f98:	e0fffa17 	ldw	r3,-24(fp)
  800f9c:	00bfff84 	movi	r2,-2
  800fa0:	1884703a 	and	r2,r3,r2
  800fa4:	1001703a 	wrctl	status,r2
  
  return context;
  800fa8:	e0bffa17 	ldw	r2,-24(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  800fac:	e0bffb15 	stw	r2,-20(fp)

  alt_irq_active &= ~(1 << id);
  800fb0:	00c00044 	movi	r3,1
  800fb4:	e0bff517 	ldw	r2,-44(fp)
  800fb8:	1884983a 	sll	r2,r3,r2
  800fbc:	0084303a 	nor	r2,zero,r2
  800fc0:	1007883a 	mov	r3,r2
  800fc4:	00802074 	movhi	r2,129
  800fc8:	10aff404 	addi	r2,r2,-16432
  800fcc:	10800017 	ldw	r2,0(r2)
  800fd0:	1886703a 	and	r3,r3,r2
  800fd4:	00802074 	movhi	r2,129
  800fd8:	10aff404 	addi	r2,r2,-16432
  800fdc:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  800fe0:	00802074 	movhi	r2,129
  800fe4:	10aff404 	addi	r2,r2,-16432
  800fe8:	10800017 	ldw	r2,0(r2)
  800fec:	100170fa 	wrctl	ienable,r2
  800ff0:	e0bffb17 	ldw	r2,-20(fp)
  800ff4:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  800ff8:	e0bffc17 	ldw	r2,-16(fp)
  800ffc:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  801000:	0005883a 	mov	r2,zero
  801004:	e0bff215 	stw	r2,-56(fp)
	
		/* alt_irq_enable_all(status); This line is removed to prevent the interrupt from being immediately enabled. */
	}
    
	return rc; 
  801008:	e0bff217 	ldw	r2,-56(fp)
}
  80100c:	e037883a 	mov	sp,fp
  801010:	df000017 	ldw	fp,0(sp)
  801014:	dec00104 	addi	sp,sp,4
  801018:	f800283a 	ret

0080101c <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
  80101c:	defffc04 	addi	sp,sp,-16
  801020:	dfc00315 	stw	ra,12(sp)
  801024:	df000215 	stw	fp,8(sp)
  801028:	df000204 	addi	fp,sp,8
  80102c:	e13fff15 	stw	r4,-4(fp)
void *pvReturn = NULL;
  801030:	e03ffe15 	stw	zero,-8(fp)
static uint8_t *pucAlignedHeap = NULL;

	/* Ensure that blocks are always aligned to the required number of bytes. */
	#if( portBYTE_ALIGNMENT != 1 )
	{
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
  801034:	e0bfff17 	ldw	r2,-4(fp)
  801038:	108000cc 	andi	r2,r2,3
  80103c:	10000526 	beq	r2,zero,801054 <pvPortMalloc+0x38>
		{
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
  801040:	e0ffff17 	ldw	r3,-4(fp)
  801044:	00bfff04 	movi	r2,-4
  801048:	1884703a 	and	r2,r3,r2
  80104c:	10800104 	addi	r2,r2,4
  801050:	e0bfff15 	stw	r2,-4(fp)
		}
	}
	#endif

	vTaskSuspendAll();
  801054:	08040940 	call	804094 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
  801058:	d0a50417 	ldw	r2,-27632(gp)
  80105c:	1000051e 	bne	r2,zero,801074 <pvPortMalloc+0x58>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
  801060:	00802074 	movhi	r2,129
  801064:	10affb04 	addi	r2,r2,-16404
  801068:	00ffff04 	movi	r3,-4
  80106c:	10c4703a 	and	r2,r2,r3
  801070:	d0a50415 	stw	r2,-27632(gp)
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
  801074:	d0e50317 	ldw	r3,-27636(gp)
  801078:	e0bfff17 	ldw	r2,-4(fp)
  80107c:	1887883a 	add	r3,r3,r2
  801080:	00800134 	movhi	r2,4
  801084:	10b422c4 	addi	r2,r2,-12149
  801088:	10c00d36 	bltu	r2,r3,8010c0 <pvPortMalloc+0xa4>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
  80108c:	d0e50317 	ldw	r3,-27636(gp)
  801090:	e0bfff17 	ldw	r2,-4(fp)
  801094:	1885883a 	add	r2,r3,r2
  801098:	d0e50317 	ldw	r3,-27636(gp)
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
  80109c:	1880082e 	bgeu	r3,r2,8010c0 <pvPortMalloc+0xa4>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
  8010a0:	d0e50417 	ldw	r3,-27632(gp)
  8010a4:	d0a50317 	ldw	r2,-27636(gp)
  8010a8:	1885883a 	add	r2,r3,r2
  8010ac:	e0bffe15 	stw	r2,-8(fp)
			xNextFreeByte += xWantedSize;
  8010b0:	d0e50317 	ldw	r3,-27636(gp)
  8010b4:	e0bfff17 	ldw	r2,-4(fp)
  8010b8:	1885883a 	add	r2,r3,r2
  8010bc:	d0a50315 	stw	r2,-27636(gp)
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
  8010c0:	08040c00 	call	8040c0 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
  8010c4:	e0bffe17 	ldw	r2,-8(fp)
}
  8010c8:	e037883a 	mov	sp,fp
  8010cc:	dfc00117 	ldw	ra,4(sp)
  8010d0:	df000017 	ldw	fp,0(sp)
  8010d4:	dec00204 	addi	sp,sp,8
  8010d8:	f800283a 	ret

008010dc <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
  8010dc:	defffe04 	addi	sp,sp,-8
  8010e0:	df000115 	stw	fp,4(sp)
  8010e4:	df000104 	addi	fp,sp,4
  8010e8:	e13fff15 	stw	r4,-4(fp)
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
  8010ec:	0001883a 	nop
  8010f0:	e037883a 	mov	sp,fp
  8010f4:	df000017 	ldw	fp,0(sp)
  8010f8:	dec00104 	addi	sp,sp,4
  8010fc:	f800283a 	ret

00801100 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
  801100:	deffff04 	addi	sp,sp,-4
  801104:	df000015 	stw	fp,0(sp)
  801108:	d839883a 	mov	fp,sp
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
  80110c:	d0250315 	stw	zero,-27636(gp)
}
  801110:	0001883a 	nop
  801114:	e037883a 	mov	sp,fp
  801118:	df000017 	ldw	fp,0(sp)
  80111c:	dec00104 	addi	sp,sp,4
  801120:	f800283a 	ret

00801124 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
  801124:	deffff04 	addi	sp,sp,-4
  801128:	df000015 	stw	fp,0(sp)
  80112c:	d839883a 	mov	fp,sp
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
  801130:	d0e50317 	ldw	r3,-27636(gp)
  801134:	00800134 	movhi	r2,4
  801138:	10b42304 	addi	r2,r2,-12148
  80113c:	10c5c83a 	sub	r2,r2,r3
}
  801140:	e037883a 	mov	sp,fp
  801144:	df000017 	ldw	fp,0(sp)
  801148:	dec00104 	addi	sp,sp,4
  80114c:	f800283a 	ret

00801150 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
  801150:	defffb04 	addi	sp,sp,-20
  801154:	dfc00415 	stw	ra,16(sp)
  801158:	df000315 	stw	fp,12(sp)
  80115c:	df000304 	addi	fp,sp,12
  801160:	e13ffe15 	stw	r4,-8(fp)
  801164:	e17fff15 	stw	r5,-4(fp)
Queue_t * const pxQueue = xQueue;
  801168:	e0bffe17 	ldw	r2,-8(fp)
  80116c:	e0bffd15 	stw	r2,-12(fp)

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
  801170:	0804ff40 	call	804ff4 <vTaskEnterCritical>
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
  801174:	e0bffd17 	ldw	r2,-12(fp)
  801178:	10c00017 	ldw	r3,0(r2)
  80117c:	e0bffd17 	ldw	r2,-12(fp)
  801180:	11000f17 	ldw	r4,60(r2)
  801184:	e0bffd17 	ldw	r2,-12(fp)
  801188:	10801017 	ldw	r2,64(r2)
  80118c:	2085383a 	mul	r2,r4,r2
  801190:	1887883a 	add	r3,r3,r2
  801194:	e0bffd17 	ldw	r2,-12(fp)
  801198:	10c00215 	stw	r3,8(r2)
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
  80119c:	e0bffd17 	ldw	r2,-12(fp)
  8011a0:	10000e15 	stw	zero,56(r2)
		pxQueue->pcWriteTo = pxQueue->pcHead;
  8011a4:	e0bffd17 	ldw	r2,-12(fp)
  8011a8:	10c00017 	ldw	r3,0(r2)
  8011ac:	e0bffd17 	ldw	r2,-12(fp)
  8011b0:	10c00115 	stw	r3,4(r2)
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
  8011b4:	e0bffd17 	ldw	r2,-12(fp)
  8011b8:	10c00017 	ldw	r3,0(r2)
  8011bc:	e0bffd17 	ldw	r2,-12(fp)
  8011c0:	10800f17 	ldw	r2,60(r2)
  8011c4:	113fffc4 	addi	r4,r2,-1
  8011c8:	e0bffd17 	ldw	r2,-12(fp)
  8011cc:	10801017 	ldw	r2,64(r2)
  8011d0:	2085383a 	mul	r2,r4,r2
  8011d4:	1887883a 	add	r3,r3,r2
  8011d8:	e0bffd17 	ldw	r2,-12(fp)
  8011dc:	10c00315 	stw	r3,12(r2)
		pxQueue->cRxLock = queueUNLOCKED;
  8011e0:	e0bffd17 	ldw	r2,-12(fp)
  8011e4:	00ffffc4 	movi	r3,-1
  8011e8:	10c01105 	stb	r3,68(r2)
		pxQueue->cTxLock = queueUNLOCKED;
  8011ec:	e0bffd17 	ldw	r2,-12(fp)
  8011f0:	00ffffc4 	movi	r3,-1
  8011f4:	10c01145 	stb	r3,69(r2)

		if( xNewQueue == pdFALSE )
  8011f8:	e0bfff17 	ldw	r2,-4(fp)
  8011fc:	10000a1e 	bne	r2,zero,801228 <xQueueGenericReset+0xd8>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  801200:	e0bffd17 	ldw	r2,-12(fp)
  801204:	10800417 	ldw	r2,16(r2)
  801208:	10000f26 	beq	r2,zero,801248 <xQueueGenericReset+0xf8>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  80120c:	e0bffd17 	ldw	r2,-12(fp)
  801210:	10800404 	addi	r2,r2,16
  801214:	1009883a 	mov	r4,r2
  801218:	08046540 	call	804654 <xTaskRemoveFromEventList>
  80121c:	10000a26 	beq	r2,zero,801248 <xQueueGenericReset+0xf8>
				{
					queueYIELD_IF_USING_PREEMPTION();
  801220:	003b683a 	trap	0
  801224:	00000806 	br	801248 <xQueueGenericReset+0xf8>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
  801228:	e0bffd17 	ldw	r2,-12(fp)
  80122c:	10800404 	addi	r2,r2,16
  801230:	1009883a 	mov	r4,r2
  801234:	08009a00 	call	8009a0 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
  801238:	e0bffd17 	ldw	r2,-12(fp)
  80123c:	10800904 	addi	r2,r2,36
  801240:	1009883a 	mov	r4,r2
  801244:	08009a00 	call	8009a0 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
  801248:	08050480 	call	805048 <vTaskExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
  80124c:	00800044 	movi	r2,1
}
  801250:	e037883a 	mov	sp,fp
  801254:	dfc00117 	ldw	ra,4(sp)
  801258:	df000017 	ldw	fp,0(sp)
  80125c:	dec00204 	addi	sp,sp,8
  801260:	f800283a 	ret

00801264 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
  801264:	defff704 	addi	sp,sp,-36
  801268:	dfc00815 	stw	ra,32(sp)
  80126c:	df000715 	stw	fp,28(sp)
  801270:	df000704 	addi	fp,sp,28
  801274:	e13ffd15 	stw	r4,-12(fp)
  801278:	e17ffe15 	stw	r5,-8(fp)
  80127c:	3005883a 	mov	r2,r6
  801280:	e0bfff05 	stb	r2,-4(fp)
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		/* Allocate enough space to hold the maximum number of items that
		can be in the queue at any time.  It is valid for uxItemSize to be
		zero in the case the queue is used as a semaphore. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  801284:	e0fffd17 	ldw	r3,-12(fp)
  801288:	e0bffe17 	ldw	r2,-8(fp)
  80128c:	1885383a 	mul	r2,r3,r2
  801290:	e0bffa15 	stw	r2,-24(fp)
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
  801294:	e0bffa17 	ldw	r2,-24(fp)
  801298:	10801204 	addi	r2,r2,72
  80129c:	1009883a 	mov	r4,r2
  8012a0:	080101c0 	call	80101c <pvPortMalloc>
  8012a4:	e0bffb15 	stw	r2,-20(fp)

		if( pxNewQueue != NULL )
  8012a8:	e0bffb17 	ldw	r2,-20(fp)
  8012ac:	10000d26 	beq	r2,zero,8012e4 <xQueueGenericCreate+0x80>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
  8012b0:	e0bffb17 	ldw	r2,-20(fp)
  8012b4:	e0bffc15 	stw	r2,-16(fp)
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
  8012b8:	e0bffc17 	ldw	r2,-16(fp)
  8012bc:	10801204 	addi	r2,r2,72
  8012c0:	e0bffc15 	stw	r2,-16(fp)
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
  8012c4:	e0ffff03 	ldbu	r3,-4(fp)
  8012c8:	e0bffb17 	ldw	r2,-20(fp)
  8012cc:	d8800015 	stw	r2,0(sp)
  8012d0:	180f883a 	mov	r7,r3
  8012d4:	e1bffc17 	ldw	r6,-16(fp)
  8012d8:	e17ffe17 	ldw	r5,-8(fp)
  8012dc:	e13ffd17 	ldw	r4,-12(fp)
  8012e0:	08012fc0 	call	8012fc <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
  8012e4:	e0bffb17 	ldw	r2,-20(fp)
	}
  8012e8:	e037883a 	mov	sp,fp
  8012ec:	dfc00117 	ldw	ra,4(sp)
  8012f0:	df000017 	ldw	fp,0(sp)
  8012f4:	dec00204 	addi	sp,sp,8
  8012f8:	f800283a 	ret

008012fc <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
  8012fc:	defffa04 	addi	sp,sp,-24
  801300:	dfc00515 	stw	ra,20(sp)
  801304:	df000415 	stw	fp,16(sp)
  801308:	df000404 	addi	fp,sp,16
  80130c:	e13ffc15 	stw	r4,-16(fp)
  801310:	e17ffd15 	stw	r5,-12(fp)
  801314:	e1bffe15 	stw	r6,-8(fp)
  801318:	3805883a 	mov	r2,r7
  80131c:	e0bfff05 	stb	r2,-4(fp)
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
  801320:	e0bffd17 	ldw	r2,-12(fp)
  801324:	1000041e 	bne	r2,zero,801338 <prvInitialiseNewQueue+0x3c>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
  801328:	e0800217 	ldw	r2,8(fp)
  80132c:	e0c00217 	ldw	r3,8(fp)
  801330:	10c00015 	stw	r3,0(r2)
  801334:	00000306 	br	801344 <prvInitialiseNewQueue+0x48>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
  801338:	e0800217 	ldw	r2,8(fp)
  80133c:	e0fffe17 	ldw	r3,-8(fp)
  801340:	10c00015 	stw	r3,0(r2)
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
  801344:	e0800217 	ldw	r2,8(fp)
  801348:	e0fffc17 	ldw	r3,-16(fp)
  80134c:	10c00f15 	stw	r3,60(r2)
	pxNewQueue->uxItemSize = uxItemSize;
  801350:	e0800217 	ldw	r2,8(fp)
  801354:	e0fffd17 	ldw	r3,-12(fp)
  801358:	10c01015 	stw	r3,64(r2)
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
  80135c:	01400044 	movi	r5,1
  801360:	e1000217 	ldw	r4,8(fp)
  801364:	08011500 	call	801150 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
  801368:	0001883a 	nop
  80136c:	e037883a 	mov	sp,fp
  801370:	dfc00117 	ldw	ra,4(sp)
  801374:	df000017 	ldw	fp,0(sp)
  801378:	dec00204 	addi	sp,sp,8
  80137c:	f800283a 	ret

00801380 <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
  801380:	defffd04 	addi	sp,sp,-12
  801384:	dfc00215 	stw	ra,8(sp)
  801388:	df000115 	stw	fp,4(sp)
  80138c:	df000104 	addi	fp,sp,4
  801390:	e13fff15 	stw	r4,-4(fp)
		if( pxNewQueue != NULL )
  801394:	e0bfff17 	ldw	r2,-4(fp)
  801398:	10000b26 	beq	r2,zero,8013c8 <prvInitialiseMutex+0x48>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
  80139c:	e0bfff17 	ldw	r2,-4(fp)
  8013a0:	10000215 	stw	zero,8(r2)
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
  8013a4:	e0bfff17 	ldw	r2,-4(fp)
  8013a8:	10000015 	stw	zero,0(r2)

			/* In case this is a recursive mutex. */
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
  8013ac:	e0bfff17 	ldw	r2,-4(fp)
  8013b0:	10000315 	stw	zero,12(r2)

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
  8013b4:	000f883a 	mov	r7,zero
  8013b8:	000d883a 	mov	r6,zero
  8013bc:	000b883a 	mov	r5,zero
  8013c0:	e13fff17 	ldw	r4,-4(fp)
  8013c4:	08015c00 	call	8015c0 <xQueueGenericSend>
		}
		else
		{
			traceCREATE_MUTEX_FAILED();
		}
	}
  8013c8:	0001883a 	nop
  8013cc:	e037883a 	mov	sp,fp
  8013d0:	dfc00117 	ldw	ra,4(sp)
  8013d4:	df000017 	ldw	fp,0(sp)
  8013d8:	dec00204 	addi	sp,sp,8
  8013dc:	f800283a 	ret

008013e0 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
  8013e0:	defffa04 	addi	sp,sp,-24
  8013e4:	dfc00515 	stw	ra,20(sp)
  8013e8:	df000415 	stw	fp,16(sp)
  8013ec:	df000404 	addi	fp,sp,16
  8013f0:	2005883a 	mov	r2,r4
  8013f4:	e0bfff05 	stb	r2,-4(fp)
	QueueHandle_t xNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
  8013f8:	00800044 	movi	r2,1
  8013fc:	e0bffc15 	stw	r2,-16(fp)
  801400:	e03ffd15 	stw	zero,-12(fp)

		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
  801404:	e0bfff03 	ldbu	r2,-4(fp)
  801408:	100d883a 	mov	r6,r2
  80140c:	e17ffd17 	ldw	r5,-12(fp)
  801410:	e13ffc17 	ldw	r4,-16(fp)
  801414:	08012640 	call	801264 <xQueueGenericCreate>
  801418:	e0bffe15 	stw	r2,-8(fp)
		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
  80141c:	e13ffe17 	ldw	r4,-8(fp)
  801420:	08013800 	call	801380 <prvInitialiseMutex>

		return xNewQueue;
  801424:	e0bffe17 	ldw	r2,-8(fp)
	}
  801428:	e037883a 	mov	sp,fp
  80142c:	dfc00117 	ldw	ra,4(sp)
  801430:	df000017 	ldw	fp,0(sp)
  801434:	dec00204 	addi	sp,sp,8
  801438:	f800283a 	ret

0080143c <xQueueGiveMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
	{
  80143c:	defffa04 	addi	sp,sp,-24
  801440:	dfc00515 	stw	ra,20(sp)
  801444:	df000415 	stw	fp,16(sp)
  801448:	dc000315 	stw	r16,12(sp)
  80144c:	df000404 	addi	fp,sp,16
  801450:	e13ffe15 	stw	r4,-8(fp)
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
  801454:	e0bffe17 	ldw	r2,-8(fp)
  801458:	e0bffd15 	stw	r2,-12(fp)
		change outside of this task.  If this task does not hold the mutex then
		pxMutexHolder can never coincidentally equal the tasks handle, and as
		this is the only condition we are interested in it does not matter if
		pxMutexHolder is accessed simultaneously by another task.  Therefore no
		mutual exclusion is required to test the pxMutexHolder variable. */
		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
  80145c:	e0bffd17 	ldw	r2,-12(fp)
  801460:	14000217 	ldw	r16,8(r2)
  801464:	0804c500 	call	804c50 <xTaskGetCurrentTaskHandle>
  801468:	8080101e 	bne	r16,r2,8014ac <xQueueGiveMutexRecursive+0x70>
			/* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
			the task handle, therefore no underflow check is required.  Also,
			uxRecursiveCallCount is only modified by the mutex holder, and as
			there can only be one, no mutual exclusion is required to modify the
			uxRecursiveCallCount member. */
			( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
  80146c:	e0bffd17 	ldw	r2,-12(fp)
  801470:	10800317 	ldw	r2,12(r2)
  801474:	10ffffc4 	addi	r3,r2,-1
  801478:	e0bffd17 	ldw	r2,-12(fp)
  80147c:	10c00315 	stw	r3,12(r2)

			/* Has the recursive call count unwound to 0? */
			if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
  801480:	e0bffd17 	ldw	r2,-12(fp)
  801484:	10800317 	ldw	r2,12(r2)
  801488:	1000051e 	bne	r2,zero,8014a0 <xQueueGiveMutexRecursive+0x64>
			{
				/* Return the mutex.  This will automatically unblock any other
				task that might be waiting to access the mutex. */
				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
  80148c:	000f883a 	mov	r7,zero
  801490:	000d883a 	mov	r6,zero
  801494:	000b883a 	mov	r5,zero
  801498:	e13ffd17 	ldw	r4,-12(fp)
  80149c:	08015c00 	call	8015c0 <xQueueGenericSend>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
  8014a0:	00800044 	movi	r2,1
  8014a4:	e0bffc15 	stw	r2,-16(fp)
  8014a8:	00000106 	br	8014b0 <xQueueGiveMutexRecursive+0x74>
		}
		else
		{
			/* The mutex cannot be given because the calling task is not the
			holder. */
			xReturn = pdFAIL;
  8014ac:	e03ffc15 	stw	zero,-16(fp)

			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
		}

		return xReturn;
  8014b0:	e0bffc17 	ldw	r2,-16(fp)
	}
  8014b4:	e6ffff04 	addi	sp,fp,-4
  8014b8:	dfc00217 	ldw	ra,8(sp)
  8014bc:	df000117 	ldw	fp,4(sp)
  8014c0:	dc000017 	ldw	r16,0(sp)
  8014c4:	dec00304 	addi	sp,sp,12
  8014c8:	f800283a 	ret

008014cc <xQueueTakeMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
	{
  8014cc:	defff904 	addi	sp,sp,-28
  8014d0:	dfc00615 	stw	ra,24(sp)
  8014d4:	df000515 	stw	fp,20(sp)
  8014d8:	dc000415 	stw	r16,16(sp)
  8014dc:	df000504 	addi	fp,sp,20
  8014e0:	e13ffd15 	stw	r4,-12(fp)
  8014e4:	e17ffe15 	stw	r5,-8(fp)
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
  8014e8:	e0bffd17 	ldw	r2,-12(fp)
  8014ec:	e0bffc15 	stw	r2,-16(fp)
		/* Comments regarding mutual exclusion as per those within
		xQueueGiveMutexRecursive(). */

		traceTAKE_MUTEX_RECURSIVE( pxMutex );

		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
  8014f0:	e0bffc17 	ldw	r2,-16(fp)
  8014f4:	14000217 	ldw	r16,8(r2)
  8014f8:	0804c500 	call	804c50 <xTaskGetCurrentTaskHandle>
  8014fc:	8080081e 	bne	r16,r2,801520 <xQueueTakeMutexRecursive+0x54>
		{
			( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
  801500:	e0bffc17 	ldw	r2,-16(fp)
  801504:	10800317 	ldw	r2,12(r2)
  801508:	10c00044 	addi	r3,r2,1
  80150c:	e0bffc17 	ldw	r2,-16(fp)
  801510:	10c00315 	stw	r3,12(r2)
			xReturn = pdPASS;
  801514:	00800044 	movi	r2,1
  801518:	e0bffb15 	stw	r2,-20(fp)
  80151c:	00000b06 	br	80154c <xQueueTakeMutexRecursive+0x80>
		}
		else
		{
			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
  801520:	e17ffe17 	ldw	r5,-8(fp)
  801524:	e13ffc17 	ldw	r4,-16(fp)
  801528:	0801aec0 	call	801aec <xQueueSemaphoreTake>
  80152c:	e0bffb15 	stw	r2,-20(fp)

			/* pdPASS will only be returned if the mutex was successfully
			obtained.  The calling task may have entered the Blocked state
			before reaching here. */
			if( xReturn != pdFAIL )
  801530:	e0bffb17 	ldw	r2,-20(fp)
  801534:	10000526 	beq	r2,zero,80154c <xQueueTakeMutexRecursive+0x80>
			{
				( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
  801538:	e0bffc17 	ldw	r2,-16(fp)
  80153c:	10800317 	ldw	r2,12(r2)
  801540:	10c00044 	addi	r3,r2,1
  801544:	e0bffc17 	ldw	r2,-16(fp)
  801548:	10c00315 	stw	r3,12(r2)
			{
				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
			}
		}

		return xReturn;
  80154c:	e0bffb17 	ldw	r2,-20(fp)
	}
  801550:	e6ffff04 	addi	sp,fp,-4
  801554:	dfc00217 	ldw	ra,8(sp)
  801558:	df000117 	ldw	fp,4(sp)
  80155c:	dc000017 	ldw	r16,0(sp)
  801560:	dec00304 	addi	sp,sp,12
  801564:	f800283a 	ret

00801568 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
  801568:	defffb04 	addi	sp,sp,-20
  80156c:	dfc00415 	stw	ra,16(sp)
  801570:	df000315 	stw	fp,12(sp)
  801574:	df000304 	addi	fp,sp,12
  801578:	e13ffe15 	stw	r4,-8(fp)
  80157c:	e17fff15 	stw	r5,-4(fp)
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
		configASSERT( uxInitialCount <= uxMaxCount );

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
  801580:	01800084 	movi	r6,2
  801584:	000b883a 	mov	r5,zero
  801588:	e13ffe17 	ldw	r4,-8(fp)
  80158c:	08012640 	call	801264 <xQueueGenericCreate>
  801590:	e0bffd15 	stw	r2,-12(fp)

		if( xHandle != NULL )
  801594:	e0bffd17 	ldw	r2,-12(fp)
  801598:	10000326 	beq	r2,zero,8015a8 <xQueueCreateCountingSemaphore+0x40>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
  80159c:	e0bffd17 	ldw	r2,-12(fp)
  8015a0:	e0ffff17 	ldw	r3,-4(fp)
  8015a4:	10c00e15 	stw	r3,56(r2)
		else
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		return xHandle;
  8015a8:	e0bffd17 	ldw	r2,-12(fp)
	}
  8015ac:	e037883a 	mov	sp,fp
  8015b0:	dfc00117 	ldw	ra,4(sp)
  8015b4:	df000017 	ldw	fp,0(sp)
  8015b8:	dec00204 	addi	sp,sp,8
  8015bc:	f800283a 	ret

008015c0 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
  8015c0:	defff504 	addi	sp,sp,-44
  8015c4:	dfc00a15 	stw	ra,40(sp)
  8015c8:	df000915 	stw	fp,36(sp)
  8015cc:	df000904 	addi	fp,sp,36
  8015d0:	e13ffc15 	stw	r4,-16(fp)
  8015d4:	e17ffd15 	stw	r5,-12(fp)
  8015d8:	e1bffe15 	stw	r6,-8(fp)
  8015dc:	e1ffff15 	stw	r7,-4(fp)
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
  8015e0:	e03ff715 	stw	zero,-36(fp)
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
  8015e4:	e0bffc17 	ldw	r2,-16(fp)
  8015e8:	e0bff815 	stw	r2,-32(fp)
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
  8015ec:	0804ff40 	call	804ff4 <vTaskEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
  8015f0:	e0bff817 	ldw	r2,-32(fp)
  8015f4:	10c00e17 	ldw	r3,56(r2)
  8015f8:	e0bff817 	ldw	r2,-32(fp)
  8015fc:	10800f17 	ldw	r2,60(r2)
  801600:	18800336 	bltu	r3,r2,801610 <xQueueGenericSend+0x50>
  801604:	e0bfff17 	ldw	r2,-4(fp)
  801608:	10800098 	cmpnei	r2,r2,2
  80160c:	1000151e 	bne	r2,zero,801664 <xQueueGenericSend+0xa4>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  801610:	e1bfff17 	ldw	r6,-4(fp)
  801614:	e17ffd17 	ldw	r5,-12(fp)
  801618:	e13ff817 	ldw	r4,-32(fp)
  80161c:	08021640 	call	802164 <prvCopyDataToQueue>
  801620:	e0bff915 	stw	r2,-28(fp)

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  801624:	e0bff817 	ldw	r2,-32(fp)
  801628:	10800917 	ldw	r2,36(r2)
  80162c:	10000726 	beq	r2,zero,80164c <xQueueGenericSend+0x8c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  801630:	e0bff817 	ldw	r2,-32(fp)
  801634:	10800904 	addi	r2,r2,36
  801638:	1009883a 	mov	r4,r2
  80163c:	08046540 	call	804654 <xTaskRemoveFromEventList>
  801640:	10000526 	beq	r2,zero,801658 <xQueueGenericSend+0x98>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
  801644:	003b683a 	trap	0
  801648:	00000306 	br	801658 <xQueueGenericSend+0x98>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
  80164c:	e0bff917 	ldw	r2,-28(fp)
  801650:	10000126 	beq	r2,zero,801658 <xQueueGenericSend+0x98>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
  801654:	003b683a 	trap	0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
  801658:	08050480 	call	805048 <vTaskExitCritical>
				return pdPASS;
  80165c:	00800044 	movi	r2,1
  801660:	00003f06 	br	801760 <xQueueGenericSend+0x1a0>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
  801664:	e0bffe17 	ldw	r2,-8(fp)
  801668:	1000031e 	bne	r2,zero,801678 <xQueueGenericSend+0xb8>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
  80166c:	08050480 	call	805048 <vTaskExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
  801670:	0005883a 	mov	r2,zero
  801674:	00003a06 	br	801760 <xQueueGenericSend+0x1a0>
				}
				else if( xEntryTimeSet == pdFALSE )
  801678:	e0bff717 	ldw	r2,-36(fp)
  80167c:	1000051e 	bne	r2,zero,801694 <xQueueGenericSend+0xd4>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
  801680:	e0bffa04 	addi	r2,fp,-24
  801684:	1009883a 	mov	r4,r2
  801688:	080485c0 	call	80485c <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
  80168c:	00800044 	movi	r2,1
  801690:	e0bff715 	stw	r2,-36(fp)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
  801694:	08050480 	call	805048 <vTaskExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  801698:	08040940 	call	804094 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
  80169c:	0804ff40 	call	804ff4 <vTaskEnterCritical>
  8016a0:	e0bff817 	ldw	r2,-32(fp)
  8016a4:	10801103 	ldbu	r2,68(r2)
  8016a8:	10803fcc 	andi	r2,r2,255
  8016ac:	1080201c 	xori	r2,r2,128
  8016b0:	10bfe004 	addi	r2,r2,-128
  8016b4:	10bfffd8 	cmpnei	r2,r2,-1
  8016b8:	1000021e 	bne	r2,zero,8016c4 <xQueueGenericSend+0x104>
  8016bc:	e0bff817 	ldw	r2,-32(fp)
  8016c0:	10001105 	stb	zero,68(r2)
  8016c4:	e0bff817 	ldw	r2,-32(fp)
  8016c8:	10801143 	ldbu	r2,69(r2)
  8016cc:	10803fcc 	andi	r2,r2,255
  8016d0:	1080201c 	xori	r2,r2,128
  8016d4:	10bfe004 	addi	r2,r2,-128
  8016d8:	10bfffd8 	cmpnei	r2,r2,-1
  8016dc:	1000021e 	bne	r2,zero,8016e8 <xQueueGenericSend+0x128>
  8016e0:	e0bff817 	ldw	r2,-32(fp)
  8016e4:	10001145 	stb	zero,69(r2)
  8016e8:	08050480 	call	805048 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  8016ec:	e0fffe04 	addi	r3,fp,-8
  8016f0:	e0bffa04 	addi	r2,fp,-24
  8016f4:	180b883a 	mov	r5,r3
  8016f8:	1009883a 	mov	r4,r2
  8016fc:	08048980 	call	804898 <xTaskCheckForTimeOut>
  801700:	1000131e 	bne	r2,zero,801750 <xQueueGenericSend+0x190>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
  801704:	e13ff817 	ldw	r4,-32(fp)
  801708:	08025180 	call	802518 <prvIsQueueFull>
  80170c:	10000c26 	beq	r2,zero,801740 <xQueueGenericSend+0x180>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
  801710:	e0bff817 	ldw	r2,-32(fp)
  801714:	10800404 	addi	r2,r2,16
  801718:	e0fffe17 	ldw	r3,-8(fp)
  80171c:	180b883a 	mov	r5,r3
  801720:	1009883a 	mov	r4,r2
  801724:	08045a00 	call	8045a0 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
  801728:	e13ff817 	ldw	r4,-32(fp)
  80172c:	080238c0 	call	80238c <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
  801730:	08040c00 	call	8040c0 <xTaskResumeAll>
  801734:	103fad1e 	bne	r2,zero,8015ec <__alt_mem_onchip_memory2_0+0xff7815ec>
				{
					portYIELD_WITHIN_API();
  801738:	003b683a 	trap	0
  80173c:	003fab06 	br	8015ec <__alt_mem_onchip_memory2_0+0xff7815ec>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
  801740:	e13ff817 	ldw	r4,-32(fp)
  801744:	080238c0 	call	80238c <prvUnlockQueue>
				( void ) xTaskResumeAll();
  801748:	08040c00 	call	8040c0 <xTaskResumeAll>
  80174c:	003fa706 	br	8015ec <__alt_mem_onchip_memory2_0+0xff7815ec>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
  801750:	e13ff817 	ldw	r4,-32(fp)
  801754:	080238c0 	call	80238c <prvUnlockQueue>
			( void ) xTaskResumeAll();
  801758:	08040c00 	call	8040c0 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
  80175c:	0005883a 	mov	r2,zero
		}
	} /*lint -restore */
}
  801760:	e037883a 	mov	sp,fp
  801764:	dfc00117 	ldw	ra,4(sp)
  801768:	df000017 	ldw	fp,0(sp)
  80176c:	dec00204 	addi	sp,sp,8
  801770:	f800283a 	ret

00801774 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
  801774:	defff504 	addi	sp,sp,-44
  801778:	dfc00a15 	stw	ra,40(sp)
  80177c:	df000915 	stw	fp,36(sp)
  801780:	df000904 	addi	fp,sp,36
  801784:	e13ffc15 	stw	r4,-16(fp)
  801788:	e17ffd15 	stw	r5,-12(fp)
  80178c:	e1bffe15 	stw	r6,-8(fp)
  801790:	e1ffff15 	stw	r7,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
  801794:	e0bffc17 	ldw	r2,-16(fp)
  801798:	e0bff815 	stw	r2,-32(fp)
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  80179c:	e03ff915 	stw	zero,-28(fp)
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
  8017a0:	e0bff817 	ldw	r2,-32(fp)
  8017a4:	10c00e17 	ldw	r3,56(r2)
  8017a8:	e0bff817 	ldw	r2,-32(fp)
  8017ac:	10800f17 	ldw	r2,60(r2)
  8017b0:	18800336 	bltu	r3,r2,8017c0 <xQueueGenericSendFromISR+0x4c>
  8017b4:	e0bfff17 	ldw	r2,-4(fp)
  8017b8:	10800098 	cmpnei	r2,r2,2
  8017bc:	1000231e 	bne	r2,zero,80184c <xQueueGenericSendFromISR+0xd8>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
  8017c0:	e0bff817 	ldw	r2,-32(fp)
  8017c4:	10801143 	ldbu	r2,69(r2)
  8017c8:	e0bffa05 	stb	r2,-24(fp)
			const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
  8017cc:	e0bff817 	ldw	r2,-32(fp)
  8017d0:	10800e17 	ldw	r2,56(r2)
  8017d4:	e0bffb15 	stw	r2,-20(fp)
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  8017d8:	e1bfff17 	ldw	r6,-4(fp)
  8017dc:	e17ffd17 	ldw	r5,-12(fp)
  8017e0:	e13ff817 	ldw	r4,-32(fp)
  8017e4:	08021640 	call	802164 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
  8017e8:	e0bffa07 	ldb	r2,-24(fp)
  8017ec:	10bfffd8 	cmpnei	r2,r2,-1
  8017f0:	10000e1e 	bne	r2,zero,80182c <xQueueGenericSendFromISR+0xb8>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  8017f4:	e0bff817 	ldw	r2,-32(fp)
  8017f8:	10800917 	ldw	r2,36(r2)
  8017fc:	10001026 	beq	r2,zero,801840 <xQueueGenericSendFromISR+0xcc>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  801800:	e0bff817 	ldw	r2,-32(fp)
  801804:	10800904 	addi	r2,r2,36
  801808:	1009883a 	mov	r4,r2
  80180c:	08046540 	call	804654 <xTaskRemoveFromEventList>
  801810:	10000b26 	beq	r2,zero,801840 <xQueueGenericSendFromISR+0xcc>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
  801814:	e0bffe17 	ldw	r2,-8(fp)
  801818:	10000926 	beq	r2,zero,801840 <xQueueGenericSendFromISR+0xcc>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
  80181c:	e0bffe17 	ldw	r2,-8(fp)
  801820:	00c00044 	movi	r3,1
  801824:	10c00015 	stw	r3,0(r2)
  801828:	00000506 	br	801840 <xQueueGenericSendFromISR+0xcc>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
  80182c:	e0bffa03 	ldbu	r2,-24(fp)
  801830:	10800044 	addi	r2,r2,1
  801834:	1007883a 	mov	r3,r2
  801838:	e0bff817 	ldw	r2,-32(fp)
  80183c:	10c01145 	stb	r3,69(r2)
			}

			xReturn = pdPASS;
  801840:	00800044 	movi	r2,1
  801844:	e0bff715 	stw	r2,-36(fp)
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
		{
  801848:	00000106 	br	801850 <xQueueGenericSendFromISR+0xdc>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
  80184c:	e03ff715 	stw	zero,-36(fp)
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
  801850:	e0bff717 	ldw	r2,-36(fp)
}
  801854:	e037883a 	mov	sp,fp
  801858:	dfc00117 	ldw	ra,4(sp)
  80185c:	df000017 	ldw	fp,0(sp)
  801860:	dec00204 	addi	sp,sp,8
  801864:	f800283a 	ret

00801868 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
  801868:	defff704 	addi	sp,sp,-36
  80186c:	dfc00815 	stw	ra,32(sp)
  801870:	df000715 	stw	fp,28(sp)
  801874:	df000704 	addi	fp,sp,28
  801878:	e13ffe15 	stw	r4,-8(fp)
  80187c:	e17fff15 	stw	r5,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
  801880:	e0bffe17 	ldw	r2,-8(fp)
  801884:	e0bffa15 	stw	r2,-24(fp)
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  801888:	e03ffb15 	stw	zero,-20(fp)
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  80188c:	e0bffa17 	ldw	r2,-24(fp)
  801890:	10800e17 	ldw	r2,56(r2)
  801894:	e0bffc15 	stw	r2,-16(fp)

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
  801898:	e0bffa17 	ldw	r2,-24(fp)
  80189c:	10800f17 	ldw	r2,60(r2)
  8018a0:	e0fffc17 	ldw	r3,-16(fp)
  8018a4:	1880202e 	bgeu	r3,r2,801928 <xQueueGiveFromISR+0xc0>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
  8018a8:	e0bffa17 	ldw	r2,-24(fp)
  8018ac:	10801143 	ldbu	r2,69(r2)
  8018b0:	e0bffd05 	stb	r2,-12(fp)
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
  8018b4:	e0bffc17 	ldw	r2,-16(fp)
  8018b8:	10c00044 	addi	r3,r2,1
  8018bc:	e0bffa17 	ldw	r2,-24(fp)
  8018c0:	10c00e15 	stw	r3,56(r2)

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
  8018c4:	e0bffd07 	ldb	r2,-12(fp)
  8018c8:	10bfffd8 	cmpnei	r2,r2,-1
  8018cc:	10000e1e 	bne	r2,zero,801908 <xQueueGiveFromISR+0xa0>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  8018d0:	e0bffa17 	ldw	r2,-24(fp)
  8018d4:	10800917 	ldw	r2,36(r2)
  8018d8:	10001026 	beq	r2,zero,80191c <xQueueGiveFromISR+0xb4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  8018dc:	e0bffa17 	ldw	r2,-24(fp)
  8018e0:	10800904 	addi	r2,r2,36
  8018e4:	1009883a 	mov	r4,r2
  8018e8:	08046540 	call	804654 <xTaskRemoveFromEventList>
  8018ec:	10000b26 	beq	r2,zero,80191c <xQueueGiveFromISR+0xb4>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
  8018f0:	e0bfff17 	ldw	r2,-4(fp)
  8018f4:	10000926 	beq	r2,zero,80191c <xQueueGiveFromISR+0xb4>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
  8018f8:	e0bfff17 	ldw	r2,-4(fp)
  8018fc:	00c00044 	movi	r3,1
  801900:	10c00015 	stw	r3,0(r2)
  801904:	00000506 	br	80191c <xQueueGiveFromISR+0xb4>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
  801908:	e0bffd03 	ldbu	r2,-12(fp)
  80190c:	10800044 	addi	r2,r2,1
  801910:	1007883a 	mov	r3,r2
  801914:	e0bffa17 	ldw	r2,-24(fp)
  801918:	10c01145 	stb	r3,69(r2)
			}

			xReturn = pdPASS;
  80191c:	00800044 	movi	r2,1
  801920:	e0bff915 	stw	r2,-28(fp)
  801924:	00000106 	br	80192c <xQueueGiveFromISR+0xc4>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
  801928:	e03ff915 	stw	zero,-28(fp)
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
  80192c:	e0bff917 	ldw	r2,-28(fp)
}
  801930:	e037883a 	mov	sp,fp
  801934:	dfc00117 	ldw	ra,4(sp)
  801938:	df000017 	ldw	fp,0(sp)
  80193c:	dec00204 	addi	sp,sp,8
  801940:	f800283a 	ret

00801944 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
  801944:	defff604 	addi	sp,sp,-40
  801948:	dfc00915 	stw	ra,36(sp)
  80194c:	df000815 	stw	fp,32(sp)
  801950:	df000804 	addi	fp,sp,32
  801954:	e13ffd15 	stw	r4,-12(fp)
  801958:	e17ffe15 	stw	r5,-8(fp)
  80195c:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xEntryTimeSet = pdFALSE;
  801960:	e03ff815 	stw	zero,-32(fp)
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
  801964:	e0bffd17 	ldw	r2,-12(fp)
  801968:	e0bff915 	stw	r2,-28(fp)
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
  80196c:	0804ff40 	call	804ff4 <vTaskEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  801970:	e0bff917 	ldw	r2,-28(fp)
  801974:	10800e17 	ldw	r2,56(r2)
  801978:	e0bffa15 	stw	r2,-24(fp)

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
  80197c:	e0bffa17 	ldw	r2,-24(fp)
  801980:	10001326 	beq	r2,zero,8019d0 <xQueueReceive+0x8c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
  801984:	e17ffe17 	ldw	r5,-8(fp)
  801988:	e13ff917 	ldw	r4,-28(fp)
  80198c:	08022f00 	call	8022f0 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
  801990:	e0bffa17 	ldw	r2,-24(fp)
  801994:	10ffffc4 	addi	r3,r2,-1
  801998:	e0bff917 	ldw	r2,-28(fp)
  80199c:	10c00e15 	stw	r3,56(r2)

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  8019a0:	e0bff917 	ldw	r2,-28(fp)
  8019a4:	10800417 	ldw	r2,16(r2)
  8019a8:	10000626 	beq	r2,zero,8019c4 <xQueueReceive+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  8019ac:	e0bff917 	ldw	r2,-28(fp)
  8019b0:	10800404 	addi	r2,r2,16
  8019b4:	1009883a 	mov	r4,r2
  8019b8:	08046540 	call	804654 <xTaskRemoveFromEventList>
  8019bc:	10000126 	beq	r2,zero,8019c4 <xQueueReceive+0x80>
					{
						queueYIELD_IF_USING_PREEMPTION();
  8019c0:	003b683a 	trap	0
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
  8019c4:	08050480 	call	805048 <vTaskExitCritical>
				return pdPASS;
  8019c8:	00800044 	movi	r2,1
  8019cc:	00004206 	br	801ad8 <xQueueReceive+0x194>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
  8019d0:	e0bfff17 	ldw	r2,-4(fp)
  8019d4:	1000031e 	bne	r2,zero,8019e4 <xQueueReceive+0xa0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
  8019d8:	08050480 	call	805048 <vTaskExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
  8019dc:	0005883a 	mov	r2,zero
  8019e0:	00003d06 	br	801ad8 <xQueueReceive+0x194>
				}
				else if( xEntryTimeSet == pdFALSE )
  8019e4:	e0bff817 	ldw	r2,-32(fp)
  8019e8:	1000051e 	bne	r2,zero,801a00 <xQueueReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
  8019ec:	e0bffb04 	addi	r2,fp,-20
  8019f0:	1009883a 	mov	r4,r2
  8019f4:	080485c0 	call	80485c <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
  8019f8:	00800044 	movi	r2,1
  8019fc:	e0bff815 	stw	r2,-32(fp)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
  801a00:	08050480 	call	805048 <vTaskExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  801a04:	08040940 	call	804094 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
  801a08:	0804ff40 	call	804ff4 <vTaskEnterCritical>
  801a0c:	e0bff917 	ldw	r2,-28(fp)
  801a10:	10801103 	ldbu	r2,68(r2)
  801a14:	10803fcc 	andi	r2,r2,255
  801a18:	1080201c 	xori	r2,r2,128
  801a1c:	10bfe004 	addi	r2,r2,-128
  801a20:	10bfffd8 	cmpnei	r2,r2,-1
  801a24:	1000021e 	bne	r2,zero,801a30 <xQueueReceive+0xec>
  801a28:	e0bff917 	ldw	r2,-28(fp)
  801a2c:	10001105 	stb	zero,68(r2)
  801a30:	e0bff917 	ldw	r2,-28(fp)
  801a34:	10801143 	ldbu	r2,69(r2)
  801a38:	10803fcc 	andi	r2,r2,255
  801a3c:	1080201c 	xori	r2,r2,128
  801a40:	10bfe004 	addi	r2,r2,-128
  801a44:	10bfffd8 	cmpnei	r2,r2,-1
  801a48:	1000021e 	bne	r2,zero,801a54 <xQueueReceive+0x110>
  801a4c:	e0bff917 	ldw	r2,-28(fp)
  801a50:	10001145 	stb	zero,69(r2)
  801a54:	08050480 	call	805048 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  801a58:	e0ffff04 	addi	r3,fp,-4
  801a5c:	e0bffb04 	addi	r2,fp,-20
  801a60:	180b883a 	mov	r5,r3
  801a64:	1009883a 	mov	r4,r2
  801a68:	08048980 	call	804898 <xTaskCheckForTimeOut>
  801a6c:	1000131e 	bne	r2,zero,801abc <xQueueReceive+0x178>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
  801a70:	e13ff917 	ldw	r4,-28(fp)
  801a74:	08024800 	call	802480 <prvIsQueueEmpty>
  801a78:	10000c26 	beq	r2,zero,801aac <xQueueReceive+0x168>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  801a7c:	e0bff917 	ldw	r2,-28(fp)
  801a80:	10800904 	addi	r2,r2,36
  801a84:	e0ffff17 	ldw	r3,-4(fp)
  801a88:	180b883a 	mov	r5,r3
  801a8c:	1009883a 	mov	r4,r2
  801a90:	08045a00 	call	8045a0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
  801a94:	e13ff917 	ldw	r4,-28(fp)
  801a98:	080238c0 	call	80238c <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
  801a9c:	08040c00 	call	8040c0 <xTaskResumeAll>
  801aa0:	103fb21e 	bne	r2,zero,80196c <__alt_mem_onchip_memory2_0+0xff78196c>
				{
					portYIELD_WITHIN_API();
  801aa4:	003b683a 	trap	0
  801aa8:	003fb006 	br	80196c <__alt_mem_onchip_memory2_0+0xff78196c>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
  801aac:	e13ff917 	ldw	r4,-28(fp)
  801ab0:	080238c0 	call	80238c <prvUnlockQueue>
				( void ) xTaskResumeAll();
  801ab4:	08040c00 	call	8040c0 <xTaskResumeAll>
  801ab8:	003fac06 	br	80196c <__alt_mem_onchip_memory2_0+0xff78196c>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
  801abc:	e13ff917 	ldw	r4,-28(fp)
  801ac0:	080238c0 	call	80238c <prvUnlockQueue>
			( void ) xTaskResumeAll();
  801ac4:	08040c00 	call	8040c0 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
  801ac8:	e13ff917 	ldw	r4,-28(fp)
  801acc:	08024800 	call	802480 <prvIsQueueEmpty>
  801ad0:	103fa626 	beq	r2,zero,80196c <__alt_mem_onchip_memory2_0+0xff78196c>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
  801ad4:	0005883a 	mov	r2,zero
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
  801ad8:	e037883a 	mov	sp,fp
  801adc:	dfc00117 	ldw	ra,4(sp)
  801ae0:	df000017 	ldw	fp,0(sp)
  801ae4:	dec00204 	addi	sp,sp,8
  801ae8:	f800283a 	ret

00801aec <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
  801aec:	defff504 	addi	sp,sp,-44
  801af0:	dfc00a15 	stw	ra,40(sp)
  801af4:	df000915 	stw	fp,36(sp)
  801af8:	df000904 	addi	fp,sp,36
  801afc:	e13ffe15 	stw	r4,-8(fp)
  801b00:	e17fff15 	stw	r5,-4(fp)
BaseType_t xEntryTimeSet = pdFALSE;
  801b04:	e03ff715 	stw	zero,-36(fp)
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
  801b08:	e0bffe17 	ldw	r2,-8(fp)
  801b0c:	e0bff915 	stw	r2,-28(fp)

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
  801b10:	e03ff815 	stw	zero,-32(fp)
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
  801b14:	0804ff40 	call	804ff4 <vTaskEnterCritical>
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
  801b18:	e0bff917 	ldw	r2,-28(fp)
  801b1c:	10800e17 	ldw	r2,56(r2)
  801b20:	e0bffa15 	stw	r2,-24(fp)

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
  801b24:	e0bffa17 	ldw	r2,-24(fp)
  801b28:	10001726 	beq	r2,zero,801b88 <xQueueSemaphoreTake+0x9c>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
  801b2c:	e0bffa17 	ldw	r2,-24(fp)
  801b30:	10ffffc4 	addi	r3,r2,-1
  801b34:	e0bff917 	ldw	r2,-28(fp)
  801b38:	10c00e15 	stw	r3,56(r2)

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  801b3c:	e0bff917 	ldw	r2,-28(fp)
  801b40:	10800017 	ldw	r2,0(r2)
  801b44:	1000041e 	bne	r2,zero,801b58 <xQueueSemaphoreTake+0x6c>
					{
						/* Record the information required to implement
						priority inheritance should it become necessary. */
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
  801b48:	08050ec0 	call	8050ec <pvTaskIncrementMutexHeldCount>
  801b4c:	1007883a 	mov	r3,r2
  801b50:	e0bff917 	ldw	r2,-28(fp)
  801b54:	10c00215 	stw	r3,8(r2)
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  801b58:	e0bff917 	ldw	r2,-28(fp)
  801b5c:	10800417 	ldw	r2,16(r2)
  801b60:	10000626 	beq	r2,zero,801b7c <xQueueSemaphoreTake+0x90>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  801b64:	e0bff917 	ldw	r2,-28(fp)
  801b68:	10800404 	addi	r2,r2,16
  801b6c:	1009883a 	mov	r4,r2
  801b70:	08046540 	call	804654 <xTaskRemoveFromEventList>
  801b74:	10000126 	beq	r2,zero,801b7c <xQueueSemaphoreTake+0x90>
					{
						queueYIELD_IF_USING_PREEMPTION();
  801b78:	003b683a 	trap	0
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
  801b7c:	08050480 	call	805048 <vTaskExitCritical>
				return pdPASS;
  801b80:	00800044 	movi	r2,1
  801b84:	00005806 	br	801ce8 <xQueueSemaphoreTake+0x1fc>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
  801b88:	e0bfff17 	ldw	r2,-4(fp)
  801b8c:	1000031e 	bne	r2,zero,801b9c <xQueueSemaphoreTake+0xb0>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
  801b90:	08050480 	call	805048 <vTaskExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
  801b94:	0005883a 	mov	r2,zero
  801b98:	00005306 	br	801ce8 <xQueueSemaphoreTake+0x1fc>
				}
				else if( xEntryTimeSet == pdFALSE )
  801b9c:	e0bff717 	ldw	r2,-36(fp)
  801ba0:	1000051e 	bne	r2,zero,801bb8 <xQueueSemaphoreTake+0xcc>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
  801ba4:	e0bffc04 	addi	r2,fp,-16
  801ba8:	1009883a 	mov	r4,r2
  801bac:	080485c0 	call	80485c <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
  801bb0:	00800044 	movi	r2,1
  801bb4:	e0bff715 	stw	r2,-36(fp)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
  801bb8:	08050480 	call	805048 <vTaskExitCritical>

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
  801bbc:	08040940 	call	804094 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
  801bc0:	0804ff40 	call	804ff4 <vTaskEnterCritical>
  801bc4:	e0bff917 	ldw	r2,-28(fp)
  801bc8:	10801103 	ldbu	r2,68(r2)
  801bcc:	10803fcc 	andi	r2,r2,255
  801bd0:	1080201c 	xori	r2,r2,128
  801bd4:	10bfe004 	addi	r2,r2,-128
  801bd8:	10bfffd8 	cmpnei	r2,r2,-1
  801bdc:	1000021e 	bne	r2,zero,801be8 <xQueueSemaphoreTake+0xfc>
  801be0:	e0bff917 	ldw	r2,-28(fp)
  801be4:	10001105 	stb	zero,68(r2)
  801be8:	e0bff917 	ldw	r2,-28(fp)
  801bec:	10801143 	ldbu	r2,69(r2)
  801bf0:	10803fcc 	andi	r2,r2,255
  801bf4:	1080201c 	xori	r2,r2,128
  801bf8:	10bfe004 	addi	r2,r2,-128
  801bfc:	10bfffd8 	cmpnei	r2,r2,-1
  801c00:	1000021e 	bne	r2,zero,801c0c <xQueueSemaphoreTake+0x120>
  801c04:	e0bff917 	ldw	r2,-28(fp)
  801c08:	10001145 	stb	zero,69(r2)
  801c0c:	08050480 	call	805048 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  801c10:	e0ffff04 	addi	r3,fp,-4
  801c14:	e0bffc04 	addi	r2,fp,-16
  801c18:	180b883a 	mov	r5,r3
  801c1c:	1009883a 	mov	r4,r2
  801c20:	08048980 	call	804898 <xTaskCheckForTimeOut>
  801c24:	10001d1e 	bne	r2,zero,801c9c <xQueueSemaphoreTake+0x1b0>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
  801c28:	e13ff917 	ldw	r4,-28(fp)
  801c2c:	08024800 	call	802480 <prvIsQueueEmpty>
  801c30:	10001626 	beq	r2,zero,801c8c <xQueueSemaphoreTake+0x1a0>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  801c34:	e0bff917 	ldw	r2,-28(fp)
  801c38:	10800017 	ldw	r2,0(r2)
  801c3c:	1000071e 	bne	r2,zero,801c5c <xQueueSemaphoreTake+0x170>
					{
						taskENTER_CRITICAL();
  801c40:	0804ff40 	call	804ff4 <vTaskEnterCritical>
						{
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
  801c44:	e0bff917 	ldw	r2,-28(fp)
  801c48:	10800217 	ldw	r2,8(r2)
  801c4c:	1009883a 	mov	r4,r2
  801c50:	0804c780 	call	804c78 <xTaskPriorityInherit>
  801c54:	e0bff815 	stw	r2,-32(fp)
						}
						taskEXIT_CRITICAL();
  801c58:	08050480 	call	805048 <vTaskExitCritical>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  801c5c:	e0bff917 	ldw	r2,-28(fp)
  801c60:	10800904 	addi	r2,r2,36
  801c64:	e0ffff17 	ldw	r3,-4(fp)
  801c68:	180b883a 	mov	r5,r3
  801c6c:	1009883a 	mov	r4,r2
  801c70:	08045a00 	call	8045a0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
  801c74:	e13ff917 	ldw	r4,-28(fp)
  801c78:	080238c0 	call	80238c <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
  801c7c:	08040c00 	call	8040c0 <xTaskResumeAll>
  801c80:	103fa41e 	bne	r2,zero,801b14 <__alt_mem_onchip_memory2_0+0xff781b14>
				{
					portYIELD_WITHIN_API();
  801c84:	003b683a 	trap	0
  801c88:	003fa206 	br	801b14 <__alt_mem_onchip_memory2_0+0xff781b14>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
  801c8c:	e13ff917 	ldw	r4,-28(fp)
  801c90:	080238c0 	call	80238c <prvUnlockQueue>
				( void ) xTaskResumeAll();
  801c94:	08040c00 	call	8040c0 <xTaskResumeAll>
  801c98:	003f9e06 	br	801b14 <__alt_mem_onchip_memory2_0+0xff781b14>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
  801c9c:	e13ff917 	ldw	r4,-28(fp)
  801ca0:	080238c0 	call	80238c <prvUnlockQueue>
			( void ) xTaskResumeAll();
  801ca4:	08040c00 	call	8040c0 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
  801ca8:	e13ff917 	ldw	r4,-28(fp)
  801cac:	08024800 	call	802480 <prvIsQueueEmpty>
  801cb0:	103f9826 	beq	r2,zero,801b14 <__alt_mem_onchip_memory2_0+0xff781b14>
				#if ( configUSE_MUTEXES == 1 )
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if( xInheritanceOccurred != pdFALSE )
  801cb4:	e0bff817 	ldw	r2,-32(fp)
  801cb8:	10000a26 	beq	r2,zero,801ce4 <xQueueSemaphoreTake+0x1f8>
					{
						taskENTER_CRITICAL();
  801cbc:	0804ff40 	call	804ff4 <vTaskEnterCritical>
							/* This task blocking on the mutex caused another
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
  801cc0:	e13ff917 	ldw	r4,-28(fp)
  801cc4:	08021140 	call	802114 <prvGetDisinheritPriorityAfterTimeout>
  801cc8:	e0bffb15 	stw	r2,-20(fp)
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
  801ccc:	e0bff917 	ldw	r2,-28(fp)
  801cd0:	10800217 	ldw	r2,8(r2)
  801cd4:	e17ffb17 	ldw	r5,-20(fp)
  801cd8:	1009883a 	mov	r4,r2
  801cdc:	0804eb40 	call	804eb4 <vTaskPriorityDisinheritAfterTimeout>
						}
						taskEXIT_CRITICAL();
  801ce0:	08050480 	call	805048 <vTaskExitCritical>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
  801ce4:	0005883a 	mov	r2,zero
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
  801ce8:	e037883a 	mov	sp,fp
  801cec:	dfc00117 	ldw	ra,4(sp)
  801cf0:	df000017 	ldw	fp,0(sp)
  801cf4:	dec00204 	addi	sp,sp,8
  801cf8:	f800283a 	ret

00801cfc <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
  801cfc:	defff504 	addi	sp,sp,-44
  801d00:	dfc00a15 	stw	ra,40(sp)
  801d04:	df000915 	stw	fp,36(sp)
  801d08:	df000904 	addi	fp,sp,36
  801d0c:	e13ffd15 	stw	r4,-12(fp)
  801d10:	e17ffe15 	stw	r5,-8(fp)
  801d14:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xEntryTimeSet = pdFALSE;
  801d18:	e03ff715 	stw	zero,-36(fp)
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
  801d1c:	e0bffd17 	ldw	r2,-12(fp)
  801d20:	e0bff815 	stw	r2,-32(fp)
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
  801d24:	0804ff40 	call	804ff4 <vTaskEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  801d28:	e0bff817 	ldw	r2,-32(fp)
  801d2c:	10800e17 	ldw	r2,56(r2)
  801d30:	e0bff915 	stw	r2,-28(fp)

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
  801d34:	e0bff917 	ldw	r2,-28(fp)
  801d38:	10001526 	beq	r2,zero,801d90 <xQueuePeek+0x94>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
  801d3c:	e0bff817 	ldw	r2,-32(fp)
  801d40:	10800317 	ldw	r2,12(r2)
  801d44:	e0bffa15 	stw	r2,-24(fp)

				prvCopyDataFromQueue( pxQueue, pvBuffer );
  801d48:	e17ffe17 	ldw	r5,-8(fp)
  801d4c:	e13ff817 	ldw	r4,-32(fp)
  801d50:	08022f00 	call	8022f0 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
  801d54:	e0bff817 	ldw	r2,-32(fp)
  801d58:	e0fffa17 	ldw	r3,-24(fp)
  801d5c:	10c00315 	stw	r3,12(r2)

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  801d60:	e0bff817 	ldw	r2,-32(fp)
  801d64:	10800917 	ldw	r2,36(r2)
  801d68:	10000626 	beq	r2,zero,801d84 <xQueuePeek+0x88>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  801d6c:	e0bff817 	ldw	r2,-32(fp)
  801d70:	10800904 	addi	r2,r2,36
  801d74:	1009883a 	mov	r4,r2
  801d78:	08046540 	call	804654 <xTaskRemoveFromEventList>
  801d7c:	10000126 	beq	r2,zero,801d84 <xQueuePeek+0x88>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
  801d80:	003b683a 	trap	0
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
  801d84:	08050480 	call	805048 <vTaskExitCritical>
				return pdPASS;
  801d88:	00800044 	movi	r2,1
  801d8c:	00004206 	br	801e98 <xQueuePeek+0x19c>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
  801d90:	e0bfff17 	ldw	r2,-4(fp)
  801d94:	1000031e 	bne	r2,zero,801da4 <xQueuePeek+0xa8>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
  801d98:	08050480 	call	805048 <vTaskExitCritical>
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
  801d9c:	0005883a 	mov	r2,zero
  801da0:	00003d06 	br	801e98 <xQueuePeek+0x19c>
				}
				else if( xEntryTimeSet == pdFALSE )
  801da4:	e0bff717 	ldw	r2,-36(fp)
  801da8:	1000051e 	bne	r2,zero,801dc0 <xQueuePeek+0xc4>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
  801dac:	e0bffb04 	addi	r2,fp,-20
  801db0:	1009883a 	mov	r4,r2
  801db4:	080485c0 	call	80485c <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
  801db8:	00800044 	movi	r2,1
  801dbc:	e0bff715 	stw	r2,-36(fp)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
  801dc0:	08050480 	call	805048 <vTaskExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  801dc4:	08040940 	call	804094 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
  801dc8:	0804ff40 	call	804ff4 <vTaskEnterCritical>
  801dcc:	e0bff817 	ldw	r2,-32(fp)
  801dd0:	10801103 	ldbu	r2,68(r2)
  801dd4:	10803fcc 	andi	r2,r2,255
  801dd8:	1080201c 	xori	r2,r2,128
  801ddc:	10bfe004 	addi	r2,r2,-128
  801de0:	10bfffd8 	cmpnei	r2,r2,-1
  801de4:	1000021e 	bne	r2,zero,801df0 <xQueuePeek+0xf4>
  801de8:	e0bff817 	ldw	r2,-32(fp)
  801dec:	10001105 	stb	zero,68(r2)
  801df0:	e0bff817 	ldw	r2,-32(fp)
  801df4:	10801143 	ldbu	r2,69(r2)
  801df8:	10803fcc 	andi	r2,r2,255
  801dfc:	1080201c 	xori	r2,r2,128
  801e00:	10bfe004 	addi	r2,r2,-128
  801e04:	10bfffd8 	cmpnei	r2,r2,-1
  801e08:	1000021e 	bne	r2,zero,801e14 <xQueuePeek+0x118>
  801e0c:	e0bff817 	ldw	r2,-32(fp)
  801e10:	10001145 	stb	zero,69(r2)
  801e14:	08050480 	call	805048 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  801e18:	e0ffff04 	addi	r3,fp,-4
  801e1c:	e0bffb04 	addi	r2,fp,-20
  801e20:	180b883a 	mov	r5,r3
  801e24:	1009883a 	mov	r4,r2
  801e28:	08048980 	call	804898 <xTaskCheckForTimeOut>
  801e2c:	1000131e 	bne	r2,zero,801e7c <xQueuePeek+0x180>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
  801e30:	e13ff817 	ldw	r4,-32(fp)
  801e34:	08024800 	call	802480 <prvIsQueueEmpty>
  801e38:	10000c26 	beq	r2,zero,801e6c <xQueuePeek+0x170>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  801e3c:	e0bff817 	ldw	r2,-32(fp)
  801e40:	10800904 	addi	r2,r2,36
  801e44:	e0ffff17 	ldw	r3,-4(fp)
  801e48:	180b883a 	mov	r5,r3
  801e4c:	1009883a 	mov	r4,r2
  801e50:	08045a00 	call	8045a0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
  801e54:	e13ff817 	ldw	r4,-32(fp)
  801e58:	080238c0 	call	80238c <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
  801e5c:	08040c00 	call	8040c0 <xTaskResumeAll>
  801e60:	103fb01e 	bne	r2,zero,801d24 <__alt_mem_onchip_memory2_0+0xff781d24>
				{
					portYIELD_WITHIN_API();
  801e64:	003b683a 	trap	0
  801e68:	003fae06 	br	801d24 <__alt_mem_onchip_memory2_0+0xff781d24>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
  801e6c:	e13ff817 	ldw	r4,-32(fp)
  801e70:	080238c0 	call	80238c <prvUnlockQueue>
				( void ) xTaskResumeAll();
  801e74:	08040c00 	call	8040c0 <xTaskResumeAll>
  801e78:	003faa06 	br	801d24 <__alt_mem_onchip_memory2_0+0xff781d24>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
  801e7c:	e13ff817 	ldw	r4,-32(fp)
  801e80:	080238c0 	call	80238c <prvUnlockQueue>
			( void ) xTaskResumeAll();
  801e84:	08040c00 	call	8040c0 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
  801e88:	e13ff817 	ldw	r4,-32(fp)
  801e8c:	08024800 	call	802480 <prvIsQueueEmpty>
  801e90:	103fa426 	beq	r2,zero,801d24 <__alt_mem_onchip_memory2_0+0xff781d24>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
  801e94:	0005883a 	mov	r2,zero
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
  801e98:	e037883a 	mov	sp,fp
  801e9c:	dfc00117 	ldw	ra,4(sp)
  801ea0:	df000017 	ldw	fp,0(sp)
  801ea4:	dec00204 	addi	sp,sp,8
  801ea8:	f800283a 	ret

00801eac <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
  801eac:	defff604 	addi	sp,sp,-40
  801eb0:	dfc00915 	stw	ra,36(sp)
  801eb4:	df000815 	stw	fp,32(sp)
  801eb8:	df000804 	addi	fp,sp,32
  801ebc:	e13ffd15 	stw	r4,-12(fp)
  801ec0:	e17ffe15 	stw	r5,-8(fp)
  801ec4:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
  801ec8:	e0bffd17 	ldw	r2,-12(fp)
  801ecc:	e0bff915 	stw	r2,-28(fp)
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  801ed0:	e03ffa15 	stw	zero,-24(fp)
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  801ed4:	e0bff917 	ldw	r2,-28(fp)
  801ed8:	10800e17 	ldw	r2,56(r2)
  801edc:	e0bffb15 	stw	r2,-20(fp)

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
  801ee0:	e0bffb17 	ldw	r2,-20(fp)
  801ee4:	10002326 	beq	r2,zero,801f74 <xQueueReceiveFromISR+0xc8>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
  801ee8:	e0bff917 	ldw	r2,-28(fp)
  801eec:	10801103 	ldbu	r2,68(r2)
  801ef0:	e0bffc05 	stb	r2,-16(fp)

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
  801ef4:	e17ffe17 	ldw	r5,-8(fp)
  801ef8:	e13ff917 	ldw	r4,-28(fp)
  801efc:	08022f00 	call	8022f0 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
  801f00:	e0bffb17 	ldw	r2,-20(fp)
  801f04:	10ffffc4 	addi	r3,r2,-1
  801f08:	e0bff917 	ldw	r2,-28(fp)
  801f0c:	10c00e15 	stw	r3,56(r2)

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
  801f10:	e0bffc07 	ldb	r2,-16(fp)
  801f14:	10bfffd8 	cmpnei	r2,r2,-1
  801f18:	10000e1e 	bne	r2,zero,801f54 <xQueueReceiveFromISR+0xa8>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  801f1c:	e0bff917 	ldw	r2,-28(fp)
  801f20:	10800417 	ldw	r2,16(r2)
  801f24:	10001026 	beq	r2,zero,801f68 <xQueueReceiveFromISR+0xbc>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  801f28:	e0bff917 	ldw	r2,-28(fp)
  801f2c:	10800404 	addi	r2,r2,16
  801f30:	1009883a 	mov	r4,r2
  801f34:	08046540 	call	804654 <xTaskRemoveFromEventList>
  801f38:	10000b26 	beq	r2,zero,801f68 <xQueueReceiveFromISR+0xbc>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
  801f3c:	e0bfff17 	ldw	r2,-4(fp)
  801f40:	10000926 	beq	r2,zero,801f68 <xQueueReceiveFromISR+0xbc>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
  801f44:	e0bfff17 	ldw	r2,-4(fp)
  801f48:	00c00044 	movi	r3,1
  801f4c:	10c00015 	stw	r3,0(r2)
  801f50:	00000506 	br	801f68 <xQueueReceiveFromISR+0xbc>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
  801f54:	e0bffc03 	ldbu	r2,-16(fp)
  801f58:	10800044 	addi	r2,r2,1
  801f5c:	1007883a 	mov	r3,r2
  801f60:	e0bff917 	ldw	r2,-28(fp)
  801f64:	10c01105 	stb	r3,68(r2)
			}

			xReturn = pdPASS;
  801f68:	00800044 	movi	r2,1
  801f6c:	e0bff815 	stw	r2,-32(fp)
  801f70:	00000106 	br	801f78 <xQueueReceiveFromISR+0xcc>
		}
		else
		{
			xReturn = pdFAIL;
  801f74:	e03ff815 	stw	zero,-32(fp)
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
  801f78:	e0bff817 	ldw	r2,-32(fp)
}
  801f7c:	e037883a 	mov	sp,fp
  801f80:	dfc00117 	ldw	ra,4(sp)
  801f84:	df000017 	ldw	fp,0(sp)
  801f88:	dec00204 	addi	sp,sp,8
  801f8c:	f800283a 	ret

00801f90 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
  801f90:	defff804 	addi	sp,sp,-32
  801f94:	dfc00715 	stw	ra,28(sp)
  801f98:	df000615 	stw	fp,24(sp)
  801f9c:	df000604 	addi	fp,sp,24
  801fa0:	e13ffe15 	stw	r4,-8(fp)
  801fa4:	e17fff15 	stw	r5,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
  801fa8:	e0bffe17 	ldw	r2,-8(fp)
  801fac:	e0bffb15 	stw	r2,-20(fp)
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  801fb0:	e03ffc15 	stw	zero,-16(fp)
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
  801fb4:	e0bffb17 	ldw	r2,-20(fp)
  801fb8:	10800e17 	ldw	r2,56(r2)
  801fbc:	10000c26 	beq	r2,zero,801ff0 <xQueuePeekFromISR+0x60>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
  801fc0:	e0bffb17 	ldw	r2,-20(fp)
  801fc4:	10800317 	ldw	r2,12(r2)
  801fc8:	e0bffd15 	stw	r2,-12(fp)
			prvCopyDataFromQueue( pxQueue, pvBuffer );
  801fcc:	e17fff17 	ldw	r5,-4(fp)
  801fd0:	e13ffb17 	ldw	r4,-20(fp)
  801fd4:	08022f00 	call	8022f0 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
  801fd8:	e0bffb17 	ldw	r2,-20(fp)
  801fdc:	e0fffd17 	ldw	r3,-12(fp)
  801fe0:	10c00315 	stw	r3,12(r2)

			xReturn = pdPASS;
  801fe4:	00800044 	movi	r2,1
  801fe8:	e0bffa15 	stw	r2,-24(fp)
  801fec:	00000106 	br	801ff4 <xQueuePeekFromISR+0x64>
		}
		else
		{
			xReturn = pdFAIL;
  801ff0:	e03ffa15 	stw	zero,-24(fp)
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
  801ff4:	e0bffa17 	ldw	r2,-24(fp)
}
  801ff8:	e037883a 	mov	sp,fp
  801ffc:	dfc00117 	ldw	ra,4(sp)
  802000:	df000017 	ldw	fp,0(sp)
  802004:	dec00204 	addi	sp,sp,8
  802008:	f800283a 	ret

0080200c <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
  80200c:	defffc04 	addi	sp,sp,-16
  802010:	dfc00315 	stw	ra,12(sp)
  802014:	df000215 	stw	fp,8(sp)
  802018:	df000204 	addi	fp,sp,8
  80201c:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
  802020:	0804ff40 	call	804ff4 <vTaskEnterCritical>
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
  802024:	e0bfff17 	ldw	r2,-4(fp)
  802028:	10800e17 	ldw	r2,56(r2)
  80202c:	e0bffe15 	stw	r2,-8(fp)
	}
	taskEXIT_CRITICAL();
  802030:	08050480 	call	805048 <vTaskExitCritical>

	return uxReturn;
  802034:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
  802038:	e037883a 	mov	sp,fp
  80203c:	dfc00117 	ldw	ra,4(sp)
  802040:	df000017 	ldw	fp,0(sp)
  802044:	dec00204 	addi	sp,sp,8
  802048:	f800283a 	ret

0080204c <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
  80204c:	defffb04 	addi	sp,sp,-20
  802050:	dfc00415 	stw	ra,16(sp)
  802054:	df000315 	stw	fp,12(sp)
  802058:	df000304 	addi	fp,sp,12
  80205c:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
  802060:	e0bfff17 	ldw	r2,-4(fp)
  802064:	e0bffd15 	stw	r2,-12(fp)

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
  802068:	0804ff40 	call	804ff4 <vTaskEnterCritical>
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
  80206c:	e0bffd17 	ldw	r2,-12(fp)
  802070:	10c00f17 	ldw	r3,60(r2)
  802074:	e0bffd17 	ldw	r2,-12(fp)
  802078:	10800e17 	ldw	r2,56(r2)
  80207c:	1885c83a 	sub	r2,r3,r2
  802080:	e0bffe15 	stw	r2,-8(fp)
	}
	taskEXIT_CRITICAL();
  802084:	08050480 	call	805048 <vTaskExitCritical>

	return uxReturn;
  802088:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
  80208c:	e037883a 	mov	sp,fp
  802090:	dfc00117 	ldw	ra,4(sp)
  802094:	df000017 	ldw	fp,0(sp)
  802098:	dec00204 	addi	sp,sp,8
  80209c:	f800283a 	ret

008020a0 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
  8020a0:	defffc04 	addi	sp,sp,-16
  8020a4:	df000315 	stw	fp,12(sp)
  8020a8:	df000304 	addi	fp,sp,12
  8020ac:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
  8020b0:	e0bfff17 	ldw	r2,-4(fp)
  8020b4:	e0bffd15 	stw	r2,-12(fp)

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
  8020b8:	e0bffd17 	ldw	r2,-12(fp)
  8020bc:	10800e17 	ldw	r2,56(r2)
  8020c0:	e0bffe15 	stw	r2,-8(fp)

	return uxReturn;
  8020c4:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
  8020c8:	e037883a 	mov	sp,fp
  8020cc:	df000017 	ldw	fp,0(sp)
  8020d0:	dec00104 	addi	sp,sp,4
  8020d4:	f800283a 	ret

008020d8 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
  8020d8:	defffc04 	addi	sp,sp,-16
  8020dc:	dfc00315 	stw	ra,12(sp)
  8020e0:	df000215 	stw	fp,8(sp)
  8020e4:	df000204 	addi	fp,sp,8
  8020e8:	e13fff15 	stw	r4,-4(fp)
Queue_t * const pxQueue = xQueue;
  8020ec:	e0bfff17 	ldw	r2,-4(fp)
  8020f0:	e0bffe15 	stw	r2,-8(fp)

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
  8020f4:	e13ffe17 	ldw	r4,-8(fp)
  8020f8:	08010dc0 	call	8010dc <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
  8020fc:	0001883a 	nop
  802100:	e037883a 	mov	sp,fp
  802104:	dfc00117 	ldw	ra,4(sp)
  802108:	df000017 	ldw	fp,0(sp)
  80210c:	dec00204 	addi	sp,sp,8
  802110:	f800283a 	ret

00802114 <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
	{
  802114:	defffd04 	addi	sp,sp,-12
  802118:	df000215 	stw	fp,8(sp)
  80211c:	df000204 	addi	fp,sp,8
  802120:	e13fff15 	stw	r4,-4(fp)
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
  802124:	e0bfff17 	ldw	r2,-4(fp)
  802128:	10800917 	ldw	r2,36(r2)
  80212c:	10000726 	beq	r2,zero,80214c <prvGetDisinheritPriorityAfterTimeout+0x38>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
  802130:	e0bfff17 	ldw	r2,-4(fp)
  802134:	10800c17 	ldw	r2,48(r2)
  802138:	10800017 	ldw	r2,0(r2)
  80213c:	00c00144 	movi	r3,5
  802140:	1885c83a 	sub	r2,r3,r2
  802144:	e0bffe15 	stw	r2,-8(fp)
  802148:	00000106 	br	802150 <prvGetDisinheritPriorityAfterTimeout+0x3c>
		}
		else
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
  80214c:	e03ffe15 	stw	zero,-8(fp)
		}

		return uxHighestPriorityOfWaitingTasks;
  802150:	e0bffe17 	ldw	r2,-8(fp)
	}
  802154:	e037883a 	mov	sp,fp
  802158:	df000017 	ldw	fp,0(sp)
  80215c:	dec00104 	addi	sp,sp,4
  802160:	f800283a 	ret

00802164 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
  802164:	defff904 	addi	sp,sp,-28
  802168:	dfc00615 	stw	ra,24(sp)
  80216c:	df000515 	stw	fp,20(sp)
  802170:	df000504 	addi	fp,sp,20
  802174:	e13ffd15 	stw	r4,-12(fp)
  802178:	e17ffe15 	stw	r5,-8(fp)
  80217c:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xReturn = pdFALSE;
  802180:	e03ffb15 	stw	zero,-20(fp)
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  802184:	e0bffd17 	ldw	r2,-12(fp)
  802188:	10800e17 	ldw	r2,56(r2)
  80218c:	e0bffc15 	stw	r2,-16(fp)

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
  802190:	e0bffd17 	ldw	r2,-12(fp)
  802194:	10801017 	ldw	r2,64(r2)
  802198:	10000b1e 	bne	r2,zero,8021c8 <prvCopyDataToQueue+0x64>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  80219c:	e0bffd17 	ldw	r2,-12(fp)
  8021a0:	10800017 	ldw	r2,0(r2)
  8021a4:	1000481e 	bne	r2,zero,8022c8 <prvCopyDataToQueue+0x164>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
  8021a8:	e0bffd17 	ldw	r2,-12(fp)
  8021ac:	10800217 	ldw	r2,8(r2)
  8021b0:	1009883a 	mov	r4,r2
  8021b4:	0804db80 	call	804db8 <xTaskPriorityDisinherit>
  8021b8:	e0bffb15 	stw	r2,-20(fp)
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
  8021bc:	e0bffd17 	ldw	r2,-12(fp)
  8021c0:	10000215 	stw	zero,8(r2)
  8021c4:	00004006 	br	8022c8 <prvCopyDataToQueue+0x164>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
  8021c8:	e0bfff17 	ldw	r2,-4(fp)
  8021cc:	1000191e 	bne	r2,zero,802234 <prvCopyDataToQueue+0xd0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
  8021d0:	e0bffd17 	ldw	r2,-12(fp)
  8021d4:	10c00117 	ldw	r3,4(r2)
  8021d8:	e0bffd17 	ldw	r2,-12(fp)
  8021dc:	10801017 	ldw	r2,64(r2)
  8021e0:	100d883a 	mov	r6,r2
  8021e4:	e17ffe17 	ldw	r5,-8(fp)
  8021e8:	1809883a 	mov	r4,r3
  8021ec:	08066f00 	call	8066f0 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
  8021f0:	e0bffd17 	ldw	r2,-12(fp)
  8021f4:	10c00117 	ldw	r3,4(r2)
  8021f8:	e0bffd17 	ldw	r2,-12(fp)
  8021fc:	10801017 	ldw	r2,64(r2)
  802200:	1887883a 	add	r3,r3,r2
  802204:	e0bffd17 	ldw	r2,-12(fp)
  802208:	10c00115 	stw	r3,4(r2)
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
  80220c:	e0bffd17 	ldw	r2,-12(fp)
  802210:	10c00117 	ldw	r3,4(r2)
  802214:	e0bffd17 	ldw	r2,-12(fp)
  802218:	10800217 	ldw	r2,8(r2)
  80221c:	18802a36 	bltu	r3,r2,8022c8 <prvCopyDataToQueue+0x164>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
  802220:	e0bffd17 	ldw	r2,-12(fp)
  802224:	10c00017 	ldw	r3,0(r2)
  802228:	e0bffd17 	ldw	r2,-12(fp)
  80222c:	10c00115 	stw	r3,4(r2)
  802230:	00002506 	br	8022c8 <prvCopyDataToQueue+0x164>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
  802234:	e0bffd17 	ldw	r2,-12(fp)
  802238:	10c00317 	ldw	r3,12(r2)
  80223c:	e0bffd17 	ldw	r2,-12(fp)
  802240:	10801017 	ldw	r2,64(r2)
  802244:	100d883a 	mov	r6,r2
  802248:	e17ffe17 	ldw	r5,-8(fp)
  80224c:	1809883a 	mov	r4,r3
  802250:	08066f00 	call	8066f0 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
  802254:	e0bffd17 	ldw	r2,-12(fp)
  802258:	10c00317 	ldw	r3,12(r2)
  80225c:	e0bffd17 	ldw	r2,-12(fp)
  802260:	10801017 	ldw	r2,64(r2)
  802264:	0085c83a 	sub	r2,zero,r2
  802268:	1887883a 	add	r3,r3,r2
  80226c:	e0bffd17 	ldw	r2,-12(fp)
  802270:	10c00315 	stw	r3,12(r2)
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
  802274:	e0bffd17 	ldw	r2,-12(fp)
  802278:	10c00317 	ldw	r3,12(r2)
  80227c:	e0bffd17 	ldw	r2,-12(fp)
  802280:	10800017 	ldw	r2,0(r2)
  802284:	1880082e 	bgeu	r3,r2,8022a8 <prvCopyDataToQueue+0x144>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
  802288:	e0bffd17 	ldw	r2,-12(fp)
  80228c:	10c00217 	ldw	r3,8(r2)
  802290:	e0bffd17 	ldw	r2,-12(fp)
  802294:	10801017 	ldw	r2,64(r2)
  802298:	0085c83a 	sub	r2,zero,r2
  80229c:	1887883a 	add	r3,r3,r2
  8022a0:	e0bffd17 	ldw	r2,-12(fp)
  8022a4:	10c00315 	stw	r3,12(r2)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
  8022a8:	e0bfff17 	ldw	r2,-4(fp)
  8022ac:	10800098 	cmpnei	r2,r2,2
  8022b0:	1000051e 	bne	r2,zero,8022c8 <prvCopyDataToQueue+0x164>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
  8022b4:	e0bffc17 	ldw	r2,-16(fp)
  8022b8:	10000326 	beq	r2,zero,8022c8 <prvCopyDataToQueue+0x164>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
  8022bc:	e0bffc17 	ldw	r2,-16(fp)
  8022c0:	10bfffc4 	addi	r2,r2,-1
  8022c4:	e0bffc15 	stw	r2,-16(fp)
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
  8022c8:	e0bffc17 	ldw	r2,-16(fp)
  8022cc:	10c00044 	addi	r3,r2,1
  8022d0:	e0bffd17 	ldw	r2,-12(fp)
  8022d4:	10c00e15 	stw	r3,56(r2)

	return xReturn;
  8022d8:	e0bffb17 	ldw	r2,-20(fp)
}
  8022dc:	e037883a 	mov	sp,fp
  8022e0:	dfc00117 	ldw	ra,4(sp)
  8022e4:	df000017 	ldw	fp,0(sp)
  8022e8:	dec00204 	addi	sp,sp,8
  8022ec:	f800283a 	ret

008022f0 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
  8022f0:	defffc04 	addi	sp,sp,-16
  8022f4:	dfc00315 	stw	ra,12(sp)
  8022f8:	df000215 	stw	fp,8(sp)
  8022fc:	df000204 	addi	fp,sp,8
  802300:	e13ffe15 	stw	r4,-8(fp)
  802304:	e17fff15 	stw	r5,-4(fp)
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
  802308:	e0bffe17 	ldw	r2,-8(fp)
  80230c:	10801017 	ldw	r2,64(r2)
  802310:	10001826 	beq	r2,zero,802374 <prvCopyDataFromQueue+0x84>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
  802314:	e0bffe17 	ldw	r2,-8(fp)
  802318:	10c00317 	ldw	r3,12(r2)
  80231c:	e0bffe17 	ldw	r2,-8(fp)
  802320:	10801017 	ldw	r2,64(r2)
  802324:	1887883a 	add	r3,r3,r2
  802328:	e0bffe17 	ldw	r2,-8(fp)
  80232c:	10c00315 	stw	r3,12(r2)
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
  802330:	e0bffe17 	ldw	r2,-8(fp)
  802334:	10c00317 	ldw	r3,12(r2)
  802338:	e0bffe17 	ldw	r2,-8(fp)
  80233c:	10800217 	ldw	r2,8(r2)
  802340:	18800436 	bltu	r3,r2,802354 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
  802344:	e0bffe17 	ldw	r2,-8(fp)
  802348:	10c00017 	ldw	r3,0(r2)
  80234c:	e0bffe17 	ldw	r2,-8(fp)
  802350:	10c00315 	stw	r3,12(r2)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
  802354:	e0bffe17 	ldw	r2,-8(fp)
  802358:	10c00317 	ldw	r3,12(r2)
  80235c:	e0bffe17 	ldw	r2,-8(fp)
  802360:	10801017 	ldw	r2,64(r2)
  802364:	100d883a 	mov	r6,r2
  802368:	180b883a 	mov	r5,r3
  80236c:	e13fff17 	ldw	r4,-4(fp)
  802370:	08066f00 	call	8066f0 <memcpy>
	}
}
  802374:	0001883a 	nop
  802378:	e037883a 	mov	sp,fp
  80237c:	dfc00117 	ldw	ra,4(sp)
  802380:	df000017 	ldw	fp,0(sp)
  802384:	dec00204 	addi	sp,sp,8
  802388:	f800283a 	ret

0080238c <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
  80238c:	defffc04 	addi	sp,sp,-16
  802390:	dfc00315 	stw	ra,12(sp)
  802394:	df000215 	stw	fp,8(sp)
  802398:	df000204 	addi	fp,sp,8
  80239c:	e13fff15 	stw	r4,-4(fp)

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
  8023a0:	0804ff40 	call	804ff4 <vTaskEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
  8023a4:	e0bfff17 	ldw	r2,-4(fp)
  8023a8:	10801143 	ldbu	r2,69(r2)
  8023ac:	e0bffe05 	stb	r2,-8(fp)

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
  8023b0:	00000c06 	br	8023e4 <prvUnlockQueue+0x58>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  8023b4:	e0bfff17 	ldw	r2,-4(fp)
  8023b8:	10800917 	ldw	r2,36(r2)
  8023bc:	10000c26 	beq	r2,zero,8023f0 <prvUnlockQueue+0x64>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  8023c0:	e0bfff17 	ldw	r2,-4(fp)
  8023c4:	10800904 	addi	r2,r2,36
  8023c8:	1009883a 	mov	r4,r2
  8023cc:	08046540 	call	804654 <xTaskRemoveFromEventList>
  8023d0:	10000126 	beq	r2,zero,8023d8 <prvUnlockQueue+0x4c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
  8023d4:	08049780 	call	804978 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
  8023d8:	e0bffe03 	ldbu	r2,-8(fp)
  8023dc:	10bfffc4 	addi	r2,r2,-1
  8023e0:	e0bffe05 	stb	r2,-8(fp)
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
  8023e4:	e0bffe07 	ldb	r2,-8(fp)
  8023e8:	00bff216 	blt	zero,r2,8023b4 <__alt_mem_onchip_memory2_0+0xff7823b4>
  8023ec:	00000106 	br	8023f4 <prvUnlockQueue+0x68>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				else
				{
					break;
  8023f0:	0001883a 	nop
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
  8023f4:	e0bfff17 	ldw	r2,-4(fp)
  8023f8:	00ffffc4 	movi	r3,-1
  8023fc:	10c01145 	stb	r3,69(r2)
	}
	taskEXIT_CRITICAL();
  802400:	08050480 	call	805048 <vTaskExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
  802404:	0804ff40 	call	804ff4 <vTaskEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
  802408:	e0bfff17 	ldw	r2,-4(fp)
  80240c:	10801103 	ldbu	r2,68(r2)
  802410:	e0bffe45 	stb	r2,-7(fp)

		while( cRxLock > queueLOCKED_UNMODIFIED )
  802414:	00000c06 	br	802448 <prvUnlockQueue+0xbc>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  802418:	e0bfff17 	ldw	r2,-4(fp)
  80241c:	10800417 	ldw	r2,16(r2)
  802420:	10000c26 	beq	r2,zero,802454 <prvUnlockQueue+0xc8>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  802424:	e0bfff17 	ldw	r2,-4(fp)
  802428:	10800404 	addi	r2,r2,16
  80242c:	1009883a 	mov	r4,r2
  802430:	08046540 	call	804654 <xTaskRemoveFromEventList>
  802434:	10000126 	beq	r2,zero,80243c <prvUnlockQueue+0xb0>
				{
					vTaskMissedYield();
  802438:	08049780 	call	804978 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
  80243c:	e0bffe43 	ldbu	r2,-7(fp)
  802440:	10bfffc4 	addi	r2,r2,-1
  802444:	e0bffe45 	stb	r2,-7(fp)
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
  802448:	e0bffe47 	ldb	r2,-7(fp)
  80244c:	00bff216 	blt	zero,r2,802418 <__alt_mem_onchip_memory2_0+0xff782418>
  802450:	00000106 	br	802458 <prvUnlockQueue+0xcc>

				--cRxLock;
			}
			else
			{
				break;
  802454:	0001883a 	nop
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
  802458:	e0bfff17 	ldw	r2,-4(fp)
  80245c:	00ffffc4 	movi	r3,-1
  802460:	10c01105 	stb	r3,68(r2)
	}
	taskEXIT_CRITICAL();
  802464:	08050480 	call	805048 <vTaskExitCritical>
}
  802468:	0001883a 	nop
  80246c:	e037883a 	mov	sp,fp
  802470:	dfc00117 	ldw	ra,4(sp)
  802474:	df000017 	ldw	fp,0(sp)
  802478:	dec00204 	addi	sp,sp,8
  80247c:	f800283a 	ret

00802480 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
  802480:	defffc04 	addi	sp,sp,-16
  802484:	dfc00315 	stw	ra,12(sp)
  802488:	df000215 	stw	fp,8(sp)
  80248c:	df000204 	addi	fp,sp,8
  802490:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;

	taskENTER_CRITICAL();
  802494:	0804ff40 	call	804ff4 <vTaskEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
  802498:	e0bfff17 	ldw	r2,-4(fp)
  80249c:	10800e17 	ldw	r2,56(r2)
  8024a0:	1000031e 	bne	r2,zero,8024b0 <prvIsQueueEmpty+0x30>
		{
			xReturn = pdTRUE;
  8024a4:	00800044 	movi	r2,1
  8024a8:	e0bffe15 	stw	r2,-8(fp)
  8024ac:	00000106 	br	8024b4 <prvIsQueueEmpty+0x34>
		}
		else
		{
			xReturn = pdFALSE;
  8024b0:	e03ffe15 	stw	zero,-8(fp)
		}
	}
	taskEXIT_CRITICAL();
  8024b4:	08050480 	call	805048 <vTaskExitCritical>

	return xReturn;
  8024b8:	e0bffe17 	ldw	r2,-8(fp)
}
  8024bc:	e037883a 	mov	sp,fp
  8024c0:	dfc00117 	ldw	ra,4(sp)
  8024c4:	df000017 	ldw	fp,0(sp)
  8024c8:	dec00204 	addi	sp,sp,8
  8024cc:	f800283a 	ret

008024d0 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
  8024d0:	defffc04 	addi	sp,sp,-16
  8024d4:	df000315 	stw	fp,12(sp)
  8024d8:	df000304 	addi	fp,sp,12
  8024dc:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
  8024e0:	e0bfff17 	ldw	r2,-4(fp)
  8024e4:	e0bffe15 	stw	r2,-8(fp)

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
  8024e8:	e0bffe17 	ldw	r2,-8(fp)
  8024ec:	10800e17 	ldw	r2,56(r2)
  8024f0:	1000031e 	bne	r2,zero,802500 <xQueueIsQueueEmptyFromISR+0x30>
	{
		xReturn = pdTRUE;
  8024f4:	00800044 	movi	r2,1
  8024f8:	e0bffd15 	stw	r2,-12(fp)
  8024fc:	00000106 	br	802504 <xQueueIsQueueEmptyFromISR+0x34>
	}
	else
	{
		xReturn = pdFALSE;
  802500:	e03ffd15 	stw	zero,-12(fp)
	}

	return xReturn;
  802504:	e0bffd17 	ldw	r2,-12(fp)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
  802508:	e037883a 	mov	sp,fp
  80250c:	df000017 	ldw	fp,0(sp)
  802510:	dec00104 	addi	sp,sp,4
  802514:	f800283a 	ret

00802518 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
  802518:	defffc04 	addi	sp,sp,-16
  80251c:	dfc00315 	stw	ra,12(sp)
  802520:	df000215 	stw	fp,8(sp)
  802524:	df000204 	addi	fp,sp,8
  802528:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;

	taskENTER_CRITICAL();
  80252c:	0804ff40 	call	804ff4 <vTaskEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
  802530:	e0bfff17 	ldw	r2,-4(fp)
  802534:	10c00e17 	ldw	r3,56(r2)
  802538:	e0bfff17 	ldw	r2,-4(fp)
  80253c:	10800f17 	ldw	r2,60(r2)
  802540:	1880031e 	bne	r3,r2,802550 <prvIsQueueFull+0x38>
		{
			xReturn = pdTRUE;
  802544:	00800044 	movi	r2,1
  802548:	e0bffe15 	stw	r2,-8(fp)
  80254c:	00000106 	br	802554 <prvIsQueueFull+0x3c>
		}
		else
		{
			xReturn = pdFALSE;
  802550:	e03ffe15 	stw	zero,-8(fp)
		}
	}
	taskEXIT_CRITICAL();
  802554:	08050480 	call	805048 <vTaskExitCritical>

	return xReturn;
  802558:	e0bffe17 	ldw	r2,-8(fp)
}
  80255c:	e037883a 	mov	sp,fp
  802560:	dfc00117 	ldw	ra,4(sp)
  802564:	df000017 	ldw	fp,0(sp)
  802568:	dec00204 	addi	sp,sp,8
  80256c:	f800283a 	ret

00802570 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
  802570:	defffc04 	addi	sp,sp,-16
  802574:	df000315 	stw	fp,12(sp)
  802578:	df000304 	addi	fp,sp,12
  80257c:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
  802580:	e0bfff17 	ldw	r2,-4(fp)
  802584:	e0bffe15 	stw	r2,-8(fp)

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
  802588:	e0bffe17 	ldw	r2,-8(fp)
  80258c:	10c00e17 	ldw	r3,56(r2)
  802590:	e0bffe17 	ldw	r2,-8(fp)
  802594:	10800f17 	ldw	r2,60(r2)
  802598:	1880031e 	bne	r3,r2,8025a8 <xQueueIsQueueFullFromISR+0x38>
	{
		xReturn = pdTRUE;
  80259c:	00800044 	movi	r2,1
  8025a0:	e0bffd15 	stw	r2,-12(fp)
  8025a4:	00000106 	br	8025ac <xQueueIsQueueFullFromISR+0x3c>
	}
	else
	{
		xReturn = pdFALSE;
  8025a8:	e03ffd15 	stw	zero,-12(fp)
	}

	return xReturn;
  8025ac:	e0bffd17 	ldw	r2,-12(fp)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
  8025b0:	e037883a 	mov	sp,fp
  8025b4:	df000017 	ldw	fp,0(sp)
  8025b8:	dec00104 	addi	sp,sp,4
  8025bc:	f800283a 	ret

008025c0 <xStreamBufferGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
	{
  8025c0:	defff804 	addi	sp,sp,-32
  8025c4:	dfc00715 	stw	ra,28(sp)
  8025c8:	df000615 	stw	fp,24(sp)
  8025cc:	df000604 	addi	fp,sp,24
  8025d0:	e13ffd15 	stw	r4,-12(fp)
  8025d4:	e17ffe15 	stw	r5,-8(fp)
  8025d8:	e1bfff15 	stw	r6,-4(fp)

		/* In case the stream buffer is going to be used as a message buffer
		(that is, it will hold discrete messages with a little meta data that
		says how big the next message is) check the buffer will be large enough
		to hold at least one message. */
		if( xIsMessageBuffer == pdTRUE )
  8025dc:	e0bfff17 	ldw	r2,-4(fp)
  8025e0:	10800058 	cmpnei	r2,r2,1
  8025e4:	1000031e 	bne	r2,zero,8025f4 <xStreamBufferGenericCreate+0x34>
		{
			/* Is a message buffer but not statically allocated. */
			ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
  8025e8:	00800044 	movi	r2,1
  8025ec:	e0bffb05 	stb	r2,-20(fp)
  8025f0:	00000106 	br	8025f8 <xStreamBufferGenericCreate+0x38>
			configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
		}
		else
		{
			/* Not a message buffer and not statically allocated. */
			ucFlags = 0;
  8025f4:	e03ffb05 	stb	zero,-20(fp)
		}
		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

		/* A trigger level of 0 would cause a waiting task to unblock even when
		the buffer was empty. */
		if( xTriggerLevelBytes == ( size_t ) 0 )
  8025f8:	e0bffe17 	ldw	r2,-8(fp)
  8025fc:	1000021e 	bne	r2,zero,802608 <xStreamBufferGenericCreate+0x48>
		{
			xTriggerLevelBytes = ( size_t ) 1;
  802600:	00800044 	movi	r2,1
  802604:	e0bffe15 	stw	r2,-8(fp)
		and the buffer follows immediately after.  The requested size is
		incremented so the free space is returned as the user would expect -
		this is a quirk of the implementation that means otherwise the free
		space would be reported as one byte smaller than would be logically
		expected. */
		xBufferSizeBytes++;
  802608:	e0bffd17 	ldw	r2,-12(fp)
  80260c:	10800044 	addi	r2,r2,1
  802610:	e0bffd15 	stw	r2,-12(fp)
		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
  802614:	e0bffd17 	ldw	r2,-12(fp)
  802618:	10800804 	addi	r2,r2,32
  80261c:	1009883a 	mov	r4,r2
  802620:	080101c0 	call	80101c <pvPortMalloc>
  802624:	e0bffc15 	stw	r2,-16(fp)

		if( pucAllocatedMemory != NULL )
  802628:	e0bffc17 	ldw	r2,-16(fp)
  80262c:	10000926 	beq	r2,zero,802654 <xStreamBufferGenericCreate+0x94>
		{
			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
  802630:	e0bffc17 	ldw	r2,-16(fp)
  802634:	10c00804 	addi	r3,r2,32
  802638:	e0bffb03 	ldbu	r2,-20(fp)
  80263c:	d8800015 	stw	r2,0(sp)
  802640:	e1fffe17 	ldw	r7,-8(fp)
  802644:	e1bffd17 	ldw	r6,-12(fp)
  802648:	180b883a 	mov	r5,r3
  80264c:	e13ffc17 	ldw	r4,-16(fp)
  802650:	08033e40 	call	8033e4 <prvInitialiseNewStreamBuffer>
		else
		{
			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
		}

		return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
  802654:	e0bffc17 	ldw	r2,-16(fp)
	}
  802658:	e037883a 	mov	sp,fp
  80265c:	dfc00117 	ldw	ra,4(sp)
  802660:	df000017 	ldw	fp,0(sp)
  802664:	dec00204 	addi	sp,sp,8
  802668:	f800283a 	ret

0080266c <vStreamBufferDelete>:

#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
  80266c:	defffc04 	addi	sp,sp,-16
  802670:	dfc00315 	stw	ra,12(sp)
  802674:	df000215 	stw	fp,8(sp)
  802678:	df000204 	addi	fp,sp,8
  80267c:	e13fff15 	stw	r4,-4(fp)
StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
  802680:	e0bfff17 	ldw	r2,-4(fp)
  802684:	e0bffe15 	stw	r2,-8(fp)

	configASSERT( pxStreamBuffer );

	traceSTREAM_BUFFER_DELETE( xStreamBuffer );

	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
  802688:	e0bffe17 	ldw	r2,-8(fp)
  80268c:	10800703 	ldbu	r2,28(r2)
  802690:	10803fcc 	andi	r2,r2,255
  802694:	1080008c 	andi	r2,r2,2
  802698:	1000031e 	bne	r2,zero,8026a8 <vStreamBufferDelete+0x3c>
	{
		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
		{
			/* Both the structure and the buffer were allocated using a single call
			to pvPortMalloc(), hence only one call to vPortFree() is required. */
			vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
  80269c:	e13ffe17 	ldw	r4,-8(fp)
  8026a0:	08010dc0 	call	8010dc <vPortFree>
	{
		/* The structure and buffer were not allocated dynamically and cannot be
		freed - just scrub the structure so future use will assert. */
		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
	}
}
  8026a4:	00000406 	br	8026b8 <vStreamBufferDelete+0x4c>
	}
	else
	{
		/* The structure and buffer were not allocated dynamically and cannot be
		freed - just scrub the structure so future use will assert. */
		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
  8026a8:	01800804 	movi	r6,32
  8026ac:	000b883a 	mov	r5,zero
  8026b0:	e13ffe17 	ldw	r4,-8(fp)
  8026b4:	08067180 	call	806718 <memset>
	}
}
  8026b8:	0001883a 	nop
  8026bc:	e037883a 	mov	sp,fp
  8026c0:	dfc00117 	ldw	ra,4(sp)
  8026c4:	df000017 	ldw	fp,0(sp)
  8026c8:	dec00204 	addi	sp,sp,8
  8026cc:	f800283a 	ret

008026d0 <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
  8026d0:	defffa04 	addi	sp,sp,-24
  8026d4:	dfc00515 	stw	ra,20(sp)
  8026d8:	df000415 	stw	fp,16(sp)
  8026dc:	df000404 	addi	fp,sp,16
  8026e0:	e13fff15 	stw	r4,-4(fp)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
  8026e4:	e0bfff17 	ldw	r2,-4(fp)
  8026e8:	e0bffe15 	stw	r2,-8(fp)
BaseType_t xReturn = pdFAIL;
  8026ec:	e03ffd15 	stw	zero,-12(fp)
		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
	}
	#endif

	/* Can only reset a message buffer if there are no tasks blocked on it. */
	taskENTER_CRITICAL();
  8026f0:	0804ff40 	call	804ff4 <vTaskEnterCritical>
	{
		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
  8026f4:	e0bffe17 	ldw	r2,-8(fp)
  8026f8:	10800417 	ldw	r2,16(r2)
  8026fc:	1000141e 	bne	r2,zero,802750 <xStreamBufferReset+0x80>
		{
			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
  802700:	e0bffe17 	ldw	r2,-8(fp)
  802704:	10800517 	ldw	r2,20(r2)
  802708:	1000111e 	bne	r2,zero,802750 <xStreamBufferReset+0x80>
			{
				prvInitialiseNewStreamBuffer( pxStreamBuffer,
  80270c:	e0bffe17 	ldw	r2,-8(fp)
  802710:	10c00617 	ldw	r3,24(r2)
  802714:	e0bffe17 	ldw	r2,-8(fp)
  802718:	11000217 	ldw	r4,8(r2)
  80271c:	e0bffe17 	ldw	r2,-8(fp)
  802720:	11400317 	ldw	r5,12(r2)
											  pxStreamBuffer->pucBuffer,
											  pxStreamBuffer->xLength,
											  pxStreamBuffer->xTriggerLevelBytes,
											  pxStreamBuffer->ucFlags );
  802724:	e0bffe17 	ldw	r2,-8(fp)
  802728:	10800703 	ldbu	r2,28(r2)
	{
		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
		{
			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
			{
				prvInitialiseNewStreamBuffer( pxStreamBuffer,
  80272c:	10803fcc 	andi	r2,r2,255
  802730:	d8800015 	stw	r2,0(sp)
  802734:	280f883a 	mov	r7,r5
  802738:	200d883a 	mov	r6,r4
  80273c:	180b883a 	mov	r5,r3
  802740:	e13ffe17 	ldw	r4,-8(fp)
  802744:	08033e40 	call	8033e4 <prvInitialiseNewStreamBuffer>
											  pxStreamBuffer->pucBuffer,
											  pxStreamBuffer->xLength,
											  pxStreamBuffer->xTriggerLevelBytes,
											  pxStreamBuffer->ucFlags );
				xReturn = pdPASS;
  802748:	00800044 	movi	r2,1
  80274c:	e0bffd15 	stw	r2,-12(fp)

				traceSTREAM_BUFFER_RESET( xStreamBuffer );
			}
		}
	}
	taskEXIT_CRITICAL();
  802750:	08050480 	call	805048 <vTaskExitCritical>

	return xReturn;
  802754:	e0bffd17 	ldw	r2,-12(fp)
}
  802758:	e037883a 	mov	sp,fp
  80275c:	dfc00117 	ldw	ra,4(sp)
  802760:	df000017 	ldw	fp,0(sp)
  802764:	dec00204 	addi	sp,sp,8
  802768:	f800283a 	ret

0080276c <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
{
  80276c:	defffb04 	addi	sp,sp,-20
  802770:	df000415 	stw	fp,16(sp)
  802774:	df000404 	addi	fp,sp,16
  802778:	e13ffe15 	stw	r4,-8(fp)
  80277c:	e17fff15 	stw	r5,-4(fp)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
  802780:	e0bffe17 	ldw	r2,-8(fp)
  802784:	e0bffd15 	stw	r2,-12(fp)
BaseType_t xReturn;

	configASSERT( pxStreamBuffer );

	/* It is not valid for the trigger level to be 0. */
	if( xTriggerLevel == ( size_t ) 0 )
  802788:	e0bfff17 	ldw	r2,-4(fp)
  80278c:	1000021e 	bne	r2,zero,802798 <xStreamBufferSetTriggerLevel+0x2c>
	{
		xTriggerLevel = ( size_t ) 1;
  802790:	00800044 	movi	r2,1
  802794:	e0bfff15 	stw	r2,-4(fp)
	}

	/* The trigger level is the number of bytes that must be in the stream
	buffer before a task that is waiting for data is unblocked. */
	if( xTriggerLevel <= pxStreamBuffer->xLength )
  802798:	e0bffd17 	ldw	r2,-12(fp)
  80279c:	10c00217 	ldw	r3,8(r2)
  8027a0:	e0bfff17 	ldw	r2,-4(fp)
  8027a4:	18800636 	bltu	r3,r2,8027c0 <xStreamBufferSetTriggerLevel+0x54>
	{
		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
  8027a8:	e0bffd17 	ldw	r2,-12(fp)
  8027ac:	e0ffff17 	ldw	r3,-4(fp)
  8027b0:	10c00315 	stw	r3,12(r2)
		xReturn = pdPASS;
  8027b4:	00800044 	movi	r2,1
  8027b8:	e0bffc15 	stw	r2,-16(fp)
  8027bc:	00000106 	br	8027c4 <xStreamBufferSetTriggerLevel+0x58>
	}
	else
	{
		xReturn = pdFALSE;
  8027c0:	e03ffc15 	stw	zero,-16(fp)
	}

	return xReturn;
  8027c4:	e0bffc17 	ldw	r2,-16(fp)
}
  8027c8:	e037883a 	mov	sp,fp
  8027cc:	df000017 	ldw	fp,0(sp)
  8027d0:	dec00104 	addi	sp,sp,4
  8027d4:	f800283a 	ret

008027d8 <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
  8027d8:	defffc04 	addi	sp,sp,-16
  8027dc:	df000315 	stw	fp,12(sp)
  8027e0:	df000304 	addi	fp,sp,12
  8027e4:	e13fff15 	stw	r4,-4(fp)
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
  8027e8:	e0bfff17 	ldw	r2,-4(fp)
  8027ec:	e0bffe15 	stw	r2,-8(fp)
size_t xSpace;

	configASSERT( pxStreamBuffer );

	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
  8027f0:	e0bffe17 	ldw	r2,-8(fp)
  8027f4:	10c00217 	ldw	r3,8(r2)
  8027f8:	e0bffe17 	ldw	r2,-8(fp)
  8027fc:	10800017 	ldw	r2,0(r2)
  802800:	1885883a 	add	r2,r3,r2
  802804:	e0bffd15 	stw	r2,-12(fp)
	xSpace -= pxStreamBuffer->xHead;
  802808:	e0bffe17 	ldw	r2,-8(fp)
  80280c:	10800117 	ldw	r2,4(r2)
  802810:	e0fffd17 	ldw	r3,-12(fp)
  802814:	1885c83a 	sub	r2,r3,r2
  802818:	e0bffd15 	stw	r2,-12(fp)
	xSpace -= ( size_t ) 1;
  80281c:	e0bffd17 	ldw	r2,-12(fp)
  802820:	10bfffc4 	addi	r2,r2,-1
  802824:	e0bffd15 	stw	r2,-12(fp)

	if( xSpace >= pxStreamBuffer->xLength )
  802828:	e0bffe17 	ldw	r2,-8(fp)
  80282c:	10800217 	ldw	r2,8(r2)
  802830:	e0fffd17 	ldw	r3,-12(fp)
  802834:	18800536 	bltu	r3,r2,80284c <xStreamBufferSpacesAvailable+0x74>
	{
		xSpace -= pxStreamBuffer->xLength;
  802838:	e0bffe17 	ldw	r2,-8(fp)
  80283c:	10800217 	ldw	r2,8(r2)
  802840:	e0fffd17 	ldw	r3,-12(fp)
  802844:	1885c83a 	sub	r2,r3,r2
  802848:	e0bffd15 	stw	r2,-12(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xSpace;
  80284c:	e0bffd17 	ldw	r2,-12(fp)
}
  802850:	e037883a 	mov	sp,fp
  802854:	df000017 	ldw	fp,0(sp)
  802858:	dec00104 	addi	sp,sp,4
  80285c:	f800283a 	ret

00802860 <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
  802860:	defffb04 	addi	sp,sp,-20
  802864:	dfc00415 	stw	ra,16(sp)
  802868:	df000315 	stw	fp,12(sp)
  80286c:	df000304 	addi	fp,sp,12
  802870:	e13fff15 	stw	r4,-4(fp)
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
  802874:	e0bfff17 	ldw	r2,-4(fp)
  802878:	e0bffd15 	stw	r2,-12(fp)
size_t xReturn;

	configASSERT( pxStreamBuffer );

	xReturn = prvBytesInBuffer( pxStreamBuffer );
  80287c:	e13ffd17 	ldw	r4,-12(fp)
  802880:	08033700 	call	803370 <prvBytesInBuffer>
  802884:	e0bffe15 	stw	r2,-8(fp)
	return xReturn;
  802888:	e0bffe17 	ldw	r2,-8(fp)
}
  80288c:	e037883a 	mov	sp,fp
  802890:	dfc00117 	ldw	ra,4(sp)
  802894:	df000017 	ldw	fp,0(sp)
  802898:	dec00204 	addi	sp,sp,8
  80289c:	f800283a 	ret

008028a0 <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
						  const void *pvTxData,
						  size_t xDataLengthBytes,
						  TickType_t xTicksToWait )
{
  8028a0:	defff304 	addi	sp,sp,-52
  8028a4:	dfc00c15 	stw	ra,48(sp)
  8028a8:	df000b15 	stw	fp,44(sp)
  8028ac:	df000b04 	addi	fp,sp,44
  8028b0:	e13ffc15 	stw	r4,-16(fp)
  8028b4:	e17ffd15 	stw	r5,-12(fp)
  8028b8:	e1bffe15 	stw	r6,-8(fp)
  8028bc:	e1ffff15 	stw	r7,-4(fp)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
  8028c0:	e0bffc17 	ldw	r2,-16(fp)
  8028c4:	e0bff815 	stw	r2,-32(fp)
size_t xReturn, xSpace = 0;
  8028c8:	e03ff615 	stw	zero,-40(fp)
size_t xRequiredSpace = xDataLengthBytes;
  8028cc:	e0bffe17 	ldw	r2,-8(fp)
  8028d0:	e0bff715 	stw	r2,-36(fp)

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
  8028d4:	e0bff817 	ldw	r2,-32(fp)
  8028d8:	10800703 	ldbu	r2,28(r2)
  8028dc:	10803fcc 	andi	r2,r2,255
  8028e0:	1080004c 	andi	r2,r2,1
  8028e4:	10000326 	beq	r2,zero,8028f4 <xStreamBufferSend+0x54>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
  8028e8:	e0bff717 	ldw	r2,-36(fp)
  8028ec:	10800104 	addi	r2,r2,4
  8028f0:	e0bff715 	stw	r2,-36(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xTicksToWait != ( TickType_t ) 0 )
  8028f4:	e0bfff17 	ldw	r2,-4(fp)
  8028f8:	10002226 	beq	r2,zero,802984 <xStreamBufferSend+0xe4>
	{
		vTaskSetTimeOutState( &xTimeOut );
  8028fc:	e0bffa04 	addi	r2,fp,-24
  802900:	1009883a 	mov	r4,r2
  802904:	08048100 	call	804810 <vTaskSetTimeOutState>

		do
		{
			/* Wait until the required number of bytes are free in the message
			buffer. */
			taskENTER_CRITICAL();
  802908:	0804ff40 	call	804ff4 <vTaskEnterCritical>
			{
				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
  80290c:	e13ff817 	ldw	r4,-32(fp)
  802910:	08027d80 	call	8027d8 <xStreamBufferSpacesAvailable>
  802914:	e0bff615 	stw	r2,-40(fp)

				if( xSpace < xRequiredSpace )
  802918:	e0fff617 	ldw	r3,-40(fp)
  80291c:	e0bff717 	ldw	r2,-36(fp)
  802920:	1880072e 	bgeu	r3,r2,802940 <xStreamBufferSend+0xa0>
				{
					/* Clear notification state as going to wait for space. */
					( void ) xTaskNotifyStateClear( NULL );
  802924:	0009883a 	mov	r4,zero
  802928:	08057780 	call	805778 <xTaskNotifyStateClear>

					/* Should only be one writer. */
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
  80292c:	0804c500 	call	804c50 <xTaskGetCurrentTaskHandle>
  802930:	1007883a 	mov	r3,r2
  802934:	e0bff817 	ldw	r2,-32(fp)
  802938:	10c00515 	stw	r3,20(r2)
  80293c:	00000206 	br	802948 <xStreamBufferSend+0xa8>
				}
				else
				{
					taskEXIT_CRITICAL();
  802940:	08050480 	call	805048 <vTaskExitCritical>
					break;
  802944:	00000f06 	br	802984 <xStreamBufferSend+0xe4>
				}
			}
			taskEXIT_CRITICAL();
  802948:	08050480 	call	805048 <vTaskExitCritical>

			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
  80294c:	e0bfff17 	ldw	r2,-4(fp)
  802950:	100f883a 	mov	r7,r2
  802954:	000d883a 	mov	r6,zero
  802958:	000b883a 	mov	r5,zero
  80295c:	0009883a 	mov	r4,zero
  802960:	08051d40 	call	8051d4 <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToSend = NULL;
  802964:	e0bff817 	ldw	r2,-32(fp)
  802968:	10000515 	stw	zero,20(r2)

		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
  80296c:	e0ffff04 	addi	r3,fp,-4
  802970:	e0bffa04 	addi	r2,fp,-24
  802974:	180b883a 	mov	r5,r3
  802978:	1009883a 	mov	r4,r2
  80297c:	08048980 	call	804898 <xTaskCheckForTimeOut>
  802980:	103fe126 	beq	r2,zero,802908 <__alt_mem_onchip_memory2_0+0xff782908>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xSpace == ( size_t ) 0 )
  802984:	e0bff617 	ldw	r2,-40(fp)
  802988:	1000031e 	bne	r2,zero,802998 <xStreamBufferSend+0xf8>
	{
		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
  80298c:	e13ff817 	ldw	r4,-32(fp)
  802990:	08027d80 	call	8027d8 <xStreamBufferSpacesAvailable>
  802994:	e0bff615 	stw	r2,-40(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
  802998:	e0bff717 	ldw	r2,-36(fp)
  80299c:	d8800015 	stw	r2,0(sp)
  8029a0:	e1fff617 	ldw	r7,-40(fp)
  8029a4:	e1bffe17 	ldw	r6,-8(fp)
  8029a8:	e17ffd17 	ldw	r5,-12(fp)
  8029ac:	e13ff817 	ldw	r4,-32(fp)
  8029b0:	0802b180 	call	802b18 <prvWriteMessageToBuffer>
  8029b4:	e0bff915 	stw	r2,-28(fp)

	if( xReturn > ( size_t ) 0 )
  8029b8:	e0bff917 	ldw	r2,-28(fp)
  8029bc:	10001426 	beq	r2,zero,802a10 <xStreamBufferSend+0x170>
	{
		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
  8029c0:	e13ff817 	ldw	r4,-32(fp)
  8029c4:	08033700 	call	803370 <prvBytesInBuffer>
  8029c8:	1007883a 	mov	r3,r2
  8029cc:	e0bff817 	ldw	r2,-32(fp)
  8029d0:	10800317 	ldw	r2,12(r2)
  8029d4:	18800e36 	bltu	r3,r2,802a10 <xStreamBufferSend+0x170>
		{
			sbSEND_COMPLETED( pxStreamBuffer );
  8029d8:	08040940 	call	804094 <vTaskSuspendAll>
  8029dc:	e0bff817 	ldw	r2,-32(fp)
  8029e0:	10800417 	ldw	r2,16(r2)
  8029e4:	10000926 	beq	r2,zero,802a0c <xStreamBufferSend+0x16c>
  8029e8:	e0bff817 	ldw	r2,-32(fp)
  8029ec:	10800417 	ldw	r2,16(r2)
  8029f0:	000f883a 	mov	r7,zero
  8029f4:	000d883a 	mov	r6,zero
  8029f8:	000b883a 	mov	r5,zero
  8029fc:	1009883a 	mov	r4,r2
  802a00:	08052c80 	call	8052c8 <xTaskGenericNotify>
  802a04:	e0bff817 	ldw	r2,-32(fp)
  802a08:	10000415 	stw	zero,16(r2)
  802a0c:	08040c00 	call	8040c0 <xTaskResumeAll>
	{
		mtCOVERAGE_TEST_MARKER();
		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
	}

	return xReturn;
  802a10:	e0bff917 	ldw	r2,-28(fp)
}
  802a14:	e037883a 	mov	sp,fp
  802a18:	dfc00117 	ldw	ra,4(sp)
  802a1c:	df000017 	ldw	fp,0(sp)
  802a20:	dec00204 	addi	sp,sp,8
  802a24:	f800283a 	ret

00802a28 <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
								 const void *pvTxData,
								 size_t xDataLengthBytes,
								 BaseType_t * const pxHigherPriorityTaskWoken )
{
  802a28:	defff404 	addi	sp,sp,-48
  802a2c:	dfc00b15 	stw	ra,44(sp)
  802a30:	df000a15 	stw	fp,40(sp)
  802a34:	df000a04 	addi	fp,sp,40
  802a38:	e13ffc15 	stw	r4,-16(fp)
  802a3c:	e17ffd15 	stw	r5,-12(fp)
  802a40:	e1bffe15 	stw	r6,-8(fp)
  802a44:	e1ffff15 	stw	r7,-4(fp)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
  802a48:	e0bffc17 	ldw	r2,-16(fp)
  802a4c:	e0bff815 	stw	r2,-32(fp)
size_t xReturn, xSpace;
size_t xRequiredSpace = xDataLengthBytes;
  802a50:	e0bffe17 	ldw	r2,-8(fp)
  802a54:	e0bff715 	stw	r2,-36(fp)

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
  802a58:	e0bff817 	ldw	r2,-32(fp)
  802a5c:	10800703 	ldbu	r2,28(r2)
  802a60:	10803fcc 	andi	r2,r2,255
  802a64:	1080004c 	andi	r2,r2,1
  802a68:	10000326 	beq	r2,zero,802a78 <xStreamBufferSendFromISR+0x50>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
  802a6c:	e0bff717 	ldw	r2,-36(fp)
  802a70:	10800104 	addi	r2,r2,4
  802a74:	e0bff715 	stw	r2,-36(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
  802a78:	e13ff817 	ldw	r4,-32(fp)
  802a7c:	08027d80 	call	8027d8 <xStreamBufferSpacesAvailable>
  802a80:	e0bff915 	stw	r2,-28(fp)
	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
  802a84:	e0bff717 	ldw	r2,-36(fp)
  802a88:	d8800015 	stw	r2,0(sp)
  802a8c:	e1fff917 	ldw	r7,-28(fp)
  802a90:	e1bffe17 	ldw	r6,-8(fp)
  802a94:	e17ffd17 	ldw	r5,-12(fp)
  802a98:	e13ff817 	ldw	r4,-32(fp)
  802a9c:	0802b180 	call	802b18 <prvWriteMessageToBuffer>
  802aa0:	e0bffa15 	stw	r2,-24(fp)

	if( xReturn > ( size_t ) 0 )
  802aa4:	e0bffa17 	ldw	r2,-24(fp)
  802aa8:	10001526 	beq	r2,zero,802b00 <xStreamBufferSendFromISR+0xd8>
	{
		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
  802aac:	e13ff817 	ldw	r4,-32(fp)
  802ab0:	08033700 	call	803370 <prvBytesInBuffer>
  802ab4:	1007883a 	mov	r3,r2
  802ab8:	e0bff817 	ldw	r2,-32(fp)
  802abc:	10800317 	ldw	r2,12(r2)
  802ac0:	18800f36 	bltu	r3,r2,802b00 <xStreamBufferSendFromISR+0xd8>
		{
			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
  802ac4:	e03ffb15 	stw	zero,-20(fp)
  802ac8:	e0bff817 	ldw	r2,-32(fp)
  802acc:	10800417 	ldw	r2,16(r2)
  802ad0:	10000b26 	beq	r2,zero,802b00 <xStreamBufferSendFromISR+0xd8>
  802ad4:	e0bff817 	ldw	r2,-32(fp)
  802ad8:	10c00417 	ldw	r3,16(r2)
  802adc:	e0bfff17 	ldw	r2,-4(fp)
  802ae0:	d8800015 	stw	r2,0(sp)
  802ae4:	000f883a 	mov	r7,zero
  802ae8:	000d883a 	mov	r6,zero
  802aec:	000b883a 	mov	r5,zero
  802af0:	1809883a 	mov	r4,r3
  802af4:	08054740 	call	805474 <xTaskGenericNotifyFromISR>
  802af8:	e0bff817 	ldw	r2,-32(fp)
  802afc:	10000415 	stw	zero,16(r2)
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

	return xReturn;
  802b00:	e0bffa17 	ldw	r2,-24(fp)
}
  802b04:	e037883a 	mov	sp,fp
  802b08:	dfc00117 	ldw	ra,4(sp)
  802b0c:	df000017 	ldw	fp,0(sp)
  802b10:	dec00204 	addi	sp,sp,8
  802b14:	f800283a 	ret

00802b18 <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
									   const void * pvTxData,
									   size_t xDataLengthBytes,
									   size_t xSpace,
									   size_t xRequiredSpace )
{
  802b18:	defff804 	addi	sp,sp,-32
  802b1c:	dfc00715 	stw	ra,28(sp)
  802b20:	df000615 	stw	fp,24(sp)
  802b24:	df000604 	addi	fp,sp,24
  802b28:	e13ffc15 	stw	r4,-16(fp)
  802b2c:	e17ffd15 	stw	r5,-12(fp)
  802b30:	e1bffe15 	stw	r6,-8(fp)
  802b34:	e1ffff15 	stw	r7,-4(fp)
	BaseType_t xShouldWrite;
	size_t xReturn;

	if( xSpace == ( size_t ) 0 )
  802b38:	e0bfff17 	ldw	r2,-4(fp)
  802b3c:	1000021e 	bne	r2,zero,802b48 <prvWriteMessageToBuffer+0x30>
	{
		/* Doesn't matter if this is a stream buffer or a message buffer, there
		is no space to write. */
		xShouldWrite = pdFALSE;
  802b40:	e03ffa15 	stw	zero,-24(fp)
  802b44:	00001906 	br	802bac <prvWriteMessageToBuffer+0x94>
	}
	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
  802b48:	e0bffc17 	ldw	r2,-16(fp)
  802b4c:	10800703 	ldbu	r2,28(r2)
  802b50:	10803fcc 	andi	r2,r2,255
  802b54:	1080004c 	andi	r2,r2,1
  802b58:	1000081e 	bne	r2,zero,802b7c <prvWriteMessageToBuffer+0x64>
	{
		/* This is a stream buffer, as opposed to a message buffer, so writing a
		stream of bytes rather than discrete messages.  Write as many bytes as
		possible. */
		xShouldWrite = pdTRUE;
  802b5c:	00800044 	movi	r2,1
  802b60:	e0bffa15 	stw	r2,-24(fp)
		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
  802b64:	e0fffe17 	ldw	r3,-8(fp)
  802b68:	e0bfff17 	ldw	r2,-4(fp)
  802b6c:	1880012e 	bgeu	r3,r2,802b74 <prvWriteMessageToBuffer+0x5c>
  802b70:	1805883a 	mov	r2,r3
  802b74:	e0bffe15 	stw	r2,-8(fp)
  802b78:	00000c06 	br	802bac <prvWriteMessageToBuffer+0x94>
	}
	else if( xSpace >= xRequiredSpace )
  802b7c:	e0ffff17 	ldw	r3,-4(fp)
  802b80:	e0800217 	ldw	r2,8(fp)
  802b84:	18800836 	bltu	r3,r2,802ba8 <prvWriteMessageToBuffer+0x90>
	{
		/* This is a message buffer, as opposed to a stream buffer, and there
		is enough space to write both the message length and the message itself
		into the buffer.  Start by writing the length of the data, the data
		itself will be written later in this function. */
		xShouldWrite = pdTRUE;
  802b88:	00800044 	movi	r2,1
  802b8c:	e0bffa15 	stw	r2,-24(fp)
		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
  802b90:	e0bffe04 	addi	r2,fp,-8
  802b94:	01800104 	movi	r6,4
  802b98:	100b883a 	mov	r5,r2
  802b9c:	e13ffc17 	ldw	r4,-16(fp)
  802ba0:	08031680 	call	803168 <prvWriteBytesToBuffer>
  802ba4:	00000106 	br	802bac <prvWriteMessageToBuffer+0x94>
	}
	else
	{
		/* There is space available, but not enough space. */
		xShouldWrite = pdFALSE;
  802ba8:	e03ffa15 	stw	zero,-24(fp)
	}

	if( xShouldWrite != pdFALSE )
  802bac:	e0bffa17 	ldw	r2,-24(fp)
  802bb0:	10000726 	beq	r2,zero,802bd0 <prvWriteMessageToBuffer+0xb8>
	{
		/* Writes the data itself. */
		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
  802bb4:	e0bffe17 	ldw	r2,-8(fp)
  802bb8:	100d883a 	mov	r6,r2
  802bbc:	e17ffd17 	ldw	r5,-12(fp)
  802bc0:	e13ffc17 	ldw	r4,-16(fp)
  802bc4:	08031680 	call	803168 <prvWriteBytesToBuffer>
  802bc8:	e0bffb15 	stw	r2,-20(fp)
  802bcc:	00000106 	br	802bd4 <prvWriteMessageToBuffer+0xbc>
	}
	else
	{
		xReturn = 0;
  802bd0:	e03ffb15 	stw	zero,-20(fp)
	}

	return xReturn;
  802bd4:	e0bffb17 	ldw	r2,-20(fp)
}
  802bd8:	e037883a 	mov	sp,fp
  802bdc:	dfc00117 	ldw	ra,4(sp)
  802be0:	df000017 	ldw	fp,0(sp)
  802be4:	dec00204 	addi	sp,sp,8
  802be8:	f800283a 	ret

00802bec <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
							 void *pvRxData,
							 size_t xBufferLengthBytes,
							 TickType_t xTicksToWait )
{
  802bec:	defff504 	addi	sp,sp,-44
  802bf0:	dfc00a15 	stw	ra,40(sp)
  802bf4:	df000915 	stw	fp,36(sp)
  802bf8:	df000904 	addi	fp,sp,36
  802bfc:	e13ffc15 	stw	r4,-16(fp)
  802c00:	e17ffd15 	stw	r5,-12(fp)
  802c04:	e1bffe15 	stw	r6,-8(fp)
  802c08:	e1ffff15 	stw	r7,-4(fp)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
  802c0c:	e0bffc17 	ldw	r2,-16(fp)
  802c10:	e0bffb15 	stw	r2,-20(fp)
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
  802c14:	e03ff815 	stw	zero,-32(fp)
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
  802c18:	e0bffb17 	ldw	r2,-20(fp)
  802c1c:	10800703 	ldbu	r2,28(r2)
  802c20:	10803fcc 	andi	r2,r2,255
  802c24:	1080004c 	andi	r2,r2,1
  802c28:	10000326 	beq	r2,zero,802c38 <xStreamBufferReceive+0x4c>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
  802c2c:	00800104 	movi	r2,4
  802c30:	e0bffa15 	stw	r2,-24(fp)
  802c34:	00000106 	br	802c3c <xStreamBufferReceive+0x50>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
  802c38:	e03ffa15 	stw	zero,-24(fp)
	}

	if( xTicksToWait != ( TickType_t ) 0 )
  802c3c:	e0bfff17 	ldw	r2,-4(fp)
  802c40:	10001c26 	beq	r2,zero,802cb4 <xStreamBufferReceive+0xc8>
	{
		/* Checking if there is data and clearing the notification state must be
		performed atomically. */
		taskENTER_CRITICAL();
  802c44:	0804ff40 	call	804ff4 <vTaskEnterCritical>
		{
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
  802c48:	e13ffb17 	ldw	r4,-20(fp)
  802c4c:	08033700 	call	803370 <prvBytesInBuffer>
  802c50:	e0bff915 	stw	r2,-28(fp)
			/* If this function was invoked by a message buffer read then
			xBytesToStoreMessageLength holds the number of bytes used to hold
			the length of the next discrete message.  If this function was
			invoked by a stream buffer read then xBytesToStoreMessageLength will
			be 0. */
			if( xBytesAvailable <= xBytesToStoreMessageLength )
  802c54:	e0bff917 	ldw	r2,-28(fp)
  802c58:	e0fffa17 	ldw	r3,-24(fp)
  802c5c:	18800636 	bltu	r3,r2,802c78 <xStreamBufferReceive+0x8c>
			{
				/* Clear notification state as going to wait for data. */
				( void ) xTaskNotifyStateClear( NULL );
  802c60:	0009883a 	mov	r4,zero
  802c64:	08057780 	call	805778 <xTaskNotifyStateClear>

				/* Should only be one reader. */
				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
  802c68:	0804c500 	call	804c50 <xTaskGetCurrentTaskHandle>
  802c6c:	1007883a 	mov	r3,r2
  802c70:	e0bffb17 	ldw	r2,-20(fp)
  802c74:	10c00415 	stw	r3,16(r2)
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
  802c78:	08050480 	call	805048 <vTaskExitCritical>

		if( xBytesAvailable <= xBytesToStoreMessageLength )
  802c7c:	e0bff917 	ldw	r2,-28(fp)
  802c80:	e0fffa17 	ldw	r3,-24(fp)
  802c84:	18800e36 	bltu	r3,r2,802cc0 <xStreamBufferReceive+0xd4>
		{
			/* Wait for data to be available. */
			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
  802c88:	e1ffff17 	ldw	r7,-4(fp)
  802c8c:	000d883a 	mov	r6,zero
  802c90:	000b883a 	mov	r5,zero
  802c94:	0009883a 	mov	r4,zero
  802c98:	08051d40 	call	8051d4 <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToReceive = NULL;
  802c9c:	e0bffb17 	ldw	r2,-20(fp)
  802ca0:	10000415 	stw	zero,16(r2)

			/* Recheck the data available after blocking. */
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
  802ca4:	e13ffb17 	ldw	r4,-20(fp)
  802ca8:	08033700 	call	803370 <prvBytesInBuffer>
  802cac:	e0bff915 	stw	r2,-28(fp)
  802cb0:	00000306 	br	802cc0 <xStreamBufferReceive+0xd4>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
  802cb4:	e13ffb17 	ldw	r4,-20(fp)
  802cb8:	08033700 	call	803370 <prvBytesInBuffer>
  802cbc:	e0bff915 	stw	r2,-28(fp)
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
  802cc0:	e0bff917 	ldw	r2,-28(fp)
  802cc4:	e0fffa17 	ldw	r3,-24(fp)
  802cc8:	1880182e 	bgeu	r3,r2,802d2c <xStreamBufferReceive+0x140>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
  802ccc:	e0bffa17 	ldw	r2,-24(fp)
  802cd0:	d8800015 	stw	r2,0(sp)
  802cd4:	e1fff917 	ldw	r7,-28(fp)
  802cd8:	e1bffe17 	ldw	r6,-8(fp)
  802cdc:	e17ffd17 	ldw	r5,-12(fp)
  802ce0:	e13ffb17 	ldw	r4,-20(fp)
  802ce4:	0802ed00 	call	802ed0 <prvReadMessageFromBuffer>
  802ce8:	e0bff815 	stw	r2,-32(fp)

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
  802cec:	e0bff817 	ldw	r2,-32(fp)
  802cf0:	10000e26 	beq	r2,zero,802d2c <xStreamBufferReceive+0x140>
		{
			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
			sbRECEIVE_COMPLETED( pxStreamBuffer );
  802cf4:	08040940 	call	804094 <vTaskSuspendAll>
  802cf8:	e0bffb17 	ldw	r2,-20(fp)
  802cfc:	10800517 	ldw	r2,20(r2)
  802d00:	10000926 	beq	r2,zero,802d28 <xStreamBufferReceive+0x13c>
  802d04:	e0bffb17 	ldw	r2,-20(fp)
  802d08:	10800517 	ldw	r2,20(r2)
  802d0c:	000f883a 	mov	r7,zero
  802d10:	000d883a 	mov	r6,zero
  802d14:	000b883a 	mov	r5,zero
  802d18:	1009883a 	mov	r4,r2
  802d1c:	08052c80 	call	8052c8 <xTaskGenericNotify>
  802d20:	e0bffb17 	ldw	r2,-20(fp)
  802d24:	10000515 	stw	zero,20(r2)
  802d28:	08040c00 	call	8040c0 <xTaskResumeAll>
	{
		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
		mtCOVERAGE_TEST_MARKER();
	}

	return xReceivedLength;
  802d2c:	e0bff817 	ldw	r2,-32(fp)
}
  802d30:	e037883a 	mov	sp,fp
  802d34:	dfc00117 	ldw	ra,4(sp)
  802d38:	df000017 	ldw	fp,0(sp)
  802d3c:	dec00204 	addi	sp,sp,8
  802d40:	f800283a 	ret

00802d44 <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
  802d44:	defff804 	addi	sp,sp,-32
  802d48:	dfc00715 	stw	ra,28(sp)
  802d4c:	df000615 	stw	fp,24(sp)
  802d50:	df000604 	addi	fp,sp,24
  802d54:	e13fff15 	stw	r4,-4(fp)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
  802d58:	e0bfff17 	ldw	r2,-4(fp)
  802d5c:	e0bffb15 	stw	r2,-20(fp)
configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

	configASSERT( pxStreamBuffer );

	/* Ensure the stream buffer is being used as a message buffer. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
  802d60:	e0bffb17 	ldw	r2,-20(fp)
  802d64:	10800703 	ldbu	r2,28(r2)
  802d68:	10803fcc 	andi	r2,r2,255
  802d6c:	1080004c 	andi	r2,r2,1
  802d70:	10001726 	beq	r2,zero,802dd0 <xStreamBufferNextMessageLengthBytes+0x8c>
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
  802d74:	e13ffb17 	ldw	r4,-20(fp)
  802d78:	08033700 	call	803370 <prvBytesInBuffer>
  802d7c:	e0bffc15 	stw	r2,-16(fp)
		if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
  802d80:	e0bffc17 	ldw	r2,-16(fp)
  802d84:	10800170 	cmpltui	r2,r2,5
  802d88:	10000f1e 	bne	r2,zero,802dc8 <xStreamBufferNextMessageLengthBytes+0x84>
			required to hold the length of the next message, so another message
			is available.  Return its length without removing the length bytes
			from the buffer.  A copy of the tail is stored so the buffer can be
			returned to its prior state as the message is not actually being
			removed from the buffer. */
			xOriginalTail = pxStreamBuffer->xTail;
  802d8c:	e0bffb17 	ldw	r2,-20(fp)
  802d90:	10800017 	ldw	r2,0(r2)
  802d94:	e0bffd15 	stw	r2,-12(fp)
			( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );
  802d98:	e0bffe04 	addi	r2,fp,-8
  802d9c:	e1fffc17 	ldw	r7,-16(fp)
  802da0:	01800104 	movi	r6,4
  802da4:	100b883a 	mov	r5,r2
  802da8:	e13ffb17 	ldw	r4,-20(fp)
  802dac:	080325c0 	call	80325c <prvReadBytesFromBuffer>
			xReturn = ( size_t ) xTempReturn;
  802db0:	e0bffe17 	ldw	r2,-8(fp)
  802db4:	e0bffa15 	stw	r2,-24(fp)
			pxStreamBuffer->xTail = xOriginalTail;
  802db8:	e0bffb17 	ldw	r2,-20(fp)
  802dbc:	e0fffd17 	ldw	r3,-12(fp)
  802dc0:	10c00015 	stw	r3,0(r2)
  802dc4:	00000306 	br	802dd4 <xStreamBufferNextMessageLengthBytes+0x90>
			/* The minimum amount of bytes in a message buffer is
			( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
			less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
			value is 0. */
			configASSERT( xBytesAvailable == 0 );
			xReturn = 0;
  802dc8:	e03ffa15 	stw	zero,-24(fp)
  802dcc:	00000106 	br	802dd4 <xStreamBufferNextMessageLengthBytes+0x90>
		}
	}
	else
	{
		xReturn = 0;
  802dd0:	e03ffa15 	stw	zero,-24(fp)
	}

	return xReturn;
  802dd4:	e0bffa17 	ldw	r2,-24(fp)
}
  802dd8:	e037883a 	mov	sp,fp
  802ddc:	dfc00117 	ldw	ra,4(sp)
  802de0:	df000017 	ldw	fp,0(sp)
  802de4:	dec00204 	addi	sp,sp,8
  802de8:	f800283a 	ret

00802dec <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
									void *pvRxData,
									size_t xBufferLengthBytes,
									BaseType_t * const pxHigherPriorityTaskWoken )
{
  802dec:	defff404 	addi	sp,sp,-48
  802df0:	dfc00b15 	stw	ra,44(sp)
  802df4:	df000a15 	stw	fp,40(sp)
  802df8:	df000a04 	addi	fp,sp,40
  802dfc:	e13ffc15 	stw	r4,-16(fp)
  802e00:	e17ffd15 	stw	r5,-12(fp)
  802e04:	e1bffe15 	stw	r6,-8(fp)
  802e08:	e1ffff15 	stw	r7,-4(fp)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
  802e0c:	e0bffc17 	ldw	r2,-16(fp)
  802e10:	e0bff915 	stw	r2,-28(fp)
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
  802e14:	e03ff715 	stw	zero,-36(fp)
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
  802e18:	e0bff917 	ldw	r2,-28(fp)
  802e1c:	10800703 	ldbu	r2,28(r2)
  802e20:	10803fcc 	andi	r2,r2,255
  802e24:	1080004c 	andi	r2,r2,1
  802e28:	10000326 	beq	r2,zero,802e38 <xStreamBufferReceiveFromISR+0x4c>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
  802e2c:	00800104 	movi	r2,4
  802e30:	e0bff815 	stw	r2,-32(fp)
  802e34:	00000106 	br	802e3c <xStreamBufferReceiveFromISR+0x50>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
  802e38:	e03ff815 	stw	zero,-32(fp)
	}

	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
  802e3c:	e13ff917 	ldw	r4,-28(fp)
  802e40:	08033700 	call	803370 <prvBytesInBuffer>
  802e44:	e0bffa15 	stw	r2,-24(fp)
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
  802e48:	e0bffa17 	ldw	r2,-24(fp)
  802e4c:	e0fff817 	ldw	r3,-32(fp)
  802e50:	1880192e 	bgeu	r3,r2,802eb8 <xStreamBufferReceiveFromISR+0xcc>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
  802e54:	e0bff817 	ldw	r2,-32(fp)
  802e58:	d8800015 	stw	r2,0(sp)
  802e5c:	e1fffa17 	ldw	r7,-24(fp)
  802e60:	e1bffe17 	ldw	r6,-8(fp)
  802e64:	e17ffd17 	ldw	r5,-12(fp)
  802e68:	e13ff917 	ldw	r4,-28(fp)
  802e6c:	0802ed00 	call	802ed0 <prvReadMessageFromBuffer>
  802e70:	e0bff715 	stw	r2,-36(fp)

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
  802e74:	e0bff717 	ldw	r2,-36(fp)
  802e78:	10000f26 	beq	r2,zero,802eb8 <xStreamBufferReceiveFromISR+0xcc>
		{
			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
  802e7c:	e03ffb15 	stw	zero,-20(fp)
  802e80:	e0bff917 	ldw	r2,-28(fp)
  802e84:	10800517 	ldw	r2,20(r2)
  802e88:	10000b26 	beq	r2,zero,802eb8 <xStreamBufferReceiveFromISR+0xcc>
  802e8c:	e0bff917 	ldw	r2,-28(fp)
  802e90:	10c00517 	ldw	r3,20(r2)
  802e94:	e0bfff17 	ldw	r2,-4(fp)
  802e98:	d8800015 	stw	r2,0(sp)
  802e9c:	000f883a 	mov	r7,zero
  802ea0:	000d883a 	mov	r6,zero
  802ea4:	000b883a 	mov	r5,zero
  802ea8:	1809883a 	mov	r4,r3
  802eac:	08054740 	call	805474 <xTaskGenericNotifyFromISR>
  802eb0:	e0bff917 	ldw	r2,-28(fp)
  802eb4:	10000515 	stw	zero,20(r2)
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

	return xReceivedLength;
  802eb8:	e0bff717 	ldw	r2,-36(fp)
}
  802ebc:	e037883a 	mov	sp,fp
  802ec0:	dfc00117 	ldw	ra,4(sp)
  802ec4:	df000017 	ldw	fp,0(sp)
  802ec8:	dec00204 	addi	sp,sp,8
  802ecc:	f800283a 	ret

00802ed0 <prvReadMessageFromBuffer>:
static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
										void *pvRxData,
										size_t xBufferLengthBytes,
										size_t xBytesAvailable,
										size_t xBytesToStoreMessageLength )
{
  802ed0:	defff604 	addi	sp,sp,-40
  802ed4:	dfc00915 	stw	ra,36(sp)
  802ed8:	df000815 	stw	fp,32(sp)
  802edc:	df000804 	addi	fp,sp,32
  802ee0:	e13ffc15 	stw	r4,-16(fp)
  802ee4:	e17ffd15 	stw	r5,-12(fp)
  802ee8:	e1bffe15 	stw	r6,-8(fp)
  802eec:	e1ffff15 	stw	r7,-4(fp)
size_t xOriginalTail, xReceivedLength, xNextMessageLength;
configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;

	if( xBytesToStoreMessageLength != ( size_t ) 0 )
  802ef0:	e0800217 	ldw	r2,8(fp)
  802ef4:	10001726 	beq	r2,zero,802f54 <prvReadMessageFromBuffer+0x84>
	{
		/* A discrete message is being received.  First receive the length
		of the message.  A copy of the tail is stored so the buffer can be
		returned to its prior state if the length of the message is too
		large for the provided buffer. */
		xOriginalTail = pxStreamBuffer->xTail;
  802ef8:	e0bffc17 	ldw	r2,-16(fp)
  802efc:	10800017 	ldw	r2,0(r2)
  802f00:	e0bff915 	stw	r2,-28(fp)
		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
  802f04:	e0bffb04 	addi	r2,fp,-20
  802f08:	e1ffff17 	ldw	r7,-4(fp)
  802f0c:	e1800217 	ldw	r6,8(fp)
  802f10:	100b883a 	mov	r5,r2
  802f14:	e13ffc17 	ldw	r4,-16(fp)
  802f18:	080325c0 	call	80325c <prvReadBytesFromBuffer>
		xNextMessageLength = ( size_t ) xTempNextMessageLength;
  802f1c:	e0bffb17 	ldw	r2,-20(fp)
  802f20:	e0bff815 	stw	r2,-32(fp)

		/* Reduce the number of bytes available by the number of bytes just
		read out. */
		xBytesAvailable -= xBytesToStoreMessageLength;
  802f24:	e0ffff17 	ldw	r3,-4(fp)
  802f28:	e0800217 	ldw	r2,8(fp)
  802f2c:	1885c83a 	sub	r2,r3,r2
  802f30:	e0bfff15 	stw	r2,-4(fp)

		/* Check there is enough space in the buffer provided by the
		user. */
		if( xNextMessageLength > xBufferLengthBytes )
  802f34:	e0bff817 	ldw	r2,-32(fp)
  802f38:	e0fffe17 	ldw	r3,-8(fp)
  802f3c:	1880072e 	bgeu	r3,r2,802f5c <prvReadMessageFromBuffer+0x8c>
		{
			/* The user has provided insufficient space to read the message
			so return the buffer to its previous state (so the length of
			the message is in the buffer again). */
			pxStreamBuffer->xTail = xOriginalTail;
  802f40:	e0bffc17 	ldw	r2,-16(fp)
  802f44:	e0fff917 	ldw	r3,-28(fp)
  802f48:	10c00015 	stw	r3,0(r2)
			xNextMessageLength = 0;
  802f4c:	e03ff815 	stw	zero,-32(fp)
  802f50:	00000206 	br	802f5c <prvReadMessageFromBuffer+0x8c>
	}
	else
	{
		/* A stream of bytes is being received (as opposed to a discrete
		message), so read as many bytes as possible. */
		xNextMessageLength = xBufferLengthBytes;
  802f54:	e0bffe17 	ldw	r2,-8(fp)
  802f58:	e0bff815 	stw	r2,-32(fp)
	}

	/* Read the actual data. */
	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
  802f5c:	e1ffff17 	ldw	r7,-4(fp)
  802f60:	e1bff817 	ldw	r6,-32(fp)
  802f64:	e17ffd17 	ldw	r5,-12(fp)
  802f68:	e13ffc17 	ldw	r4,-16(fp)
  802f6c:	080325c0 	call	80325c <prvReadBytesFromBuffer>
  802f70:	e0bffa15 	stw	r2,-24(fp)

	return xReceivedLength;
  802f74:	e0bffa17 	ldw	r2,-24(fp)
}
  802f78:	e037883a 	mov	sp,fp
  802f7c:	dfc00117 	ldw	ra,4(sp)
  802f80:	df000017 	ldw	fp,0(sp)
  802f84:	dec00204 	addi	sp,sp,8
  802f88:	f800283a 	ret

00802f8c <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
  802f8c:	defffb04 	addi	sp,sp,-20
  802f90:	df000415 	stw	fp,16(sp)
  802f94:	df000404 	addi	fp,sp,16
  802f98:	e13fff15 	stw	r4,-4(fp)
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
  802f9c:	e0bfff17 	ldw	r2,-4(fp)
  802fa0:	e0bffd15 	stw	r2,-12(fp)
size_t xTail;

	configASSERT( pxStreamBuffer );

	/* True if no bytes are available. */
	xTail = pxStreamBuffer->xTail;
  802fa4:	e0bffd17 	ldw	r2,-12(fp)
  802fa8:	10800017 	ldw	r2,0(r2)
  802fac:	e0bffe15 	stw	r2,-8(fp)
	if( pxStreamBuffer->xHead == xTail )
  802fb0:	e0bffd17 	ldw	r2,-12(fp)
  802fb4:	10c00117 	ldw	r3,4(r2)
  802fb8:	e0bffe17 	ldw	r2,-8(fp)
  802fbc:	1880031e 	bne	r3,r2,802fcc <xStreamBufferIsEmpty+0x40>
	{
		xReturn = pdTRUE;
  802fc0:	00800044 	movi	r2,1
  802fc4:	e0bffc15 	stw	r2,-16(fp)
  802fc8:	00000106 	br	802fd0 <xStreamBufferIsEmpty+0x44>
	}
	else
	{
		xReturn = pdFALSE;
  802fcc:	e03ffc15 	stw	zero,-16(fp)
	}

	return xReturn;
  802fd0:	e0bffc17 	ldw	r2,-16(fp)
}
  802fd4:	e037883a 	mov	sp,fp
  802fd8:	df000017 	ldw	fp,0(sp)
  802fdc:	dec00104 	addi	sp,sp,4
  802fe0:	f800283a 	ret

00802fe4 <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
  802fe4:	defffa04 	addi	sp,sp,-24
  802fe8:	dfc00515 	stw	ra,20(sp)
  802fec:	df000415 	stw	fp,16(sp)
  802ff0:	df000404 	addi	fp,sp,16
  802ff4:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;
size_t xBytesToStoreMessageLength;
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
  802ff8:	e0bfff17 	ldw	r2,-4(fp)
  802ffc:	e0bffe15 	stw	r2,-8(fp)

	/* This generic version of the receive function is used by both message
	buffers, which store discrete messages, and stream buffers, which store a
	continuous stream of bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
  803000:	e0bffe17 	ldw	r2,-8(fp)
  803004:	10800703 	ldbu	r2,28(r2)
  803008:	10803fcc 	andi	r2,r2,255
  80300c:	1080004c 	andi	r2,r2,1
  803010:	10000326 	beq	r2,zero,803020 <xStreamBufferIsFull+0x3c>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
  803014:	00800104 	movi	r2,4
  803018:	e0bffd15 	stw	r2,-12(fp)
  80301c:	00000106 	br	803024 <xStreamBufferIsFull+0x40>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
  803020:	e03ffd15 	stw	zero,-12(fp)
	}

	/* True if the available space equals zero. */
	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
  803024:	e13fff17 	ldw	r4,-4(fp)
  803028:	08027d80 	call	8027d8 <xStreamBufferSpacesAvailable>
  80302c:	1007883a 	mov	r3,r2
  803030:	e0bffd17 	ldw	r2,-12(fp)
  803034:	10c00336 	bltu	r2,r3,803044 <xStreamBufferIsFull+0x60>
	{
		xReturn = pdTRUE;
  803038:	00800044 	movi	r2,1
  80303c:	e0bffc15 	stw	r2,-16(fp)
  803040:	00000106 	br	803048 <xStreamBufferIsFull+0x64>
	}
	else
	{
		xReturn = pdFALSE;
  803044:	e03ffc15 	stw	zero,-16(fp)
	}

	return xReturn;
  803048:	e0bffc17 	ldw	r2,-16(fp)
}
  80304c:	e037883a 	mov	sp,fp
  803050:	dfc00117 	ldw	ra,4(sp)
  803054:	df000017 	ldw	fp,0(sp)
  803058:	dec00204 	addi	sp,sp,8
  80305c:	f800283a 	ret

00803060 <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
  803060:	defff804 	addi	sp,sp,-32
  803064:	dfc00715 	stw	ra,28(sp)
  803068:	df000615 	stw	fp,24(sp)
  80306c:	df000604 	addi	fp,sp,24
  803070:	e13ffe15 	stw	r4,-8(fp)
  803074:	e17fff15 	stw	r5,-4(fp)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
  803078:	e0bffe17 	ldw	r2,-8(fp)
  80307c:	e0bffc15 	stw	r2,-16(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
  803080:	e03ffd15 	stw	zero,-12(fp)
	{
		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
  803084:	e0bffc17 	ldw	r2,-16(fp)
  803088:	10800417 	ldw	r2,16(r2)
  80308c:	10000e26 	beq	r2,zero,8030c8 <xStreamBufferSendCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
  803090:	e0bffc17 	ldw	r2,-16(fp)
  803094:	10c00417 	ldw	r3,16(r2)
  803098:	e0bfff17 	ldw	r2,-4(fp)
  80309c:	d8800015 	stw	r2,0(sp)
  8030a0:	000f883a 	mov	r7,zero
  8030a4:	000d883a 	mov	r6,zero
  8030a8:	000b883a 	mov	r5,zero
  8030ac:	1809883a 	mov	r4,r3
  8030b0:	08054740 	call	805474 <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
  8030b4:	e0bffc17 	ldw	r2,-16(fp)
  8030b8:	10000415 	stw	zero,16(r2)
			xReturn = pdTRUE;
  8030bc:	00800044 	movi	r2,1
  8030c0:	e0bffb15 	stw	r2,-20(fp)
  8030c4:	00000106 	br	8030cc <xStreamBufferSendCompletedFromISR+0x6c>
		}
		else
		{
			xReturn = pdFALSE;
  8030c8:	e03ffb15 	stw	zero,-20(fp)
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
  8030cc:	e0bffb17 	ldw	r2,-20(fp)
}
  8030d0:	e037883a 	mov	sp,fp
  8030d4:	dfc00117 	ldw	ra,4(sp)
  8030d8:	df000017 	ldw	fp,0(sp)
  8030dc:	dec00204 	addi	sp,sp,8
  8030e0:	f800283a 	ret

008030e4 <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
  8030e4:	defff804 	addi	sp,sp,-32
  8030e8:	dfc00715 	stw	ra,28(sp)
  8030ec:	df000615 	stw	fp,24(sp)
  8030f0:	df000604 	addi	fp,sp,24
  8030f4:	e13ffe15 	stw	r4,-8(fp)
  8030f8:	e17fff15 	stw	r5,-4(fp)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
  8030fc:	e0bffe17 	ldw	r2,-8(fp)
  803100:	e0bffc15 	stw	r2,-16(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
  803104:	e03ffd15 	stw	zero,-12(fp)
	{
		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
  803108:	e0bffc17 	ldw	r2,-16(fp)
  80310c:	10800517 	ldw	r2,20(r2)
  803110:	10000e26 	beq	r2,zero,80314c <xStreamBufferReceiveCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
  803114:	e0bffc17 	ldw	r2,-16(fp)
  803118:	10c00517 	ldw	r3,20(r2)
  80311c:	e0bfff17 	ldw	r2,-4(fp)
  803120:	d8800015 	stw	r2,0(sp)
  803124:	000f883a 	mov	r7,zero
  803128:	000d883a 	mov	r6,zero
  80312c:	000b883a 	mov	r5,zero
  803130:	1809883a 	mov	r4,r3
  803134:	08054740 	call	805474 <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
  803138:	e0bffc17 	ldw	r2,-16(fp)
  80313c:	10000515 	stw	zero,20(r2)
			xReturn = pdTRUE;
  803140:	00800044 	movi	r2,1
  803144:	e0bffb15 	stw	r2,-20(fp)
  803148:	00000106 	br	803150 <xStreamBufferReceiveCompletedFromISR+0x6c>
		}
		else
		{
			xReturn = pdFALSE;
  80314c:	e03ffb15 	stw	zero,-20(fp)
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
  803150:	e0bffb17 	ldw	r2,-20(fp)
}
  803154:	e037883a 	mov	sp,fp
  803158:	dfc00117 	ldw	ra,4(sp)
  80315c:	df000017 	ldw	fp,0(sp)
  803160:	dec00204 	addi	sp,sp,8
  803164:	f800283a 	ret

00803168 <prvWriteBytesToBuffer>:
/*-----------------------------------------------------------*/

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
{
  803168:	defff904 	addi	sp,sp,-28
  80316c:	dfc00615 	stw	ra,24(sp)
  803170:	df000515 	stw	fp,20(sp)
  803174:	df000504 	addi	fp,sp,20
  803178:	e13ffd15 	stw	r4,-12(fp)
  80317c:	e17ffe15 	stw	r5,-8(fp)
  803180:	e1bfff15 	stw	r6,-4(fp)
size_t xNextHead, xFirstLength;

	configASSERT( xCount > ( size_t ) 0 );

	xNextHead = pxStreamBuffer->xHead;
  803184:	e0bffd17 	ldw	r2,-12(fp)
  803188:	10800117 	ldw	r2,4(r2)
  80318c:	e0bffb15 	stw	r2,-20(fp)

	/* Calculate the number of bytes that can be added in the first write -
	which may be less than the total number of bytes that need to be added if
	the buffer will wrap back to the beginning. */
	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
  803190:	e0bffd17 	ldw	r2,-12(fp)
  803194:	10c00217 	ldw	r3,8(r2)
  803198:	e0bffb17 	ldw	r2,-20(fp)
  80319c:	1885c83a 	sub	r2,r3,r2
  8031a0:	e0ffff17 	ldw	r3,-4(fp)
  8031a4:	1880012e 	bgeu	r3,r2,8031ac <prvWriteBytesToBuffer+0x44>
  8031a8:	1805883a 	mov	r2,r3
  8031ac:	e0bffc15 	stw	r2,-16(fp)

	/* Write as many bytes as can be written in the first write. */
	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
	( void ) memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
  8031b0:	e0bffd17 	ldw	r2,-12(fp)
  8031b4:	10c00617 	ldw	r3,24(r2)
  8031b8:	e0bffb17 	ldw	r2,-20(fp)
  8031bc:	1885883a 	add	r2,r3,r2
  8031c0:	e1bffc17 	ldw	r6,-16(fp)
  8031c4:	e17ffe17 	ldw	r5,-8(fp)
  8031c8:	1009883a 	mov	r4,r2
  8031cc:	08066f00 	call	8066f0 <memcpy>

	/* If the number of bytes written was less than the number that could be
	written in the first write... */
	if( xCount > xFirstLength )
  8031d0:	e0bfff17 	ldw	r2,-4(fp)
  8031d4:	e0fffc17 	ldw	r3,-16(fp)
  8031d8:	18800a2e 	bgeu	r3,r2,803204 <prvWriteBytesToBuffer+0x9c>
	{
		/* ...then write the remaining bytes to the start of the buffer. */
		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
  8031dc:	e0bffd17 	ldw	r2,-12(fp)
  8031e0:	11000617 	ldw	r4,24(r2)
  8031e4:	e0fffe17 	ldw	r3,-8(fp)
  8031e8:	e0bffc17 	ldw	r2,-16(fp)
  8031ec:	188b883a 	add	r5,r3,r2
  8031f0:	e0ffff17 	ldw	r3,-4(fp)
  8031f4:	e0bffc17 	ldw	r2,-16(fp)
  8031f8:	1885c83a 	sub	r2,r3,r2
  8031fc:	100d883a 	mov	r6,r2
  803200:	08066f00 	call	8066f0 <memcpy>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xNextHead += xCount;
  803204:	e0fffb17 	ldw	r3,-20(fp)
  803208:	e0bfff17 	ldw	r2,-4(fp)
  80320c:	1885883a 	add	r2,r3,r2
  803210:	e0bffb15 	stw	r2,-20(fp)
	if( xNextHead >= pxStreamBuffer->xLength )
  803214:	e0bffd17 	ldw	r2,-12(fp)
  803218:	10800217 	ldw	r2,8(r2)
  80321c:	e0fffb17 	ldw	r3,-20(fp)
  803220:	18800536 	bltu	r3,r2,803238 <prvWriteBytesToBuffer+0xd0>
	{
		xNextHead -= pxStreamBuffer->xLength;
  803224:	e0bffd17 	ldw	r2,-12(fp)
  803228:	10800217 	ldw	r2,8(r2)
  80322c:	e0fffb17 	ldw	r3,-20(fp)
  803230:	1885c83a 	sub	r2,r3,r2
  803234:	e0bffb15 	stw	r2,-20(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxStreamBuffer->xHead = xNextHead;
  803238:	e0bffd17 	ldw	r2,-12(fp)
  80323c:	e0fffb17 	ldw	r3,-20(fp)
  803240:	10c00115 	stw	r3,4(r2)

	return xCount;
  803244:	e0bfff17 	ldw	r2,-4(fp)
}
  803248:	e037883a 	mov	sp,fp
  80324c:	dfc00117 	ldw	ra,4(sp)
  803250:	df000017 	ldw	fp,0(sp)
  803254:	dec00204 	addi	sp,sp,8
  803258:	f800283a 	ret

0080325c <prvReadBytesFromBuffer>:
/*-----------------------------------------------------------*/

static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
{
  80325c:	defff704 	addi	sp,sp,-36
  803260:	dfc00815 	stw	ra,32(sp)
  803264:	df000715 	stw	fp,28(sp)
  803268:	df000704 	addi	fp,sp,28
  80326c:	e13ffc15 	stw	r4,-16(fp)
  803270:	e17ffd15 	stw	r5,-12(fp)
  803274:	e1bffe15 	stw	r6,-8(fp)
  803278:	e1ffff15 	stw	r7,-4(fp)
size_t xCount, xFirstLength, xNextTail;

	/* Use the minimum of the wanted bytes and the available bytes. */
	xCount = configMIN( xBytesAvailable, xMaxCount );
  80327c:	e0ffff17 	ldw	r3,-4(fp)
  803280:	e0bffe17 	ldw	r2,-8(fp)
  803284:	1880012e 	bgeu	r3,r2,80328c <prvReadBytesFromBuffer+0x30>
  803288:	1805883a 	mov	r2,r3
  80328c:	e0bffa15 	stw	r2,-24(fp)

	if( xCount > ( size_t ) 0 )
  803290:	e0bffa17 	ldw	r2,-24(fp)
  803294:	10003026 	beq	r2,zero,803358 <prvReadBytesFromBuffer+0xfc>
	{
		xNextTail = pxStreamBuffer->xTail;
  803298:	e0bffc17 	ldw	r2,-16(fp)
  80329c:	10800017 	ldw	r2,0(r2)
  8032a0:	e0bff915 	stw	r2,-28(fp)

		/* Calculate the number of bytes that can be read - which may be
		less than the number wanted if the data wraps around to the start of
		the buffer. */
		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
  8032a4:	e0bffc17 	ldw	r2,-16(fp)
  8032a8:	10c00217 	ldw	r3,8(r2)
  8032ac:	e0bff917 	ldw	r2,-28(fp)
  8032b0:	1885c83a 	sub	r2,r3,r2
  8032b4:	e0fffa17 	ldw	r3,-24(fp)
  8032b8:	1880012e 	bgeu	r3,r2,8032c0 <prvReadBytesFromBuffer+0x64>
  8032bc:	1805883a 	mov	r2,r3
  8032c0:	e0bffb15 	stw	r2,-20(fp)

		/* Obtain the number of bytes it is possible to obtain in the first
		read.  Asserts check bounds of read and write. */
		configASSERT( xFirstLength <= xMaxCount );
		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
  8032c4:	e0bffc17 	ldw	r2,-16(fp)
  8032c8:	10c00617 	ldw	r3,24(r2)
  8032cc:	e0bff917 	ldw	r2,-28(fp)
  8032d0:	1885883a 	add	r2,r3,r2
  8032d4:	e1bffb17 	ldw	r6,-20(fp)
  8032d8:	100b883a 	mov	r5,r2
  8032dc:	e13ffd17 	ldw	r4,-12(fp)
  8032e0:	08066f00 	call	8066f0 <memcpy>

		/* If the total number of wanted bytes is greater than the number
		that could be read in the first read... */
		if( xCount > xFirstLength )
  8032e4:	e0bffa17 	ldw	r2,-24(fp)
  8032e8:	e0fffb17 	ldw	r3,-20(fp)
  8032ec:	18800a2e 	bgeu	r3,r2,803318 <prvReadBytesFromBuffer+0xbc>
		{
			/*...then read the remaining bytes from the start of the buffer. */
			configASSERT( xCount <= xMaxCount );
			( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
  8032f0:	e0fffd17 	ldw	r3,-12(fp)
  8032f4:	e0bffb17 	ldw	r2,-20(fp)
  8032f8:	1889883a 	add	r4,r3,r2
  8032fc:	e0bffc17 	ldw	r2,-16(fp)
  803300:	11400617 	ldw	r5,24(r2)
  803304:	e0fffa17 	ldw	r3,-24(fp)
  803308:	e0bffb17 	ldw	r2,-20(fp)
  80330c:	1885c83a 	sub	r2,r3,r2
  803310:	100d883a 	mov	r6,r2
  803314:	08066f00 	call	8066f0 <memcpy>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Move the tail pointer to effectively remove the data read from
		the buffer. */
		xNextTail += xCount;
  803318:	e0fff917 	ldw	r3,-28(fp)
  80331c:	e0bffa17 	ldw	r2,-24(fp)
  803320:	1885883a 	add	r2,r3,r2
  803324:	e0bff915 	stw	r2,-28(fp)

		if( xNextTail >= pxStreamBuffer->xLength )
  803328:	e0bffc17 	ldw	r2,-16(fp)
  80332c:	10800217 	ldw	r2,8(r2)
  803330:	e0fff917 	ldw	r3,-28(fp)
  803334:	18800536 	bltu	r3,r2,80334c <prvReadBytesFromBuffer+0xf0>
		{
			xNextTail -= pxStreamBuffer->xLength;
  803338:	e0bffc17 	ldw	r2,-16(fp)
  80333c:	10800217 	ldw	r2,8(r2)
  803340:	e0fff917 	ldw	r3,-28(fp)
  803344:	1885c83a 	sub	r2,r3,r2
  803348:	e0bff915 	stw	r2,-28(fp)
		}

		pxStreamBuffer->xTail = xNextTail;
  80334c:	e0bffc17 	ldw	r2,-16(fp)
  803350:	e0fff917 	ldw	r3,-28(fp)
  803354:	10c00015 	stw	r3,0(r2)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
  803358:	e0bffa17 	ldw	r2,-24(fp)
}
  80335c:	e037883a 	mov	sp,fp
  803360:	dfc00117 	ldw	ra,4(sp)
  803364:	df000017 	ldw	fp,0(sp)
  803368:	dec00204 	addi	sp,sp,8
  80336c:	f800283a 	ret

00803370 <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
  803370:	defffd04 	addi	sp,sp,-12
  803374:	df000215 	stw	fp,8(sp)
  803378:	df000204 	addi	fp,sp,8
  80337c:	e13fff15 	stw	r4,-4(fp)
/* Returns the distance between xTail and xHead. */
size_t xCount;

	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
  803380:	e0bfff17 	ldw	r2,-4(fp)
  803384:	10c00217 	ldw	r3,8(r2)
  803388:	e0bfff17 	ldw	r2,-4(fp)
  80338c:	10800117 	ldw	r2,4(r2)
  803390:	1885883a 	add	r2,r3,r2
  803394:	e0bffe15 	stw	r2,-8(fp)
	xCount -= pxStreamBuffer->xTail;
  803398:	e0bfff17 	ldw	r2,-4(fp)
  80339c:	10800017 	ldw	r2,0(r2)
  8033a0:	e0fffe17 	ldw	r3,-8(fp)
  8033a4:	1885c83a 	sub	r2,r3,r2
  8033a8:	e0bffe15 	stw	r2,-8(fp)
	if ( xCount >= pxStreamBuffer->xLength )
  8033ac:	e0bfff17 	ldw	r2,-4(fp)
  8033b0:	10800217 	ldw	r2,8(r2)
  8033b4:	e0fffe17 	ldw	r3,-8(fp)
  8033b8:	18800536 	bltu	r3,r2,8033d0 <prvBytesInBuffer+0x60>
	{
		xCount -= pxStreamBuffer->xLength;
  8033bc:	e0bfff17 	ldw	r2,-4(fp)
  8033c0:	10800217 	ldw	r2,8(r2)
  8033c4:	e0fffe17 	ldw	r3,-8(fp)
  8033c8:	1885c83a 	sub	r2,r3,r2
  8033cc:	e0bffe15 	stw	r2,-8(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
  8033d0:	e0bffe17 	ldw	r2,-8(fp)
}
  8033d4:	e037883a 	mov	sp,fp
  8033d8:	df000017 	ldw	fp,0(sp)
  8033dc:	dec00104 	addi	sp,sp,4
  8033e0:	f800283a 	ret

008033e4 <prvInitialiseNewStreamBuffer>:
static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
										  uint8_t * const pucBuffer,
										  size_t xBufferSizeBytes,
										  size_t xTriggerLevelBytes,
										  uint8_t ucFlags )
{
  8033e4:	defff904 	addi	sp,sp,-28
  8033e8:	dfc00615 	stw	ra,24(sp)
  8033ec:	df000515 	stw	fp,20(sp)
  8033f0:	df000504 	addi	fp,sp,20
  8033f4:	e13ffb15 	stw	r4,-20(fp)
  8033f8:	e17ffc15 	stw	r5,-16(fp)
  8033fc:	e1bffd15 	stw	r6,-12(fp)
  803400:	e1fffe15 	stw	r7,-8(fp)
  803404:	e0800217 	ldw	r2,8(fp)
  803408:	e0bfff05 	stb	r2,-4(fp)
		const BaseType_t xWriteValue = 0x55;
		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
	} /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
	#endif

	( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
  80340c:	01800804 	movi	r6,32
  803410:	000b883a 	mov	r5,zero
  803414:	e13ffb17 	ldw	r4,-20(fp)
  803418:	08067180 	call	806718 <memset>
	pxStreamBuffer->pucBuffer = pucBuffer;
  80341c:	e0bffb17 	ldw	r2,-20(fp)
  803420:	e0fffc17 	ldw	r3,-16(fp)
  803424:	10c00615 	stw	r3,24(r2)
	pxStreamBuffer->xLength = xBufferSizeBytes;
  803428:	e0bffb17 	ldw	r2,-20(fp)
  80342c:	e0fffd17 	ldw	r3,-12(fp)
  803430:	10c00215 	stw	r3,8(r2)
	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
  803434:	e0bffb17 	ldw	r2,-20(fp)
  803438:	e0fffe17 	ldw	r3,-8(fp)
  80343c:	10c00315 	stw	r3,12(r2)
	pxStreamBuffer->ucFlags = ucFlags;
  803440:	e0bffb17 	ldw	r2,-20(fp)
  803444:	e0ffff03 	ldbu	r3,-4(fp)
  803448:	10c00705 	stb	r3,28(r2)
}
  80344c:	0001883a 	nop
  803450:	e037883a 	mov	sp,fp
  803454:	dfc00117 	ldw	ra,4(sp)
  803458:	df000017 	ldw	fp,0(sp)
  80345c:	dec00204 	addi	sp,sp,8
  803460:	f800283a 	ret

00803464 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
  803464:	defff304 	addi	sp,sp,-52
  803468:	dfc00c15 	stw	ra,48(sp)
  80346c:	df000b15 	stw	fp,44(sp)
  803470:	df000b04 	addi	fp,sp,44
  803474:	e13ffc15 	stw	r4,-16(fp)
  803478:	e17ffd15 	stw	r5,-12(fp)
  80347c:	3005883a 	mov	r2,r6
  803480:	e1ffff15 	stw	r7,-4(fp)
  803484:	e0bffe0d 	sth	r2,-8(fp)
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
  803488:	e0bffe0b 	ldhu	r2,-8(fp)
  80348c:	1085883a 	add	r2,r2,r2
  803490:	1085883a 	add	r2,r2,r2
  803494:	1009883a 	mov	r4,r2
  803498:	080101c0 	call	80101c <pvPortMalloc>
  80349c:	e0bffb15 	stw	r2,-20(fp)

			if( pxStack != NULL )
  8034a0:	e0bffb17 	ldw	r2,-20(fp)
  8034a4:	10000c26 	beq	r2,zero,8034d8 <xTaskCreate+0x74>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
  8034a8:	01001404 	movi	r4,80
  8034ac:	080101c0 	call	80101c <pvPortMalloc>
  8034b0:	e0bff915 	stw	r2,-28(fp)

				if( pxNewTCB != NULL )
  8034b4:	e0bff917 	ldw	r2,-28(fp)
  8034b8:	10000426 	beq	r2,zero,8034cc <xTaskCreate+0x68>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
  8034bc:	e0bff917 	ldw	r2,-28(fp)
  8034c0:	e0fffb17 	ldw	r3,-20(fp)
  8034c4:	10c00c15 	stw	r3,48(r2)
  8034c8:	00000406 	br	8034dc <xTaskCreate+0x78>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
  8034cc:	e13ffb17 	ldw	r4,-20(fp)
  8034d0:	08010dc0 	call	8010dc <vPortFree>
  8034d4:	00000106 	br	8034dc <xTaskCreate+0x78>
				}
			}
			else
			{
				pxNewTCB = NULL;
  8034d8:	e03ff915 	stw	zero,-28(fp)
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
  8034dc:	e0bff917 	ldw	r2,-28(fp)
  8034e0:	10001226 	beq	r2,zero,80352c <xTaskCreate+0xc8>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
  8034e4:	e0fffe0b 	ldhu	r3,-8(fp)
  8034e8:	d8000315 	stw	zero,12(sp)
  8034ec:	e0bff917 	ldw	r2,-28(fp)
  8034f0:	d8800215 	stw	r2,8(sp)
  8034f4:	e0800317 	ldw	r2,12(fp)
  8034f8:	d8800115 	stw	r2,4(sp)
  8034fc:	e0800217 	ldw	r2,8(fp)
  803500:	d8800015 	stw	r2,0(sp)
  803504:	e1ffff17 	ldw	r7,-4(fp)
  803508:	180d883a 	mov	r6,r3
  80350c:	e17ffd17 	ldw	r5,-12(fp)
  803510:	e13ffc17 	ldw	r4,-16(fp)
  803514:	080354c0 	call	80354c <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
  803518:	e13ff917 	ldw	r4,-28(fp)
  80351c:	08037300 	call	803730 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
  803520:	00800044 	movi	r2,1
  803524:	e0bffa15 	stw	r2,-24(fp)
  803528:	00000206 	br	803534 <xTaskCreate+0xd0>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
  80352c:	00bfffc4 	movi	r2,-1
  803530:	e0bffa15 	stw	r2,-24(fp)
		}

		return xReturn;
  803534:	e0bffa17 	ldw	r2,-24(fp)
	}
  803538:	e037883a 	mov	sp,fp
  80353c:	dfc00117 	ldw	ra,4(sp)
  803540:	df000017 	ldw	fp,0(sp)
  803544:	dec00204 	addi	sp,sp,8
  803548:	f800283a 	ret

0080354c <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
  80354c:	defff804 	addi	sp,sp,-32
  803550:	dfc00715 	stw	ra,28(sp)
  803554:	df000615 	stw	fp,24(sp)
  803558:	df000604 	addi	fp,sp,24
  80355c:	e13ffc15 	stw	r4,-16(fp)
  803560:	e17ffd15 	stw	r5,-12(fp)
  803564:	e1bffe15 	stw	r6,-8(fp)
  803568:	e1ffff15 	stw	r7,-4(fp)

	/* Avoid dependency on memset() if it is not required. */
	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
	{
		/* Fill the stack with a known value to assist debugging. */
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
  80356c:	e0800417 	ldw	r2,16(fp)
  803570:	10c00c17 	ldw	r3,48(r2)
  803574:	e0bffe17 	ldw	r2,-8(fp)
  803578:	1085883a 	add	r2,r2,r2
  80357c:	1085883a 	add	r2,r2,r2
  803580:	100d883a 	mov	r6,r2
  803584:	01402944 	movi	r5,165
  803588:	1809883a 	mov	r4,r3
  80358c:	08067180 	call	806718 <memset>
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
  803590:	e0800417 	ldw	r2,16(fp)
  803594:	10c00c17 	ldw	r3,48(r2)
  803598:	e13ffe17 	ldw	r4,-8(fp)
  80359c:	00900034 	movhi	r2,16384
  8035a0:	10bfffc4 	addi	r2,r2,-1
  8035a4:	2085883a 	add	r2,r4,r2
  8035a8:	1085883a 	add	r2,r2,r2
  8035ac:	1085883a 	add	r2,r2,r2
  8035b0:	1885883a 	add	r2,r3,r2
  8035b4:	e0bffb15 	stw	r2,-20(fp)
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
  8035b8:	e0fffb17 	ldw	r3,-20(fp)
  8035bc:	00bfff04 	movi	r2,-4
  8035c0:	1884703a 	and	r2,r3,r2
  8035c4:	e0bffb15 	stw	r2,-20(fp)
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
  8035c8:	e0bffd17 	ldw	r2,-12(fp)
  8035cc:	10001e26 	beq	r2,zero,803648 <prvInitialiseNewTask+0xfc>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
  8035d0:	e03ffa15 	stw	zero,-24(fp)
  8035d4:	00001406 	br	803628 <prvInitialiseNewTask+0xdc>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
  8035d8:	e0fffd17 	ldw	r3,-12(fp)
  8035dc:	e0bffa17 	ldw	r2,-24(fp)
  8035e0:	1885883a 	add	r2,r3,r2
  8035e4:	10c00003 	ldbu	r3,0(r2)
  8035e8:	e1000417 	ldw	r4,16(fp)
  8035ec:	e0bffa17 	ldw	r2,-24(fp)
  8035f0:	2085883a 	add	r2,r4,r2
  8035f4:	10800d04 	addi	r2,r2,52
  8035f8:	10c00005 	stb	r3,0(r2)

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
  8035fc:	e0fffd17 	ldw	r3,-12(fp)
  803600:	e0bffa17 	ldw	r2,-24(fp)
  803604:	1885883a 	add	r2,r3,r2
  803608:	10800003 	ldbu	r2,0(r2)
  80360c:	10803fcc 	andi	r2,r2,255
  803610:	1080201c 	xori	r2,r2,128
  803614:	10bfe004 	addi	r2,r2,-128
  803618:	10000726 	beq	r2,zero,803638 <prvInitialiseNewTask+0xec>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
  80361c:	e0bffa17 	ldw	r2,-24(fp)
  803620:	10800044 	addi	r2,r2,1
  803624:	e0bffa15 	stw	r2,-24(fp)
  803628:	e0bffa17 	ldw	r2,-24(fp)
  80362c:	10800230 	cmpltui	r2,r2,8
  803630:	103fe91e 	bne	r2,zero,8035d8 <__alt_mem_onchip_memory2_0+0xff7835d8>
  803634:	00000106 	br	80363c <prvInitialiseNewTask+0xf0>
			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
			{
				break;
  803638:	0001883a 	nop
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
  80363c:	e0800417 	ldw	r2,16(fp)
  803640:	10000ec5 	stb	zero,59(r2)
  803644:	00000206 	br	803650 <prvInitialiseNewTask+0x104>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
  803648:	e0800417 	ldw	r2,16(fp)
  80364c:	10000d05 	stb	zero,52(r2)
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
  803650:	e0800217 	ldw	r2,8(fp)
  803654:	10800170 	cmpltui	r2,r2,5
  803658:	1000021e 	bne	r2,zero,803664 <prvInitialiseNewTask+0x118>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
  80365c:	00800104 	movi	r2,4
  803660:	e0800215 	stw	r2,8(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
  803664:	e0800417 	ldw	r2,16(fp)
  803668:	e0c00217 	ldw	r3,8(fp)
  80366c:	10c00b15 	stw	r3,44(r2)
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
  803670:	e0800417 	ldw	r2,16(fp)
  803674:	e0c00217 	ldw	r3,8(fp)
  803678:	10c01015 	stw	r3,64(r2)
		pxNewTCB->uxMutexesHeld = 0;
  80367c:	e0800417 	ldw	r2,16(fp)
  803680:	10001115 	stw	zero,68(r2)
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
  803684:	e0800417 	ldw	r2,16(fp)
  803688:	10800104 	addi	r2,r2,4
  80368c:	1009883a 	mov	r4,r2
  803690:	0800a080 	call	800a08 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
  803694:	e0800417 	ldw	r2,16(fp)
  803698:	10800604 	addi	r2,r2,24
  80369c:	1009883a 	mov	r4,r2
  8036a0:	0800a080 	call	800a08 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
  8036a4:	e0800417 	ldw	r2,16(fp)
  8036a8:	e0c00417 	ldw	r3,16(fp)
  8036ac:	10c00415 	stw	r3,16(r2)

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  8036b0:	00c00144 	movi	r3,5
  8036b4:	e0800217 	ldw	r2,8(fp)
  8036b8:	1887c83a 	sub	r3,r3,r2
  8036bc:	e0800417 	ldw	r2,16(fp)
  8036c0:	10c00615 	stw	r3,24(r2)
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
  8036c4:	e0800417 	ldw	r2,16(fp)
  8036c8:	e0c00417 	ldw	r3,16(fp)
  8036cc:	10c00915 	stw	r3,36(r2)

	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
	{
		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
  8036d0:	e0800417 	ldw	r2,16(fp)
  8036d4:	10000f15 	stw	zero,60(r2)
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
  8036d8:	e0800417 	ldw	r2,16(fp)
  8036dc:	10001215 	stw	zero,72(r2)
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
  8036e0:	e0800417 	ldw	r2,16(fp)
  8036e4:	10001305 	stb	zero,76(r2)
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
  8036e8:	e1bfff17 	ldw	r6,-4(fp)
  8036ec:	e17ffc17 	ldw	r5,-16(fp)
  8036f0:	e13ffb17 	ldw	r4,-20(fp)
  8036f4:	0800c5c0 	call	800c5c <pxPortInitialiseStack>
  8036f8:	1007883a 	mov	r3,r2
  8036fc:	e0800417 	ldw	r2,16(fp)
  803700:	10c00015 	stw	r3,0(r2)
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
  803704:	e0800317 	ldw	r2,12(fp)
  803708:	10000326 	beq	r2,zero,803718 <prvInitialiseNewTask+0x1cc>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
  80370c:	e0800317 	ldw	r2,12(fp)
  803710:	e0c00417 	ldw	r3,16(fp)
  803714:	10c00015 	stw	r3,0(r2)
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
  803718:	0001883a 	nop
  80371c:	e037883a 	mov	sp,fp
  803720:	dfc00117 	ldw	ra,4(sp)
  803724:	df000017 	ldw	fp,0(sp)
  803728:	dec00204 	addi	sp,sp,8
  80372c:	f800283a 	ret

00803730 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
  803730:	defffd04 	addi	sp,sp,-12
  803734:	dfc00215 	stw	ra,8(sp)
  803738:	df000115 	stw	fp,4(sp)
  80373c:	df000104 	addi	fp,sp,4
  803740:	e13fff15 	stw	r4,-4(fp)
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
  803744:	0804ff40 	call	804ff4 <vTaskEnterCritical>
	{
		uxCurrentNumberOfTasks++;
  803748:	d0a50917 	ldw	r2,-27612(gp)
  80374c:	10800044 	addi	r2,r2,1
  803750:	d0a50915 	stw	r2,-27612(gp)
		if( pxCurrentTCB == NULL )
  803754:	d0a50517 	ldw	r2,-27628(gp)
  803758:	1000071e 	bne	r2,zero,803778 <prvAddNewTaskToReadyList+0x48>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
  80375c:	e0bfff17 	ldw	r2,-4(fp)
  803760:	d0a50515 	stw	r2,-27628(gp)

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
  803764:	d0a50917 	ldw	r2,-27612(gp)
  803768:	10800058 	cmpnei	r2,r2,1
  80376c:	10000b1e 	bne	r2,zero,80379c <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
  803770:	08049bc0 	call	8049bc <prvInitialiseTaskLists>
  803774:	00000906 	br	80379c <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
  803778:	d0a50c17 	ldw	r2,-27600(gp)
  80377c:	1000071e 	bne	r2,zero,80379c <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
  803780:	d0a50517 	ldw	r2,-27628(gp)
  803784:	10800b17 	ldw	r2,44(r2)
  803788:	e0ffff17 	ldw	r3,-4(fp)
  80378c:	18c00b17 	ldw	r3,44(r3)
  803790:	18800236 	bltu	r3,r2,80379c <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
  803794:	e0bfff17 	ldw	r2,-4(fp)
  803798:	d0a50515 	stw	r2,-27628(gp)
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
  80379c:	d0a51017 	ldw	r2,-27584(gp)
  8037a0:	10800044 	addi	r2,r2,1
  8037a4:	d0a51015 	stw	r2,-27584(gp)
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
  8037a8:	e0bfff17 	ldw	r2,-4(fp)
  8037ac:	10800b17 	ldw	r2,44(r2)
  8037b0:	d0e50b17 	ldw	r3,-27604(gp)
  8037b4:	1880032e 	bgeu	r3,r2,8037c4 <prvAddNewTaskToReadyList+0x94>
  8037b8:	e0bfff17 	ldw	r2,-4(fp)
  8037bc:	10800b17 	ldw	r2,44(r2)
  8037c0:	d0a50b15 	stw	r2,-27604(gp)
  8037c4:	e0bfff17 	ldw	r2,-4(fp)
  8037c8:	10800b17 	ldw	r2,44(r2)
  8037cc:	10c00524 	muli	r3,r2,20
  8037d0:	00802174 	movhi	r2,133
  8037d4:	10a41e04 	addi	r2,r2,-28552
  8037d8:	1887883a 	add	r3,r3,r2
  8037dc:	e0bfff17 	ldw	r2,-4(fp)
  8037e0:	10800104 	addi	r2,r2,4
  8037e4:	100b883a 	mov	r5,r2
  8037e8:	1809883a 	mov	r4,r3
  8037ec:	0800a340 	call	800a34 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
  8037f0:	08050480 	call	805048 <vTaskExitCritical>

	if( xSchedulerRunning != pdFALSE )
  8037f4:	d0a50c17 	ldw	r2,-27600(gp)
  8037f8:	10000626 	beq	r2,zero,803814 <prvAddNewTaskToReadyList+0xe4>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
  8037fc:	d0a50517 	ldw	r2,-27628(gp)
  803800:	10c00b17 	ldw	r3,44(r2)
  803804:	e0bfff17 	ldw	r2,-4(fp)
  803808:	10800b17 	ldw	r2,44(r2)
  80380c:	1880012e 	bgeu	r3,r2,803814 <prvAddNewTaskToReadyList+0xe4>
		{
			taskYIELD_IF_USING_PREEMPTION();
  803810:	003b683a 	trap	0
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
  803814:	0001883a 	nop
  803818:	e037883a 	mov	sp,fp
  80381c:	dfc00117 	ldw	ra,4(sp)
  803820:	df000017 	ldw	fp,0(sp)
  803824:	dec00204 	addi	sp,sp,8
  803828:	f800283a 	ret

0080382c <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
  80382c:	defffc04 	addi	sp,sp,-16
  803830:	dfc00315 	stw	ra,12(sp)
  803834:	df000215 	stw	fp,8(sp)
  803838:	df000204 	addi	fp,sp,8
  80383c:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
  803840:	0804ff40 	call	804ff4 <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
  803844:	e0bfff17 	ldw	r2,-4(fp)
  803848:	1000021e 	bne	r2,zero,803854 <vTaskDelete+0x28>
  80384c:	d0a50517 	ldw	r2,-27628(gp)
  803850:	00000106 	br	803858 <vTaskDelete+0x2c>
  803854:	e0bfff17 	ldw	r2,-4(fp)
  803858:	e0bffe15 	stw	r2,-8(fp)

			/* Remove task from the ready/delayed list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  80385c:	e0bffe17 	ldw	r2,-8(fp)
  803860:	10800104 	addi	r2,r2,4
  803864:	1009883a 	mov	r4,r2
  803868:	0800b980 	call	800b98 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
  80386c:	e0bffe17 	ldw	r2,-8(fp)
  803870:	10800a17 	ldw	r2,40(r2)
  803874:	10000426 	beq	r2,zero,803888 <vTaskDelete+0x5c>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  803878:	e0bffe17 	ldw	r2,-8(fp)
  80387c:	10800604 	addi	r2,r2,24
  803880:	1009883a 	mov	r4,r2
  803884:	0800b980 	call	800b98 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
  803888:	d0a51017 	ldw	r2,-27584(gp)
  80388c:	10800044 	addi	r2,r2,1
  803890:	d0a51015 	stw	r2,-27584(gp)

			if( pxTCB == pxCurrentTCB )
  803894:	d0a50517 	ldw	r2,-27628(gp)
  803898:	e0fffe17 	ldw	r3,-8(fp)
  80389c:	18800a1e 	bne	r3,r2,8038c8 <vTaskDelete+0x9c>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
  8038a0:	e0bffe17 	ldw	r2,-8(fp)
  8038a4:	10800104 	addi	r2,r2,4
  8038a8:	100b883a 	mov	r5,r2
  8038ac:	01002174 	movhi	r4,133
  8038b0:	21244604 	addi	r4,r4,-28392
  8038b4:	0800a340 	call	800a34 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
  8038b8:	d0a50817 	ldw	r2,-27616(gp)
  8038bc:	10800044 	addi	r2,r2,1
  8038c0:	d0a50815 	stw	r2,-27616(gp)
  8038c4:	00000606 	br	8038e0 <vTaskDelete+0xb4>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
  8038c8:	d0a50917 	ldw	r2,-27612(gp)
  8038cc:	10bfffc4 	addi	r2,r2,-1
  8038d0:	d0a50915 	stw	r2,-27612(gp)
				traceTASK_DELETE( pxTCB );
				prvDeleteTCB( pxTCB );
  8038d4:	e13ffe17 	ldw	r4,-8(fp)
  8038d8:	0804bb80 	call	804bb8 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
  8038dc:	0804bfc0 	call	804bfc <prvResetNextTaskUnblockTime>
			}
		}
		taskEXIT_CRITICAL();
  8038e0:	08050480 	call	805048 <vTaskExitCritical>

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
  8038e4:	d0a50c17 	ldw	r2,-27600(gp)
  8038e8:	10000426 	beq	r2,zero,8038fc <vTaskDelete+0xd0>
		{
			if( pxTCB == pxCurrentTCB )
  8038ec:	d0a50517 	ldw	r2,-27628(gp)
  8038f0:	e0fffe17 	ldw	r3,-8(fp)
  8038f4:	1880011e 	bne	r3,r2,8038fc <vTaskDelete+0xd0>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
  8038f8:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
  8038fc:	0001883a 	nop
  803900:	e037883a 	mov	sp,fp
  803904:	dfc00117 	ldw	ra,4(sp)
  803908:	df000017 	ldw	fp,0(sp)
  80390c:	dec00204 	addi	sp,sp,8
  803910:	f800283a 	ret

00803914 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
  803914:	defff804 	addi	sp,sp,-32
  803918:	dfc00715 	stw	ra,28(sp)
  80391c:	df000615 	stw	fp,24(sp)
  803920:	df000604 	addi	fp,sp,24
  803924:	e13ffe15 	stw	r4,-8(fp)
  803928:	e17fff15 	stw	r5,-4(fp)
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
  80392c:	e03ffa15 	stw	zero,-24(fp)

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
  803930:	08040940 	call	804094 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
  803934:	d0a50a17 	ldw	r2,-27608(gp)
  803938:	e0bffb15 	stw	r2,-20(fp)

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
  80393c:	e0bffe17 	ldw	r2,-8(fp)
  803940:	10c00017 	ldw	r3,0(r2)
  803944:	e0bfff17 	ldw	r2,-4(fp)
  803948:	1885883a 	add	r2,r3,r2
  80394c:	e0bffc15 	stw	r2,-16(fp)

			if( xConstTickCount < *pxPreviousWakeTime )
  803950:	e0bffe17 	ldw	r2,-8(fp)
  803954:	10800017 	ldw	r2,0(r2)
  803958:	e0fffb17 	ldw	r3,-20(fp)
  80395c:	18800a2e 	bgeu	r3,r2,803988 <vTaskDelayUntil+0x74>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
  803960:	e0bffe17 	ldw	r2,-8(fp)
  803964:	10800017 	ldw	r2,0(r2)
  803968:	e0fffc17 	ldw	r3,-16(fp)
  80396c:	18800f2e 	bgeu	r3,r2,8039ac <vTaskDelayUntil+0x98>
  803970:	e0bffc17 	ldw	r2,-16(fp)
  803974:	e0fffb17 	ldw	r3,-20(fp)
  803978:	18800c2e 	bgeu	r3,r2,8039ac <vTaskDelayUntil+0x98>
				{
					xShouldDelay = pdTRUE;
  80397c:	00800044 	movi	r2,1
  803980:	e0bffa15 	stw	r2,-24(fp)
  803984:	00000906 	br	8039ac <vTaskDelayUntil+0x98>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
  803988:	e0bffe17 	ldw	r2,-8(fp)
  80398c:	10800017 	ldw	r2,0(r2)
  803990:	e0fffc17 	ldw	r3,-16(fp)
  803994:	18800336 	bltu	r3,r2,8039a4 <vTaskDelayUntil+0x90>
  803998:	e0bffc17 	ldw	r2,-16(fp)
  80399c:	e0fffb17 	ldw	r3,-20(fp)
  8039a0:	1880022e 	bgeu	r3,r2,8039ac <vTaskDelayUntil+0x98>
				{
					xShouldDelay = pdTRUE;
  8039a4:	00800044 	movi	r2,1
  8039a8:	e0bffa15 	stw	r2,-24(fp)
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
  8039ac:	e0bffe17 	ldw	r2,-8(fp)
  8039b0:	e0fffc17 	ldw	r3,-16(fp)
  8039b4:	10c00015 	stw	r3,0(r2)

			if( xShouldDelay != pdFALSE )
  8039b8:	e0bffa17 	ldw	r2,-24(fp)
  8039bc:	10000626 	beq	r2,zero,8039d8 <vTaskDelayUntil+0xc4>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
  8039c0:	e0fffc17 	ldw	r3,-16(fp)
  8039c4:	e0bffb17 	ldw	r2,-20(fp)
  8039c8:	1885c83a 	sub	r2,r3,r2
  8039cc:	000b883a 	mov	r5,zero
  8039d0:	1009883a 	mov	r4,r2
  8039d4:	08058680 	call	805868 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
  8039d8:	08040c00 	call	8040c0 <xTaskResumeAll>
  8039dc:	e0bffd15 	stw	r2,-12(fp)

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
  8039e0:	e0bffd17 	ldw	r2,-12(fp)
  8039e4:	1000011e 	bne	r2,zero,8039ec <vTaskDelayUntil+0xd8>
		{
			portYIELD_WITHIN_API();
  8039e8:	003b683a 	trap	0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  8039ec:	0001883a 	nop
  8039f0:	e037883a 	mov	sp,fp
  8039f4:	dfc00117 	ldw	ra,4(sp)
  8039f8:	df000017 	ldw	fp,0(sp)
  8039fc:	dec00204 	addi	sp,sp,8
  803a00:	f800283a 	ret

00803a04 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
  803a04:	defffc04 	addi	sp,sp,-16
  803a08:	dfc00315 	stw	ra,12(sp)
  803a0c:	df000215 	stw	fp,8(sp)
  803a10:	df000204 	addi	fp,sp,8
  803a14:	e13fff15 	stw	r4,-4(fp)
	BaseType_t xAlreadyYielded = pdFALSE;
  803a18:	e03ffe15 	stw	zero,-8(fp)

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
  803a1c:	e0bfff17 	ldw	r2,-4(fp)
  803a20:	10000626 	beq	r2,zero,803a3c <vTaskDelay+0x38>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
  803a24:	08040940 	call	804094 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
  803a28:	000b883a 	mov	r5,zero
  803a2c:	e13fff17 	ldw	r4,-4(fp)
  803a30:	08058680 	call	805868 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
  803a34:	08040c00 	call	8040c0 <xTaskResumeAll>
  803a38:	e0bffe15 	stw	r2,-8(fp)
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
  803a3c:	e0bffe17 	ldw	r2,-8(fp)
  803a40:	1000011e 	bne	r2,zero,803a48 <vTaskDelay+0x44>
		{
			portYIELD_WITHIN_API();
  803a44:	003b683a 	trap	0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  803a48:	0001883a 	nop
  803a4c:	e037883a 	mov	sp,fp
  803a50:	dfc00117 	ldw	ra,4(sp)
  803a54:	df000017 	ldw	fp,0(sp)
  803a58:	dec00204 	addi	sp,sp,8
  803a5c:	f800283a 	ret

00803a60 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
	{
  803a60:	defffb04 	addi	sp,sp,-20
  803a64:	dfc00415 	stw	ra,16(sp)
  803a68:	df000315 	stw	fp,12(sp)
  803a6c:	df000304 	addi	fp,sp,12
  803a70:	e13fff15 	stw	r4,-4(fp)
	TCB_t const *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
  803a74:	0804ff40 	call	804ff4 <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the priority of the task
			that called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
  803a78:	e0bfff17 	ldw	r2,-4(fp)
  803a7c:	1000021e 	bne	r2,zero,803a88 <uxTaskPriorityGet+0x28>
  803a80:	d0a50517 	ldw	r2,-27628(gp)
  803a84:	00000106 	br	803a8c <uxTaskPriorityGet+0x2c>
  803a88:	e0bfff17 	ldw	r2,-4(fp)
  803a8c:	e0bffd15 	stw	r2,-12(fp)
			uxReturn = pxTCB->uxPriority;
  803a90:	e0bffd17 	ldw	r2,-12(fp)
  803a94:	10800b17 	ldw	r2,44(r2)
  803a98:	e0bffe15 	stw	r2,-8(fp)
		}
		taskEXIT_CRITICAL();
  803a9c:	08050480 	call	805048 <vTaskExitCritical>

		return uxReturn;
  803aa0:	e0bffe17 	ldw	r2,-8(fp)
	}
  803aa4:	e037883a 	mov	sp,fp
  803aa8:	dfc00117 	ldw	ra,4(sp)
  803aac:	df000017 	ldw	fp,0(sp)
  803ab0:	dec00204 	addi	sp,sp,8
  803ab4:	f800283a 	ret

00803ab8 <uxTaskPriorityGetFromISR>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
	{
  803ab8:	defffb04 	addi	sp,sp,-20
  803abc:	df000415 	stw	fp,16(sp)
  803ac0:	df000404 	addi	fp,sp,16
  803ac4:	e13fff15 	stw	r4,-4(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
  803ac8:	e03ffc15 	stw	zero,-16(fp)
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
  803acc:	e0bfff17 	ldw	r2,-4(fp)
  803ad0:	1000021e 	bne	r2,zero,803adc <uxTaskPriorityGetFromISR+0x24>
  803ad4:	d0a50517 	ldw	r2,-27628(gp)
  803ad8:	00000106 	br	803ae0 <uxTaskPriorityGetFromISR+0x28>
  803adc:	e0bfff17 	ldw	r2,-4(fp)
  803ae0:	e0bffd15 	stw	r2,-12(fp)
			uxReturn = pxTCB->uxPriority;
  803ae4:	e0bffd17 	ldw	r2,-12(fp)
  803ae8:	10800b17 	ldw	r2,44(r2)
  803aec:	e0bffe15 	stw	r2,-8(fp)
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

		return uxReturn;
  803af0:	e0bffe17 	ldw	r2,-8(fp)
	}
  803af4:	e037883a 	mov	sp,fp
  803af8:	df000017 	ldw	fp,0(sp)
  803afc:	dec00104 	addi	sp,sp,4
  803b00:	f800283a 	ret

00803b04 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
  803b04:	defff804 	addi	sp,sp,-32
  803b08:	dfc00715 	stw	ra,28(sp)
  803b0c:	df000615 	stw	fp,24(sp)
  803b10:	df000604 	addi	fp,sp,24
  803b14:	e13ffe15 	stw	r4,-8(fp)
  803b18:	e17fff15 	stw	r5,-4(fp)
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
  803b1c:	e03ffa15 	stw	zero,-24(fp)

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
  803b20:	e0bfff17 	ldw	r2,-4(fp)
  803b24:	10800170 	cmpltui	r2,r2,5
  803b28:	1000021e 	bne	r2,zero,803b34 <vTaskPrioritySet+0x30>
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
  803b2c:	00800104 	movi	r2,4
  803b30:	e0bfff15 	stw	r2,-4(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
  803b34:	0804ff40 	call	804ff4 <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
  803b38:	e0bffe17 	ldw	r2,-8(fp)
  803b3c:	1000021e 	bne	r2,zero,803b48 <vTaskPrioritySet+0x44>
  803b40:	d0a50517 	ldw	r2,-27628(gp)
  803b44:	00000106 	br	803b4c <vTaskPrioritySet+0x48>
  803b48:	e0bffe17 	ldw	r2,-8(fp)
  803b4c:	e0bffb15 	stw	r2,-20(fp)

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
  803b50:	e0bffb17 	ldw	r2,-20(fp)
  803b54:	10801017 	ldw	r2,64(r2)
  803b58:	e0bffc15 	stw	r2,-16(fp)
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
  803b5c:	e0fffc17 	ldw	r3,-16(fp)
  803b60:	e0bfff17 	ldw	r2,-4(fp)
  803b64:	18804926 	beq	r3,r2,803c8c <vTaskPrioritySet+0x188>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
  803b68:	e0bfff17 	ldw	r2,-4(fp)
  803b6c:	e0fffc17 	ldw	r3,-16(fp)
  803b70:	18800a2e 	bgeu	r3,r2,803b9c <vTaskPrioritySet+0x98>
				{
					if( pxTCB != pxCurrentTCB )
  803b74:	d0a50517 	ldw	r2,-27628(gp)
  803b78:	e0fffb17 	ldw	r3,-20(fp)
  803b7c:	18800c26 	beq	r3,r2,803bb0 <vTaskPrioritySet+0xac>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
  803b80:	d0a50517 	ldw	r2,-27628(gp)
  803b84:	10800b17 	ldw	r2,44(r2)
  803b88:	e0ffff17 	ldw	r3,-4(fp)
  803b8c:	18800836 	bltu	r3,r2,803bb0 <vTaskPrioritySet+0xac>
						{
							xYieldRequired = pdTRUE;
  803b90:	00800044 	movi	r2,1
  803b94:	e0bffa15 	stw	r2,-24(fp)
  803b98:	00000506 	br	803bb0 <vTaskPrioritySet+0xac>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
  803b9c:	d0a50517 	ldw	r2,-27628(gp)
  803ba0:	e0fffb17 	ldw	r3,-20(fp)
  803ba4:	1880021e 	bne	r3,r2,803bb0 <vTaskPrioritySet+0xac>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
  803ba8:	00800044 	movi	r2,1
  803bac:	e0bffa15 	stw	r2,-24(fp)
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
  803bb0:	e0bffb17 	ldw	r2,-20(fp)
  803bb4:	10800b17 	ldw	r2,44(r2)
  803bb8:	e0bffd15 	stw	r2,-12(fp)

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
  803bbc:	e0bffb17 	ldw	r2,-20(fp)
  803bc0:	10c01017 	ldw	r3,64(r2)
  803bc4:	e0bffb17 	ldw	r2,-20(fp)
  803bc8:	10800b17 	ldw	r2,44(r2)
  803bcc:	1880031e 	bne	r3,r2,803bdc <vTaskPrioritySet+0xd8>
					{
						pxTCB->uxPriority = uxNewPriority;
  803bd0:	e0bffb17 	ldw	r2,-20(fp)
  803bd4:	e0ffff17 	ldw	r3,-4(fp)
  803bd8:	10c00b15 	stw	r3,44(r2)
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
  803bdc:	e0bffb17 	ldw	r2,-20(fp)
  803be0:	e0ffff17 	ldw	r3,-4(fp)
  803be4:	10c01015 	stw	r3,64(r2)
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
  803be8:	e0bffb17 	ldw	r2,-20(fp)
  803bec:	10800617 	ldw	r2,24(r2)
  803bf0:	10000516 	blt	r2,zero,803c08 <vTaskPrioritySet+0x104>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  803bf4:	00c00144 	movi	r3,5
  803bf8:	e0bfff17 	ldw	r2,-4(fp)
  803bfc:	1887c83a 	sub	r3,r3,r2
  803c00:	e0bffb17 	ldw	r2,-20(fp)
  803c04:	10c00615 	stw	r3,24(r2)

				/* If the task is in the blocked or suspended list we need do
				nothing more than change its priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
  803c08:	e0bffb17 	ldw	r2,-20(fp)
  803c0c:	10c00517 	ldw	r3,20(r2)
  803c10:	e0bffd17 	ldw	r2,-12(fp)
  803c14:	11000524 	muli	r4,r2,20
  803c18:	00802174 	movhi	r2,133
  803c1c:	10a41e04 	addi	r2,r2,-28552
  803c20:	2085883a 	add	r2,r4,r2
  803c24:	1880161e 	bne	r3,r2,803c80 <vTaskPrioritySet+0x17c>
				{
					/* The task is currently in its ready list - remove before
					adding it to it's new ready list.  As we are in a critical
					section we can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  803c28:	e0bffb17 	ldw	r2,-20(fp)
  803c2c:	10800104 	addi	r2,r2,4
  803c30:	1009883a 	mov	r4,r2
  803c34:	0800b980 	call	800b98 <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
  803c38:	e0bffb17 	ldw	r2,-20(fp)
  803c3c:	10800b17 	ldw	r2,44(r2)
  803c40:	d0e50b17 	ldw	r3,-27604(gp)
  803c44:	1880032e 	bgeu	r3,r2,803c54 <vTaskPrioritySet+0x150>
  803c48:	e0bffb17 	ldw	r2,-20(fp)
  803c4c:	10800b17 	ldw	r2,44(r2)
  803c50:	d0a50b15 	stw	r2,-27604(gp)
  803c54:	e0bffb17 	ldw	r2,-20(fp)
  803c58:	10800b17 	ldw	r2,44(r2)
  803c5c:	10c00524 	muli	r3,r2,20
  803c60:	00802174 	movhi	r2,133
  803c64:	10a41e04 	addi	r2,r2,-28552
  803c68:	1887883a 	add	r3,r3,r2
  803c6c:	e0bffb17 	ldw	r2,-20(fp)
  803c70:	10800104 	addi	r2,r2,4
  803c74:	100b883a 	mov	r5,r2
  803c78:	1809883a 	mov	r4,r3
  803c7c:	0800a340 	call	800a34 <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired != pdFALSE )
  803c80:	e0bffa17 	ldw	r2,-24(fp)
  803c84:	10000126 	beq	r2,zero,803c8c <vTaskPrioritySet+0x188>
				{
					taskYIELD_IF_USING_PREEMPTION();
  803c88:	003b683a 	trap	0
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
  803c8c:	08050480 	call	805048 <vTaskExitCritical>
	}
  803c90:	0001883a 	nop
  803c94:	e037883a 	mov	sp,fp
  803c98:	dfc00117 	ldw	ra,4(sp)
  803c9c:	df000017 	ldw	fp,0(sp)
  803ca0:	dec00204 	addi	sp,sp,8
  803ca4:	f800283a 	ret

00803ca8 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
  803ca8:	defffc04 	addi	sp,sp,-16
  803cac:	dfc00315 	stw	ra,12(sp)
  803cb0:	df000215 	stw	fp,8(sp)
  803cb4:	df000204 	addi	fp,sp,8
  803cb8:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
  803cbc:	0804ff40 	call	804ff4 <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
  803cc0:	e0bfff17 	ldw	r2,-4(fp)
  803cc4:	1000021e 	bne	r2,zero,803cd0 <vTaskSuspend+0x28>
  803cc8:	d0a50517 	ldw	r2,-27628(gp)
  803ccc:	00000106 	br	803cd4 <vTaskSuspend+0x2c>
  803cd0:	e0bfff17 	ldw	r2,-4(fp)
  803cd4:	e0bffe15 	stw	r2,-8(fp)

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  803cd8:	e0bffe17 	ldw	r2,-8(fp)
  803cdc:	10800104 	addi	r2,r2,4
  803ce0:	1009883a 	mov	r4,r2
  803ce4:	0800b980 	call	800b98 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
  803ce8:	e0bffe17 	ldw	r2,-8(fp)
  803cec:	10800a17 	ldw	r2,40(r2)
  803cf0:	10000426 	beq	r2,zero,803d04 <vTaskSuspend+0x5c>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  803cf4:	e0bffe17 	ldw	r2,-8(fp)
  803cf8:	10800604 	addi	r2,r2,24
  803cfc:	1009883a 	mov	r4,r2
  803d00:	0800b980 	call	800b98 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
  803d04:	e0bffe17 	ldw	r2,-8(fp)
  803d08:	10800104 	addi	r2,r2,4
  803d0c:	100b883a 	mov	r5,r2
  803d10:	01002174 	movhi	r4,133
  803d14:	21244b04 	addi	r4,r4,-28372
  803d18:	0800a340 	call	800a34 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
  803d1c:	e0bffe17 	ldw	r2,-8(fp)
  803d20:	10801303 	ldbu	r2,76(r2)
  803d24:	10803fcc 	andi	r2,r2,255
  803d28:	10800058 	cmpnei	r2,r2,1
  803d2c:	1000021e 	bne	r2,zero,803d38 <vTaskSuspend+0x90>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
  803d30:	e0bffe17 	ldw	r2,-8(fp)
  803d34:	10001305 	stb	zero,76(r2)
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
  803d38:	08050480 	call	805048 <vTaskExitCritical>

		if( xSchedulerRunning != pdFALSE )
  803d3c:	d0a50c17 	ldw	r2,-27600(gp)
  803d40:	10000326 	beq	r2,zero,803d50 <vTaskSuspend+0xa8>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
  803d44:	0804ff40 	call	804ff4 <vTaskEnterCritical>
			{
				prvResetNextTaskUnblockTime();
  803d48:	0804bfc0 	call	804bfc <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
  803d4c:	08050480 	call	805048 <vTaskExitCritical>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
  803d50:	d0a50517 	ldw	r2,-27628(gp)
  803d54:	e0fffe17 	ldw	r3,-8(fp)
  803d58:	18800c1e 	bne	r3,r2,803d8c <vTaskSuspend+0xe4>
		{
			if( xSchedulerRunning != pdFALSE )
  803d5c:	d0a50c17 	ldw	r2,-27600(gp)
  803d60:	10000226 	beq	r2,zero,803d6c <vTaskSuspend+0xc4>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
  803d64:	003b683a 	trap	0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  803d68:	00000806 	br	803d8c <vTaskSuspend+0xe4>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
  803d6c:	00802174 	movhi	r2,133
  803d70:	10a44b04 	addi	r2,r2,-28372
  803d74:	10c00017 	ldw	r3,0(r2)
  803d78:	d0a50917 	ldw	r2,-27612(gp)
  803d7c:	1880021e 	bne	r3,r2,803d88 <vTaskSuspend+0xe0>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
  803d80:	d0250515 	stw	zero,-27628(gp)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  803d84:	00000106 	br	803d8c <vTaskSuspend+0xe4>
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
  803d88:	08044c80 	call	8044c8 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  803d8c:	0001883a 	nop
  803d90:	e037883a 	mov	sp,fp
  803d94:	dfc00117 	ldw	ra,4(sp)
  803d98:	df000017 	ldw	fp,0(sp)
  803d9c:	dec00204 	addi	sp,sp,8
  803da0:	f800283a 	ret

00803da4 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
  803da4:	defffc04 	addi	sp,sp,-16
  803da8:	df000315 	stw	fp,12(sp)
  803dac:	df000304 	addi	fp,sp,12
  803db0:	e13fff15 	stw	r4,-4(fp)
	BaseType_t xReturn = pdFALSE;
  803db4:	e03ffd15 	stw	zero,-12(fp)
	const TCB_t * const pxTCB = xTask;
  803db8:	e0bfff17 	ldw	r2,-4(fp)
  803dbc:	e0bffe15 	stw	r2,-8(fp)

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
  803dc0:	e0bffe17 	ldw	r2,-8(fp)
  803dc4:	10c00517 	ldw	r3,20(r2)
  803dc8:	00802174 	movhi	r2,133
  803dcc:	10a44b04 	addi	r2,r2,-28372
  803dd0:	18800a1e 	bne	r3,r2,803dfc <prvTaskIsTaskSuspended+0x58>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
  803dd4:	e0bffe17 	ldw	r2,-8(fp)
  803dd8:	10c00a17 	ldw	r3,40(r2)
  803ddc:	00802174 	movhi	r2,133
  803de0:	10a44104 	addi	r2,r2,-28412
  803de4:	18800526 	beq	r3,r2,803dfc <prvTaskIsTaskSuspended+0x58>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
  803de8:	e0bffe17 	ldw	r2,-8(fp)
  803dec:	10800a17 	ldw	r2,40(r2)
  803df0:	1000021e 	bne	r2,zero,803dfc <prvTaskIsTaskSuspended+0x58>
				{
					xReturn = pdTRUE;
  803df4:	00800044 	movi	r2,1
  803df8:	e0bffd15 	stw	r2,-12(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
  803dfc:	e0bffd17 	ldw	r2,-12(fp)
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
  803e00:	e037883a 	mov	sp,fp
  803e04:	df000017 	ldw	fp,0(sp)
  803e08:	dec00104 	addi	sp,sp,4
  803e0c:	f800283a 	ret

00803e10 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
  803e10:	defffc04 	addi	sp,sp,-16
  803e14:	dfc00315 	stw	ra,12(sp)
  803e18:	df000215 	stw	fp,8(sp)
  803e1c:	df000204 	addi	fp,sp,8
  803e20:	e13fff15 	stw	r4,-4(fp)
	TCB_t * const pxTCB = xTaskToResume;
  803e24:	e0bfff17 	ldw	r2,-4(fp)
  803e28:	e0bffe15 	stw	r2,-8(fp)
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
  803e2c:	d0a50517 	ldw	r2,-27628(gp)
  803e30:	e0fffe17 	ldw	r3,-8(fp)
  803e34:	18802326 	beq	r3,r2,803ec4 <vTaskResume+0xb4>
  803e38:	e0bffe17 	ldw	r2,-8(fp)
  803e3c:	10002126 	beq	r2,zero,803ec4 <vTaskResume+0xb4>
		{
			taskENTER_CRITICAL();
  803e40:	0804ff40 	call	804ff4 <vTaskEnterCritical>
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
  803e44:	e13ffe17 	ldw	r4,-8(fp)
  803e48:	0803da40 	call	803da4 <prvTaskIsTaskSuspended>
  803e4c:	10001c26 	beq	r2,zero,803ec0 <vTaskResume+0xb0>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
  803e50:	e0bffe17 	ldw	r2,-8(fp)
  803e54:	10800104 	addi	r2,r2,4
  803e58:	1009883a 	mov	r4,r2
  803e5c:	0800b980 	call	800b98 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
  803e60:	e0bffe17 	ldw	r2,-8(fp)
  803e64:	10800b17 	ldw	r2,44(r2)
  803e68:	d0e50b17 	ldw	r3,-27604(gp)
  803e6c:	1880032e 	bgeu	r3,r2,803e7c <vTaskResume+0x6c>
  803e70:	e0bffe17 	ldw	r2,-8(fp)
  803e74:	10800b17 	ldw	r2,44(r2)
  803e78:	d0a50b15 	stw	r2,-27604(gp)
  803e7c:	e0bffe17 	ldw	r2,-8(fp)
  803e80:	10800b17 	ldw	r2,44(r2)
  803e84:	10c00524 	muli	r3,r2,20
  803e88:	00802174 	movhi	r2,133
  803e8c:	10a41e04 	addi	r2,r2,-28552
  803e90:	1887883a 	add	r3,r3,r2
  803e94:	e0bffe17 	ldw	r2,-8(fp)
  803e98:	10800104 	addi	r2,r2,4
  803e9c:	100b883a 	mov	r5,r2
  803ea0:	1809883a 	mov	r4,r3
  803ea4:	0800a340 	call	800a34 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  803ea8:	e0bffe17 	ldw	r2,-8(fp)
  803eac:	10c00b17 	ldw	r3,44(r2)
  803eb0:	d0a50517 	ldw	r2,-27628(gp)
  803eb4:	10800b17 	ldw	r2,44(r2)
  803eb8:	18800136 	bltu	r3,r2,803ec0 <vTaskResume+0xb0>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
  803ebc:	003b683a 	trap	0
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
  803ec0:	08050480 	call	805048 <vTaskExitCritical>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  803ec4:	0001883a 	nop
  803ec8:	e037883a 	mov	sp,fp
  803ecc:	dfc00117 	ldw	ra,4(sp)
  803ed0:	df000017 	ldw	fp,0(sp)
  803ed4:	dec00204 	addi	sp,sp,8
  803ed8:	f800283a 	ret

00803edc <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
  803edc:	defffa04 	addi	sp,sp,-24
  803ee0:	dfc00515 	stw	ra,20(sp)
  803ee4:	df000415 	stw	fp,16(sp)
  803ee8:	df000404 	addi	fp,sp,16
  803eec:	e13fff15 	stw	r4,-4(fp)
	BaseType_t xYieldRequired = pdFALSE;
  803ef0:	e03ffc15 	stw	zero,-16(fp)
	TCB_t * const pxTCB = xTaskToResume;
  803ef4:	e0bfff17 	ldw	r2,-4(fp)
  803ef8:	e0bffd15 	stw	r2,-12(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  803efc:	e03ffe15 	stw	zero,-8(fp)
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
  803f00:	e13ffd17 	ldw	r4,-12(fp)
  803f04:	0803da40 	call	803da4 <prvTaskIsTaskSuspended>
  803f08:	10002626 	beq	r2,zero,803fa4 <xTaskResumeFromISR+0xc8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  803f0c:	d0a51317 	ldw	r2,-27572(gp)
  803f10:	10001e1e 	bne	r2,zero,803f8c <xTaskResumeFromISR+0xb0>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  803f14:	e0bffd17 	ldw	r2,-12(fp)
  803f18:	10c00b17 	ldw	r3,44(r2)
  803f1c:	d0a50517 	ldw	r2,-27628(gp)
  803f20:	10800b17 	ldw	r2,44(r2)
  803f24:	18800236 	bltu	r3,r2,803f30 <xTaskResumeFromISR+0x54>
					{
						xYieldRequired = pdTRUE;
  803f28:	00800044 	movi	r2,1
  803f2c:	e0bffc15 	stw	r2,-16(fp)
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  803f30:	e0bffd17 	ldw	r2,-12(fp)
  803f34:	10800104 	addi	r2,r2,4
  803f38:	1009883a 	mov	r4,r2
  803f3c:	0800b980 	call	800b98 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
  803f40:	e0bffd17 	ldw	r2,-12(fp)
  803f44:	10800b17 	ldw	r2,44(r2)
  803f48:	d0e50b17 	ldw	r3,-27604(gp)
  803f4c:	1880032e 	bgeu	r3,r2,803f5c <xTaskResumeFromISR+0x80>
  803f50:	e0bffd17 	ldw	r2,-12(fp)
  803f54:	10800b17 	ldw	r2,44(r2)
  803f58:	d0a50b15 	stw	r2,-27604(gp)
  803f5c:	e0bffd17 	ldw	r2,-12(fp)
  803f60:	10800b17 	ldw	r2,44(r2)
  803f64:	10c00524 	muli	r3,r2,20
  803f68:	00802174 	movhi	r2,133
  803f6c:	10a41e04 	addi	r2,r2,-28552
  803f70:	1887883a 	add	r3,r3,r2
  803f74:	e0bffd17 	ldw	r2,-12(fp)
  803f78:	10800104 	addi	r2,r2,4
  803f7c:	100b883a 	mov	r5,r2
  803f80:	1809883a 	mov	r4,r3
  803f84:	0800a340 	call	800a34 <vListInsertEnd>
  803f88:	00000606 	br	803fa4 <xTaskResumeFromISR+0xc8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
  803f8c:	e0bffd17 	ldw	r2,-12(fp)
  803f90:	10800604 	addi	r2,r2,24
  803f94:	100b883a 	mov	r5,r2
  803f98:	01002174 	movhi	r4,133
  803f9c:	21244104 	addi	r4,r4,-28412
  803fa0:	0800a340 	call	800a34 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
  803fa4:	e0bffc17 	ldw	r2,-16(fp)
	}
  803fa8:	e037883a 	mov	sp,fp
  803fac:	dfc00117 	ldw	ra,4(sp)
  803fb0:	df000017 	ldw	fp,0(sp)
  803fb4:	dec00204 	addi	sp,sp,8
  803fb8:	f800283a 	ret

00803fbc <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
  803fbc:	defffa04 	addi	sp,sp,-24
  803fc0:	dfc00515 	stw	ra,20(sp)
  803fc4:	df000415 	stw	fp,16(sp)
  803fc8:	df000404 	addi	fp,sp,16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
  803fcc:	d0a51204 	addi	r2,gp,-27576
  803fd0:	d8800115 	stw	r2,4(sp)
  803fd4:	d8000015 	stw	zero,0(sp)
  803fd8:	000f883a 	mov	r7,zero
  803fdc:	01810004 	movi	r6,1024
  803fe0:	01402074 	movhi	r5,129
  803fe4:	29659304 	addi	r5,r5,-27060
  803fe8:	01002034 	movhi	r4,128
  803fec:	21126804 	addi	r4,r4,18848
  803ff0:	08034640 	call	803464 <xTaskCreate>
  803ff4:	e0bffe15 	stw	r2,-8(fp)
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
  803ff8:	e0bffe17 	ldw	r2,-8(fp)
  803ffc:	10800058 	cmpnei	r2,r2,1
  804000:	10000c1e 	bne	r2,zero,804034 <vTaskStartScheduler+0x78>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  804004:	0005303a 	rdctl	r2,status
  804008:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  80400c:	e0ffff17 	ldw	r3,-4(fp)
  804010:	00bfff84 	movi	r2,-2
  804014:	1884703a 	and	r2,r3,r2
  804018:	1001703a 	wrctl	status,r2
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
  80401c:	00bfffc4 	movi	r2,-1
  804020:	d0a51115 	stw	r2,-27580(gp)
		xSchedulerRunning = pdTRUE;
  804024:	00800044 	movi	r2,1
  804028:	d0a50c15 	stw	r2,-27600(gp)
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  80402c:	d0250a15 	stw	zero,-27608(gp)

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
  804030:	0800d3c0 	call	800d3c <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
  804034:	0001883a 	nop
  804038:	e037883a 	mov	sp,fp
  80403c:	dfc00117 	ldw	ra,4(sp)
  804040:	df000017 	ldw	fp,0(sp)
  804044:	dec00204 	addi	sp,sp,8
  804048:	f800283a 	ret

0080404c <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
  80404c:	defffd04 	addi	sp,sp,-12
  804050:	dfc00215 	stw	ra,8(sp)
  804054:	df000115 	stw	fp,4(sp)
  804058:	df000104 	addi	fp,sp,4
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  80405c:	0005303a 	rdctl	r2,status
  804060:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  804064:	e0ffff17 	ldw	r3,-4(fp)
  804068:	00bfff84 	movi	r2,-2
  80406c:	1884703a 	and	r2,r3,r2
  804070:	1001703a 	wrctl	status,r2
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
	xSchedulerRunning = pdFALSE;
  804074:	d0250c15 	stw	zero,-27600(gp)
	vPortEndScheduler();
  804078:	0800d740 	call	800d74 <vPortEndScheduler>
}
  80407c:	0001883a 	nop
  804080:	e037883a 	mov	sp,fp
  804084:	dfc00117 	ldw	ra,4(sp)
  804088:	df000017 	ldw	fp,0(sp)
  80408c:	dec00204 	addi	sp,sp,8
  804090:	f800283a 	ret

00804094 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
  804094:	deffff04 	addi	sp,sp,-4
  804098:	df000015 	stw	fp,0(sp)
  80409c:	d839883a 	mov	fp,sp
	do not otherwise exhibit real time behaviour. */
	portSOFTWARE_BARRIER();

	/* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
	is used to allow calls to vTaskSuspendAll() to nest. */
	++uxSchedulerSuspended;
  8040a0:	d0a51317 	ldw	r2,-27572(gp)
  8040a4:	10800044 	addi	r2,r2,1
  8040a8:	d0a51315 	stw	r2,-27572(gp)

	/* Enforces ordering for ports and optimised compilers that may otherwise place
	the above increment elsewhere. */
	portMEMORY_BARRIER();
}
  8040ac:	0001883a 	nop
  8040b0:	e037883a 	mov	sp,fp
  8040b4:	df000017 	ldw	fp,0(sp)
  8040b8:	dec00104 	addi	sp,sp,4
  8040bc:	f800283a 	ret

008040c0 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
  8040c0:	defffb04 	addi	sp,sp,-20
  8040c4:	dfc00415 	stw	ra,16(sp)
  8040c8:	df000315 	stw	fp,12(sp)
  8040cc:	df000304 	addi	fp,sp,12
TCB_t *pxTCB = NULL;
  8040d0:	e03ffd15 	stw	zero,-12(fp)
BaseType_t xAlreadyYielded = pdFALSE;
  8040d4:	e03ffe15 	stw	zero,-8(fp)
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
  8040d8:	0804ff40 	call	804ff4 <vTaskEnterCritical>
	{
		--uxSchedulerSuspended;
  8040dc:	d0a51317 	ldw	r2,-27572(gp)
  8040e0:	10bfffc4 	addi	r2,r2,-1
  8040e4:	d0a51315 	stw	r2,-27572(gp)

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  8040e8:	d0a51317 	ldw	r2,-27572(gp)
  8040ec:	1000431e 	bne	r2,zero,8041fc <xTaskResumeAll+0x13c>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
  8040f0:	d0a50917 	ldw	r2,-27612(gp)
  8040f4:	10004126 	beq	r2,zero,8041fc <xTaskResumeAll+0x13c>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
  8040f8:	00002606 	br	804194 <xTaskResumeAll+0xd4>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  8040fc:	00802174 	movhi	r2,133
  804100:	10a44104 	addi	r2,r2,-28412
  804104:	10800317 	ldw	r2,12(r2)
  804108:	10800317 	ldw	r2,12(r2)
  80410c:	e0bffd15 	stw	r2,-12(fp)
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  804110:	e0bffd17 	ldw	r2,-12(fp)
  804114:	10800604 	addi	r2,r2,24
  804118:	1009883a 	mov	r4,r2
  80411c:	0800b980 	call	800b98 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  804120:	e0bffd17 	ldw	r2,-12(fp)
  804124:	10800104 	addi	r2,r2,4
  804128:	1009883a 	mov	r4,r2
  80412c:	0800b980 	call	800b98 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
  804130:	e0bffd17 	ldw	r2,-12(fp)
  804134:	10800b17 	ldw	r2,44(r2)
  804138:	d0e50b17 	ldw	r3,-27604(gp)
  80413c:	1880032e 	bgeu	r3,r2,80414c <xTaskResumeAll+0x8c>
  804140:	e0bffd17 	ldw	r2,-12(fp)
  804144:	10800b17 	ldw	r2,44(r2)
  804148:	d0a50b15 	stw	r2,-27604(gp)
  80414c:	e0bffd17 	ldw	r2,-12(fp)
  804150:	10800b17 	ldw	r2,44(r2)
  804154:	10c00524 	muli	r3,r2,20
  804158:	00802174 	movhi	r2,133
  80415c:	10a41e04 	addi	r2,r2,-28552
  804160:	1887883a 	add	r3,r3,r2
  804164:	e0bffd17 	ldw	r2,-12(fp)
  804168:	10800104 	addi	r2,r2,4
  80416c:	100b883a 	mov	r5,r2
  804170:	1809883a 	mov	r4,r3
  804174:	0800a340 	call	800a34 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  804178:	e0bffd17 	ldw	r2,-12(fp)
  80417c:	10c00b17 	ldw	r3,44(r2)
  804180:	d0a50517 	ldw	r2,-27628(gp)
  804184:	10800b17 	ldw	r2,44(r2)
  804188:	18800236 	bltu	r3,r2,804194 <xTaskResumeAll+0xd4>
					{
						xYieldPending = pdTRUE;
  80418c:	00800044 	movi	r2,1
  804190:	d0a50e15 	stw	r2,-27592(gp)
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
  804194:	00802174 	movhi	r2,133
  804198:	10a44104 	addi	r2,r2,-28412
  80419c:	10800017 	ldw	r2,0(r2)
  8041a0:	103fd61e 	bne	r2,zero,8040fc <__alt_mem_onchip_memory2_0+0xff7840fc>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
  8041a4:	e0bffd17 	ldw	r2,-12(fp)
  8041a8:	10000126 	beq	r2,zero,8041b0 <xTaskResumeAll+0xf0>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
  8041ac:	0804bfc0 	call	804bfc <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
  8041b0:	d0a50d17 	ldw	r2,-27596(gp)
  8041b4:	e0bfff15 	stw	r2,-4(fp)

					if( xPendedCounts > ( TickType_t ) 0U )
  8041b8:	e0bfff17 	ldw	r2,-4(fp)
  8041bc:	10000a26 	beq	r2,zero,8041e8 <xTaskResumeAll+0x128>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
  8041c0:	08043180 	call	804318 <xTaskIncrementTick>
  8041c4:	10000226 	beq	r2,zero,8041d0 <xTaskResumeAll+0x110>
							{
								xYieldPending = pdTRUE;
  8041c8:	00800044 	movi	r2,1
  8041cc:	d0a50e15 	stw	r2,-27592(gp)
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--xPendedCounts;
  8041d0:	e0bfff17 	ldw	r2,-4(fp)
  8041d4:	10bfffc4 	addi	r2,r2,-1
  8041d8:	e0bfff15 	stw	r2,-4(fp)
						} while( xPendedCounts > ( TickType_t ) 0U );
  8041dc:	e0bfff17 	ldw	r2,-4(fp)
  8041e0:	103ff71e 	bne	r2,zero,8041c0 <__alt_mem_onchip_memory2_0+0xff7841c0>

						xPendedTicks = 0;
  8041e4:	d0250d15 	stw	zero,-27596(gp)
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
  8041e8:	d0a50e17 	ldw	r2,-27592(gp)
  8041ec:	10000326 	beq	r2,zero,8041fc <xTaskResumeAll+0x13c>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
  8041f0:	00800044 	movi	r2,1
  8041f4:	e0bffe15 	stw	r2,-8(fp)
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
  8041f8:	003b683a 	trap	0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
  8041fc:	08050480 	call	805048 <vTaskExitCritical>

	return xAlreadyYielded;
  804200:	e0bffe17 	ldw	r2,-8(fp)
}
  804204:	e037883a 	mov	sp,fp
  804208:	dfc00117 	ldw	ra,4(sp)
  80420c:	df000017 	ldw	fp,0(sp)
  804210:	dec00204 	addi	sp,sp,8
  804214:	f800283a 	ret

00804218 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
  804218:	defffe04 	addi	sp,sp,-8
  80421c:	df000115 	stw	fp,4(sp)
  804220:	df000104 	addi	fp,sp,4
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
	{
		xTicks = xTickCount;
  804224:	d0a50a17 	ldw	r2,-27608(gp)
  804228:	e0bfff15 	stw	r2,-4(fp)
	}
	portTICK_TYPE_EXIT_CRITICAL();

	return xTicks;
  80422c:	e0bfff17 	ldw	r2,-4(fp)
}
  804230:	e037883a 	mov	sp,fp
  804234:	df000017 	ldw	fp,0(sp)
  804238:	dec00104 	addi	sp,sp,4
  80423c:	f800283a 	ret

00804240 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
  804240:	defffd04 	addi	sp,sp,-12
  804244:	df000215 	stw	fp,8(sp)
  804248:	df000204 	addi	fp,sp,8
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
  80424c:	e03ffe15 	stw	zero,-8(fp)
	{
		xReturn = xTickCount;
  804250:	d0a50a17 	ldw	r2,-27608(gp)
  804254:	e0bfff15 	stw	r2,-4(fp)
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
  804258:	e0bfff17 	ldw	r2,-4(fp)
}
  80425c:	e037883a 	mov	sp,fp
  804260:	df000017 	ldw	fp,0(sp)
  804264:	dec00104 	addi	sp,sp,4
  804268:	f800283a 	ret

0080426c <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
  80426c:	deffff04 	addi	sp,sp,-4
  804270:	df000015 	stw	fp,0(sp)
  804274:	d839883a 	mov	fp,sp
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
  804278:	d0a50917 	ldw	r2,-27612(gp)
}
  80427c:	e037883a 	mov	sp,fp
  804280:	df000017 	ldw	fp,0(sp)
  804284:	dec00104 	addi	sp,sp,4
  804288:	f800283a 	ret

0080428c <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
  80428c:	defffd04 	addi	sp,sp,-12
  804290:	df000215 	stw	fp,8(sp)
  804294:	df000204 	addi	fp,sp,8
  804298:	e13fff15 	stw	r4,-4(fp)
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
  80429c:	e0bfff17 	ldw	r2,-4(fp)
  8042a0:	1000021e 	bne	r2,zero,8042ac <pcTaskGetName+0x20>
  8042a4:	d0a50517 	ldw	r2,-27628(gp)
  8042a8:	00000106 	br	8042b0 <pcTaskGetName+0x24>
  8042ac:	e0bfff17 	ldw	r2,-4(fp)
  8042b0:	e0bffe15 	stw	r2,-8(fp)
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
  8042b4:	e0bffe17 	ldw	r2,-8(fp)
  8042b8:	10800d04 	addi	r2,r2,52
}
  8042bc:	e037883a 	mov	sp,fp
  8042c0:	df000017 	ldw	fp,0(sp)
  8042c4:	dec00104 	addi	sp,sp,4
  8042c8:	f800283a 	ret

008042cc <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
  8042cc:	defffc04 	addi	sp,sp,-16
  8042d0:	dfc00315 	stw	ra,12(sp)
  8042d4:	df000215 	stw	fp,8(sp)
  8042d8:	df000204 	addi	fp,sp,8
  8042dc:	e13fff15 	stw	r4,-4(fp)
BaseType_t xYieldRequired = pdFALSE;
  8042e0:	e03ffe15 	stw	zero,-8(fp)
	relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
	configASSERT( uxSchedulerSuspended == 0 );

	/* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
	the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
	vTaskSuspendAll();
  8042e4:	08040940 	call	804094 <vTaskSuspendAll>
	xPendedTicks += xTicksToCatchUp;
  8042e8:	d0e50d17 	ldw	r3,-27596(gp)
  8042ec:	e0bfff17 	ldw	r2,-4(fp)
  8042f0:	1885883a 	add	r2,r3,r2
  8042f4:	d0a50d15 	stw	r2,-27596(gp)
	xYieldRequired = xTaskResumeAll();
  8042f8:	08040c00 	call	8040c0 <xTaskResumeAll>
  8042fc:	e0bffe15 	stw	r2,-8(fp)

	return xYieldRequired;
  804300:	e0bffe17 	ldw	r2,-8(fp)
}
  804304:	e037883a 	mov	sp,fp
  804308:	dfc00117 	ldw	ra,4(sp)
  80430c:	df000017 	ldw	fp,0(sp)
  804310:	dec00204 	addi	sp,sp,8
  804314:	f800283a 	ret

00804318 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
  804318:	defff904 	addi	sp,sp,-28
  80431c:	dfc00615 	stw	ra,24(sp)
  804320:	df000515 	stw	fp,20(sp)
  804324:	df000504 	addi	fp,sp,20
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
  804328:	e03ffb15 	stw	zero,-20(fp)

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  80432c:	d0a51317 	ldw	r2,-27572(gp)
  804330:	10005c1e 	bne	r2,zero,8044a4 <xTaskIncrementTick+0x18c>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
  804334:	d0a50a17 	ldw	r2,-27608(gp)
  804338:	10800044 	addi	r2,r2,1
  80433c:	e0bffc15 	stw	r2,-16(fp)

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
  804340:	e0bffc17 	ldw	r2,-16(fp)
  804344:	d0a50a15 	stw	r2,-27608(gp)

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
  804348:	e0bffc17 	ldw	r2,-16(fp)
  80434c:	10000a1e 	bne	r2,zero,804378 <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
  804350:	d0a50617 	ldw	r2,-27624(gp)
  804354:	e0bffd15 	stw	r2,-12(fp)
  804358:	d0a50717 	ldw	r2,-27620(gp)
  80435c:	d0a50615 	stw	r2,-27624(gp)
  804360:	e0bffd17 	ldw	r2,-12(fp)
  804364:	d0a50715 	stw	r2,-27620(gp)
  804368:	d0a50f17 	ldw	r2,-27588(gp)
  80436c:	10800044 	addi	r2,r2,1
  804370:	d0a50f15 	stw	r2,-27588(gp)
  804374:	0804bfc0 	call	804bfc <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
  804378:	d0a51117 	ldw	r2,-27580(gp)
  80437c:	e0fffc17 	ldw	r3,-16(fp)
  804380:	18803836 	bltu	r3,r2,804464 <xTaskIncrementTick+0x14c>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  804384:	d0a50617 	ldw	r2,-27624(gp)
  804388:	10800017 	ldw	r2,0(r2)
  80438c:	1000031e 	bne	r2,zero,80439c <xTaskIncrementTick+0x84>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  804390:	00bfffc4 	movi	r2,-1
  804394:	d0a51115 	stw	r2,-27580(gp)
					break;
  804398:	00003206 	br	804464 <xTaskIncrementTick+0x14c>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  80439c:	d0a50617 	ldw	r2,-27624(gp)
  8043a0:	10800317 	ldw	r2,12(r2)
  8043a4:	10800317 	ldw	r2,12(r2)
  8043a8:	e0bffe15 	stw	r2,-8(fp)
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
  8043ac:	e0bffe17 	ldw	r2,-8(fp)
  8043b0:	10800117 	ldw	r2,4(r2)
  8043b4:	e0bfff15 	stw	r2,-4(fp)

					if( xConstTickCount < xItemValue )
  8043b8:	e0fffc17 	ldw	r3,-16(fp)
  8043bc:	e0bfff17 	ldw	r2,-4(fp)
  8043c0:	1880032e 	bgeu	r3,r2,8043d0 <xTaskIncrementTick+0xb8>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
  8043c4:	e0bfff17 	ldw	r2,-4(fp)
  8043c8:	d0a51115 	stw	r2,-27580(gp)
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
  8043cc:	00002506 	br	804464 <xTaskIncrementTick+0x14c>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  8043d0:	e0bffe17 	ldw	r2,-8(fp)
  8043d4:	10800104 	addi	r2,r2,4
  8043d8:	1009883a 	mov	r4,r2
  8043dc:	0800b980 	call	800b98 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
  8043e0:	e0bffe17 	ldw	r2,-8(fp)
  8043e4:	10800a17 	ldw	r2,40(r2)
  8043e8:	10000426 	beq	r2,zero,8043fc <xTaskIncrementTick+0xe4>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  8043ec:	e0bffe17 	ldw	r2,-8(fp)
  8043f0:	10800604 	addi	r2,r2,24
  8043f4:	1009883a 	mov	r4,r2
  8043f8:	0800b980 	call	800b98 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
  8043fc:	e0bffe17 	ldw	r2,-8(fp)
  804400:	10800b17 	ldw	r2,44(r2)
  804404:	d0e50b17 	ldw	r3,-27604(gp)
  804408:	1880032e 	bgeu	r3,r2,804418 <xTaskIncrementTick+0x100>
  80440c:	e0bffe17 	ldw	r2,-8(fp)
  804410:	10800b17 	ldw	r2,44(r2)
  804414:	d0a50b15 	stw	r2,-27604(gp)
  804418:	e0bffe17 	ldw	r2,-8(fp)
  80441c:	10800b17 	ldw	r2,44(r2)
  804420:	10c00524 	muli	r3,r2,20
  804424:	00802174 	movhi	r2,133
  804428:	10a41e04 	addi	r2,r2,-28552
  80442c:	1887883a 	add	r3,r3,r2
  804430:	e0bffe17 	ldw	r2,-8(fp)
  804434:	10800104 	addi	r2,r2,4
  804438:	100b883a 	mov	r5,r2
  80443c:	1809883a 	mov	r4,r3
  804440:	0800a340 	call	800a34 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  804444:	e0bffe17 	ldw	r2,-8(fp)
  804448:	10c00b17 	ldw	r3,44(r2)
  80444c:	d0a50517 	ldw	r2,-27628(gp)
  804450:	10800b17 	ldw	r2,44(r2)
  804454:	18bfcb36 	bltu	r3,r2,804384 <__alt_mem_onchip_memory2_0+0xff784384>
						{
							xSwitchRequired = pdTRUE;
  804458:	00800044 	movi	r2,1
  80445c:	e0bffb15 	stw	r2,-20(fp)
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_PREEMPTION */
				}
			}
  804460:	003fc806 	br	804384 <__alt_mem_onchip_memory2_0+0xff784384>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
  804464:	d0a50517 	ldw	r2,-27628(gp)
  804468:	10c00b17 	ldw	r3,44(r2)
  80446c:	00802174 	movhi	r2,133
  804470:	10a41e04 	addi	r2,r2,-28552
  804474:	18c00524 	muli	r3,r3,20
  804478:	10c5883a 	add	r2,r2,r3
  80447c:	10800017 	ldw	r2,0(r2)
  804480:	108000b0 	cmpltui	r2,r2,2
  804484:	1000021e 	bne	r2,zero,804490 <xTaskIncrementTick+0x178>
			{
				xSwitchRequired = pdTRUE;
  804488:	00800044 	movi	r2,1
  80448c:	e0bffb15 	stw	r2,-20(fp)
		}
		#endif /* configUSE_TICK_HOOK */

		#if ( configUSE_PREEMPTION == 1 )
		{
			if( xYieldPending != pdFALSE )
  804490:	d0a50e17 	ldw	r2,-27592(gp)
  804494:	10000626 	beq	r2,zero,8044b0 <xTaskIncrementTick+0x198>
			{
				xSwitchRequired = pdTRUE;
  804498:	00800044 	movi	r2,1
  80449c:	e0bffb15 	stw	r2,-20(fp)
  8044a0:	00000306 	br	8044b0 <xTaskIncrementTick+0x198>
		}
		#endif /* configUSE_PREEMPTION */
	}
	else
	{
		++xPendedTicks;
  8044a4:	d0a50d17 	ldw	r2,-27596(gp)
  8044a8:	10800044 	addi	r2,r2,1
  8044ac:	d0a50d15 	stw	r2,-27596(gp)
			vApplicationTickHook();
		}
		#endif
	}

	return xSwitchRequired;
  8044b0:	e0bffb17 	ldw	r2,-20(fp)
}
  8044b4:	e037883a 	mov	sp,fp
  8044b8:	dfc00117 	ldw	ra,4(sp)
  8044bc:	df000017 	ldw	fp,0(sp)
  8044c0:	dec00204 	addi	sp,sp,8
  8044c4:	f800283a 	ret

008044c8 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
  8044c8:	defffd04 	addi	sp,sp,-12
  8044cc:	df000215 	stw	fp,8(sp)
  8044d0:	df000204 	addi	fp,sp,8
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
  8044d4:	d0a51317 	ldw	r2,-27572(gp)
  8044d8:	10000326 	beq	r2,zero,8044e8 <vTaskSwitchContext+0x20>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
  8044dc:	00800044 	movi	r2,1
  8044e0:	d0a50e15 	stw	r2,-27592(gp)
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
  8044e4:	00002906 	br	80458c <vTaskSwitchContext+0xc4>
		switch. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xYieldPending = pdFALSE;
  8044e8:	d0250e15 	stw	zero,-27592(gp)
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  8044ec:	d0a50b17 	ldw	r2,-27604(gp)
  8044f0:	e0bffe15 	stw	r2,-8(fp)
  8044f4:	00000306 	br	804504 <vTaskSwitchContext+0x3c>
  8044f8:	e0bffe17 	ldw	r2,-8(fp)
  8044fc:	10bfffc4 	addi	r2,r2,-1
  804500:	e0bffe15 	stw	r2,-8(fp)
  804504:	00802174 	movhi	r2,133
  804508:	10a41e04 	addi	r2,r2,-28552
  80450c:	e0fffe17 	ldw	r3,-8(fp)
  804510:	18c00524 	muli	r3,r3,20
  804514:	10c5883a 	add	r2,r2,r3
  804518:	10800017 	ldw	r2,0(r2)
  80451c:	103ff626 	beq	r2,zero,8044f8 <__alt_mem_onchip_memory2_0+0xff7844f8>
  804520:	e0bffe17 	ldw	r2,-8(fp)
  804524:	10c00524 	muli	r3,r2,20
  804528:	00802174 	movhi	r2,133
  80452c:	10a41e04 	addi	r2,r2,-28552
  804530:	1885883a 	add	r2,r3,r2
  804534:	e0bfff15 	stw	r2,-4(fp)
  804538:	e0bfff17 	ldw	r2,-4(fp)
  80453c:	10800117 	ldw	r2,4(r2)
  804540:	10c00117 	ldw	r3,4(r2)
  804544:	e0bfff17 	ldw	r2,-4(fp)
  804548:	10c00115 	stw	r3,4(r2)
  80454c:	e0bfff17 	ldw	r2,-4(fp)
  804550:	10c00117 	ldw	r3,4(r2)
  804554:	e0bfff17 	ldw	r2,-4(fp)
  804558:	10800204 	addi	r2,r2,8
  80455c:	1880051e 	bne	r3,r2,804574 <vTaskSwitchContext+0xac>
  804560:	e0bfff17 	ldw	r2,-4(fp)
  804564:	10800117 	ldw	r2,4(r2)
  804568:	10c00117 	ldw	r3,4(r2)
  80456c:	e0bfff17 	ldw	r2,-4(fp)
  804570:	10c00115 	stw	r3,4(r2)
  804574:	e0bfff17 	ldw	r2,-4(fp)
  804578:	10800117 	ldw	r2,4(r2)
  80457c:	10800317 	ldw	r2,12(r2)
  804580:	d0a50515 	stw	r2,-27628(gp)
  804584:	e0bffe17 	ldw	r2,-8(fp)
  804588:	d0a50b15 	stw	r2,-27604(gp)
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
  80458c:	0001883a 	nop
  804590:	e037883a 	mov	sp,fp
  804594:	df000017 	ldw	fp,0(sp)
  804598:	dec00104 	addi	sp,sp,4
  80459c:	f800283a 	ret

008045a0 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
  8045a0:	defffc04 	addi	sp,sp,-16
  8045a4:	dfc00315 	stw	ra,12(sp)
  8045a8:	df000215 	stw	fp,8(sp)
  8045ac:	df000204 	addi	fp,sp,8
  8045b0:	e13ffe15 	stw	r4,-8(fp)
  8045b4:	e17fff15 	stw	r5,-4(fp)

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
  8045b8:	d0a50517 	ldw	r2,-27628(gp)
  8045bc:	10800604 	addi	r2,r2,24
  8045c0:	100b883a 	mov	r5,r2
  8045c4:	e13ffe17 	ldw	r4,-8(fp)
  8045c8:	0800ac00 	call	800ac0 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
  8045cc:	01400044 	movi	r5,1
  8045d0:	e13fff17 	ldw	r4,-4(fp)
  8045d4:	08058680 	call	805868 <prvAddCurrentTaskToDelayedList>
}
  8045d8:	0001883a 	nop
  8045dc:	e037883a 	mov	sp,fp
  8045e0:	dfc00117 	ldw	ra,4(sp)
  8045e4:	df000017 	ldw	fp,0(sp)
  8045e8:	dec00204 	addi	sp,sp,8
  8045ec:	f800283a 	ret

008045f0 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
  8045f0:	defffb04 	addi	sp,sp,-20
  8045f4:	dfc00415 	stw	ra,16(sp)
  8045f8:	df000315 	stw	fp,12(sp)
  8045fc:	df000304 	addi	fp,sp,12
  804600:	e13ffd15 	stw	r4,-12(fp)
  804604:	e17ffe15 	stw	r5,-8(fp)
  804608:	e1bfff15 	stw	r6,-4(fp)
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
  80460c:	d0a50517 	ldw	r2,-27628(gp)
  804610:	e0fffe17 	ldw	r3,-8(fp)
  804614:	18e00034 	orhi	r3,r3,32768
  804618:	10c00615 	stw	r3,24(r2)
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
  80461c:	d0a50517 	ldw	r2,-27628(gp)
  804620:	10800604 	addi	r2,r2,24
  804624:	100b883a 	mov	r5,r2
  804628:	e13ffd17 	ldw	r4,-12(fp)
  80462c:	0800a340 	call	800a34 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
  804630:	01400044 	movi	r5,1
  804634:	e13fff17 	ldw	r4,-4(fp)
  804638:	08058680 	call	805868 <prvAddCurrentTaskToDelayedList>
}
  80463c:	0001883a 	nop
  804640:	e037883a 	mov	sp,fp
  804644:	dfc00117 	ldw	ra,4(sp)
  804648:	df000017 	ldw	fp,0(sp)
  80464c:	dec00204 	addi	sp,sp,8
  804650:	f800283a 	ret

00804654 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
  804654:	defffb04 	addi	sp,sp,-20
  804658:	dfc00415 	stw	ra,16(sp)
  80465c:	df000315 	stw	fp,12(sp)
  804660:	df000304 	addi	fp,sp,12
  804664:	e13fff15 	stw	r4,-4(fp)
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  804668:	e0bfff17 	ldw	r2,-4(fp)
  80466c:	10800317 	ldw	r2,12(r2)
  804670:	10800317 	ldw	r2,12(r2)
  804674:	e0bffe15 	stw	r2,-8(fp)
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
  804678:	e0bffe17 	ldw	r2,-8(fp)
  80467c:	10800604 	addi	r2,r2,24
  804680:	1009883a 	mov	r4,r2
  804684:	0800b980 	call	800b98 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  804688:	d0a51317 	ldw	r2,-27572(gp)
  80468c:	1000171e 	bne	r2,zero,8046ec <xTaskRemoveFromEventList+0x98>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
  804690:	e0bffe17 	ldw	r2,-8(fp)
  804694:	10800104 	addi	r2,r2,4
  804698:	1009883a 	mov	r4,r2
  80469c:	0800b980 	call	800b98 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
  8046a0:	e0bffe17 	ldw	r2,-8(fp)
  8046a4:	10800b17 	ldw	r2,44(r2)
  8046a8:	d0e50b17 	ldw	r3,-27604(gp)
  8046ac:	1880032e 	bgeu	r3,r2,8046bc <xTaskRemoveFromEventList+0x68>
  8046b0:	e0bffe17 	ldw	r2,-8(fp)
  8046b4:	10800b17 	ldw	r2,44(r2)
  8046b8:	d0a50b15 	stw	r2,-27604(gp)
  8046bc:	e0bffe17 	ldw	r2,-8(fp)
  8046c0:	10800b17 	ldw	r2,44(r2)
  8046c4:	10c00524 	muli	r3,r2,20
  8046c8:	00802174 	movhi	r2,133
  8046cc:	10a41e04 	addi	r2,r2,-28552
  8046d0:	1887883a 	add	r3,r3,r2
  8046d4:	e0bffe17 	ldw	r2,-8(fp)
  8046d8:	10800104 	addi	r2,r2,4
  8046dc:	100b883a 	mov	r5,r2
  8046e0:	1809883a 	mov	r4,r3
  8046e4:	0800a340 	call	800a34 <vListInsertEnd>
  8046e8:	00000606 	br	804704 <xTaskRemoveFromEventList+0xb0>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
  8046ec:	e0bffe17 	ldw	r2,-8(fp)
  8046f0:	10800604 	addi	r2,r2,24
  8046f4:	100b883a 	mov	r5,r2
  8046f8:	01002174 	movhi	r4,133
  8046fc:	21244104 	addi	r4,r4,-28412
  804700:	0800a340 	call	800a34 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
  804704:	e0bffe17 	ldw	r2,-8(fp)
  804708:	10800b17 	ldw	r2,44(r2)
  80470c:	d0e50517 	ldw	r3,-27628(gp)
  804710:	18c00b17 	ldw	r3,44(r3)
  804714:	1880052e 	bgeu	r3,r2,80472c <xTaskRemoveFromEventList+0xd8>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
  804718:	00800044 	movi	r2,1
  80471c:	e0bffd15 	stw	r2,-12(fp)

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
  804720:	00800044 	movi	r2,1
  804724:	d0a50e15 	stw	r2,-27592(gp)
  804728:	00000106 	br	804730 <xTaskRemoveFromEventList+0xdc>
	}
	else
	{
		xReturn = pdFALSE;
  80472c:	e03ffd15 	stw	zero,-12(fp)
	}

	return xReturn;
  804730:	e0bffd17 	ldw	r2,-12(fp)
}
  804734:	e037883a 	mov	sp,fp
  804738:	dfc00117 	ldw	ra,4(sp)
  80473c:	df000017 	ldw	fp,0(sp)
  804740:	dec00204 	addi	sp,sp,8
  804744:	f800283a 	ret

00804748 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
  804748:	defffb04 	addi	sp,sp,-20
  80474c:	dfc00415 	stw	ra,16(sp)
  804750:	df000315 	stw	fp,12(sp)
  804754:	df000304 	addi	fp,sp,12
  804758:	e13ffe15 	stw	r4,-8(fp)
  80475c:	e17fff15 	stw	r5,-4(fp)
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
  804760:	e0bfff17 	ldw	r2,-4(fp)
  804764:	10e00034 	orhi	r3,r2,32768
  804768:	e0bffe17 	ldw	r2,-8(fp)
  80476c:	10c00015 	stw	r3,0(r2)

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  804770:	e0bffe17 	ldw	r2,-8(fp)
  804774:	10800317 	ldw	r2,12(r2)
  804778:	e0bffd15 	stw	r2,-12(fp)
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
  80477c:	e13ffe17 	ldw	r4,-8(fp)
  804780:	0800b980 	call	800b98 <uxListRemove>
	#endif

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
  804784:	e0bffd17 	ldw	r2,-12(fp)
  804788:	10800104 	addi	r2,r2,4
  80478c:	1009883a 	mov	r4,r2
  804790:	0800b980 	call	800b98 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
  804794:	e0bffd17 	ldw	r2,-12(fp)
  804798:	10800b17 	ldw	r2,44(r2)
  80479c:	d0e50b17 	ldw	r3,-27604(gp)
  8047a0:	1880032e 	bgeu	r3,r2,8047b0 <vTaskRemoveFromUnorderedEventList+0x68>
  8047a4:	e0bffd17 	ldw	r2,-12(fp)
  8047a8:	10800b17 	ldw	r2,44(r2)
  8047ac:	d0a50b15 	stw	r2,-27604(gp)
  8047b0:	e0bffd17 	ldw	r2,-12(fp)
  8047b4:	10800b17 	ldw	r2,44(r2)
  8047b8:	10c00524 	muli	r3,r2,20
  8047bc:	00802174 	movhi	r2,133
  8047c0:	10a41e04 	addi	r2,r2,-28552
  8047c4:	1887883a 	add	r3,r3,r2
  8047c8:	e0bffd17 	ldw	r2,-12(fp)
  8047cc:	10800104 	addi	r2,r2,4
  8047d0:	100b883a 	mov	r5,r2
  8047d4:	1809883a 	mov	r4,r3
  8047d8:	0800a340 	call	800a34 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
  8047dc:	e0bffd17 	ldw	r2,-12(fp)
  8047e0:	10800b17 	ldw	r2,44(r2)
  8047e4:	d0e50517 	ldw	r3,-27628(gp)
  8047e8:	18c00b17 	ldw	r3,44(r3)
  8047ec:	1880022e 	bgeu	r3,r2,8047f8 <vTaskRemoveFromUnorderedEventList+0xb0>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
  8047f0:	00800044 	movi	r2,1
  8047f4:	d0a50e15 	stw	r2,-27592(gp)
	}
}
  8047f8:	0001883a 	nop
  8047fc:	e037883a 	mov	sp,fp
  804800:	dfc00117 	ldw	ra,4(sp)
  804804:	df000017 	ldw	fp,0(sp)
  804808:	dec00204 	addi	sp,sp,8
  80480c:	f800283a 	ret

00804810 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
  804810:	defffd04 	addi	sp,sp,-12
  804814:	dfc00215 	stw	ra,8(sp)
  804818:	df000115 	stw	fp,4(sp)
  80481c:	df000104 	addi	fp,sp,4
  804820:	e13fff15 	stw	r4,-4(fp)
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
  804824:	0804ff40 	call	804ff4 <vTaskEnterCritical>
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
  804828:	d0e50f17 	ldw	r3,-27588(gp)
  80482c:	e0bfff17 	ldw	r2,-4(fp)
  804830:	10c00015 	stw	r3,0(r2)
		pxTimeOut->xTimeOnEntering = xTickCount;
  804834:	d0e50a17 	ldw	r3,-27608(gp)
  804838:	e0bfff17 	ldw	r2,-4(fp)
  80483c:	10c00115 	stw	r3,4(r2)
	}
	taskEXIT_CRITICAL();
  804840:	08050480 	call	805048 <vTaskExitCritical>
}
  804844:	0001883a 	nop
  804848:	e037883a 	mov	sp,fp
  80484c:	dfc00117 	ldw	ra,4(sp)
  804850:	df000017 	ldw	fp,0(sp)
  804854:	dec00204 	addi	sp,sp,8
  804858:	f800283a 	ret

0080485c <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
  80485c:	defffe04 	addi	sp,sp,-8
  804860:	df000115 	stw	fp,4(sp)
  804864:	df000104 	addi	fp,sp,4
  804868:	e13fff15 	stw	r4,-4(fp)
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
  80486c:	d0e50f17 	ldw	r3,-27588(gp)
  804870:	e0bfff17 	ldw	r2,-4(fp)
  804874:	10c00015 	stw	r3,0(r2)
	pxTimeOut->xTimeOnEntering = xTickCount;
  804878:	d0e50a17 	ldw	r3,-27608(gp)
  80487c:	e0bfff17 	ldw	r2,-4(fp)
  804880:	10c00115 	stw	r3,4(r2)
}
  804884:	0001883a 	nop
  804888:	e037883a 	mov	sp,fp
  80488c:	df000017 	ldw	fp,0(sp)
  804890:	dec00104 	addi	sp,sp,4
  804894:	f800283a 	ret

00804898 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
  804898:	defff904 	addi	sp,sp,-28
  80489c:	dfc00615 	stw	ra,24(sp)
  8048a0:	df000515 	stw	fp,20(sp)
  8048a4:	df000504 	addi	fp,sp,20
  8048a8:	e13ffe15 	stw	r4,-8(fp)
  8048ac:	e17fff15 	stw	r5,-4(fp)
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
  8048b0:	0804ff40 	call	804ff4 <vTaskEnterCritical>
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
  8048b4:	d0a50a17 	ldw	r2,-27608(gp)
  8048b8:	e0bffc15 	stw	r2,-16(fp)
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
  8048bc:	e0bffe17 	ldw	r2,-8(fp)
  8048c0:	10800117 	ldw	r2,4(r2)
  8048c4:	e0fffc17 	ldw	r3,-16(fp)
  8048c8:	1885c83a 	sub	r2,r3,r2
  8048cc:	e0bffd15 	stw	r2,-12(fp)
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
  8048d0:	e0bfff17 	ldw	r2,-4(fp)
  8048d4:	10800017 	ldw	r2,0(r2)
  8048d8:	10bfffd8 	cmpnei	r2,r2,-1
  8048dc:	1000021e 	bne	r2,zero,8048e8 <xTaskCheckForTimeOut+0x50>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
  8048e0:	e03ffb15 	stw	zero,-20(fp)
  8048e4:	00001d06 	br	80495c <xTaskCheckForTimeOut+0xc4>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
  8048e8:	e0bffe17 	ldw	r2,-8(fp)
  8048ec:	10c00017 	ldw	r3,0(r2)
  8048f0:	d0a50f17 	ldw	r2,-27588(gp)
  8048f4:	18800726 	beq	r3,r2,804914 <xTaskCheckForTimeOut+0x7c>
  8048f8:	e0bffe17 	ldw	r2,-8(fp)
  8048fc:	10800117 	ldw	r2,4(r2)
  804900:	e0fffc17 	ldw	r3,-16(fp)
  804904:	18800336 	bltu	r3,r2,804914 <xTaskCheckForTimeOut+0x7c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
  804908:	00800044 	movi	r2,1
  80490c:	e0bffb15 	stw	r2,-20(fp)
  804910:	00001206 	br	80495c <xTaskCheckForTimeOut+0xc4>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
  804914:	e0bfff17 	ldw	r2,-4(fp)
  804918:	10800017 	ldw	r2,0(r2)
  80491c:	e0fffd17 	ldw	r3,-12(fp)
  804920:	18800a2e 	bgeu	r3,r2,80494c <xTaskCheckForTimeOut+0xb4>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
  804924:	e0bfff17 	ldw	r2,-4(fp)
  804928:	10c00017 	ldw	r3,0(r2)
  80492c:	e0bffd17 	ldw	r2,-12(fp)
  804930:	1887c83a 	sub	r3,r3,r2
  804934:	e0bfff17 	ldw	r2,-4(fp)
  804938:	10c00015 	stw	r3,0(r2)
			vTaskInternalSetTimeOutState( pxTimeOut );
  80493c:	e13ffe17 	ldw	r4,-8(fp)
  804940:	080485c0 	call	80485c <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
  804944:	e03ffb15 	stw	zero,-20(fp)
  804948:	00000406 	br	80495c <xTaskCheckForTimeOut+0xc4>
		}
		else
		{
			*pxTicksToWait = 0;
  80494c:	e0bfff17 	ldw	r2,-4(fp)
  804950:	10000015 	stw	zero,0(r2)
			xReturn = pdTRUE;
  804954:	00800044 	movi	r2,1
  804958:	e0bffb15 	stw	r2,-20(fp)
		}
	}
	taskEXIT_CRITICAL();
  80495c:	08050480 	call	805048 <vTaskExitCritical>

	return xReturn;
  804960:	e0bffb17 	ldw	r2,-20(fp)
}
  804964:	e037883a 	mov	sp,fp
  804968:	dfc00117 	ldw	ra,4(sp)
  80496c:	df000017 	ldw	fp,0(sp)
  804970:	dec00204 	addi	sp,sp,8
  804974:	f800283a 	ret

00804978 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
  804978:	deffff04 	addi	sp,sp,-4
  80497c:	df000015 	stw	fp,0(sp)
  804980:	d839883a 	mov	fp,sp
	xYieldPending = pdTRUE;
  804984:	00800044 	movi	r2,1
  804988:	d0a50e15 	stw	r2,-27592(gp)
}
  80498c:	0001883a 	nop
  804990:	e037883a 	mov	sp,fp
  804994:	df000017 	ldw	fp,0(sp)
  804998:	dec00104 	addi	sp,sp,4
  80499c:	f800283a 	ret

008049a0 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
  8049a0:	defffd04 	addi	sp,sp,-12
  8049a4:	dfc00215 	stw	ra,8(sp)
  8049a8:	df000115 	stw	fp,4(sp)
  8049ac:	df000104 	addi	fp,sp,4
  8049b0:	e13fff15 	stw	r4,-4(fp)

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
  8049b4:	0804a740 	call	804a74 <prvCheckTasksWaitingTermination>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
  8049b8:	003ffe06 	br	8049b4 <__alt_mem_onchip_memory2_0+0xff7849b4>

008049bc <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
  8049bc:	defffd04 	addi	sp,sp,-12
  8049c0:	dfc00215 	stw	ra,8(sp)
  8049c4:	df000115 	stw	fp,4(sp)
  8049c8:	df000104 	addi	fp,sp,4
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
  8049cc:	e03fff15 	stw	zero,-4(fp)
  8049d0:	00000a06 	br	8049fc <prvInitialiseTaskLists+0x40>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
  8049d4:	e0bfff17 	ldw	r2,-4(fp)
  8049d8:	10c00524 	muli	r3,r2,20
  8049dc:	00802174 	movhi	r2,133
  8049e0:	10a41e04 	addi	r2,r2,-28552
  8049e4:	1885883a 	add	r2,r3,r2
  8049e8:	1009883a 	mov	r4,r2
  8049ec:	08009a00 	call	8009a0 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
  8049f0:	e0bfff17 	ldw	r2,-4(fp)
  8049f4:	10800044 	addi	r2,r2,1
  8049f8:	e0bfff15 	stw	r2,-4(fp)
  8049fc:	e0bfff17 	ldw	r2,-4(fp)
  804a00:	10800170 	cmpltui	r2,r2,5
  804a04:	103ff31e 	bne	r2,zero,8049d4 <__alt_mem_onchip_memory2_0+0xff7849d4>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
  804a08:	01002174 	movhi	r4,133
  804a0c:	21243704 	addi	r4,r4,-28452
  804a10:	08009a00 	call	8009a0 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
  804a14:	01002174 	movhi	r4,133
  804a18:	21243c04 	addi	r4,r4,-28432
  804a1c:	08009a00 	call	8009a0 <vListInitialise>
	vListInitialise( &xPendingReadyList );
  804a20:	01002174 	movhi	r4,133
  804a24:	21244104 	addi	r4,r4,-28412
  804a28:	08009a00 	call	8009a0 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
  804a2c:	01002174 	movhi	r4,133
  804a30:	21244604 	addi	r4,r4,-28392
  804a34:	08009a00 	call	8009a0 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
  804a38:	01002174 	movhi	r4,133
  804a3c:	21244b04 	addi	r4,r4,-28372
  804a40:	08009a00 	call	8009a0 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
  804a44:	00802174 	movhi	r2,133
  804a48:	10a43704 	addi	r2,r2,-28452
  804a4c:	d0a50615 	stw	r2,-27624(gp)
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
  804a50:	00802174 	movhi	r2,133
  804a54:	10a43c04 	addi	r2,r2,-28432
  804a58:	d0a50715 	stw	r2,-27620(gp)
}
  804a5c:	0001883a 	nop
  804a60:	e037883a 	mov	sp,fp
  804a64:	dfc00117 	ldw	ra,4(sp)
  804a68:	df000017 	ldw	fp,0(sp)
  804a6c:	dec00204 	addi	sp,sp,8
  804a70:	f800283a 	ret

00804a74 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
  804a74:	defffd04 	addi	sp,sp,-12
  804a78:	dfc00215 	stw	ra,8(sp)
  804a7c:	df000115 	stw	fp,4(sp)
  804a80:	df000104 	addi	fp,sp,4
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
  804a84:	00001306 	br	804ad4 <prvCheckTasksWaitingTermination+0x60>
		{
			taskENTER_CRITICAL();
  804a88:	0804ff40 	call	804ff4 <vTaskEnterCritical>
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  804a8c:	00802174 	movhi	r2,133
  804a90:	10a44604 	addi	r2,r2,-28392
  804a94:	10800317 	ldw	r2,12(r2)
  804a98:	10800317 	ldw	r2,12(r2)
  804a9c:	e0bfff15 	stw	r2,-4(fp)
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  804aa0:	e0bfff17 	ldw	r2,-4(fp)
  804aa4:	10800104 	addi	r2,r2,4
  804aa8:	1009883a 	mov	r4,r2
  804aac:	0800b980 	call	800b98 <uxListRemove>
				--uxCurrentNumberOfTasks;
  804ab0:	d0a50917 	ldw	r2,-27612(gp)
  804ab4:	10bfffc4 	addi	r2,r2,-1
  804ab8:	d0a50915 	stw	r2,-27612(gp)
				--uxDeletedTasksWaitingCleanUp;
  804abc:	d0a50817 	ldw	r2,-27616(gp)
  804ac0:	10bfffc4 	addi	r2,r2,-1
  804ac4:	d0a50815 	stw	r2,-27616(gp)
			}
			taskEXIT_CRITICAL();
  804ac8:	08050480 	call	805048 <vTaskExitCritical>

			prvDeleteTCB( pxTCB );
  804acc:	e13fff17 	ldw	r4,-4(fp)
  804ad0:	0804bb80 	call	804bb8 <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
  804ad4:	d0a50817 	ldw	r2,-27616(gp)
  804ad8:	103feb1e 	bne	r2,zero,804a88 <__alt_mem_onchip_memory2_0+0xff784a88>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
  804adc:	0001883a 	nop
  804ae0:	e037883a 	mov	sp,fp
  804ae4:	dfc00117 	ldw	ra,4(sp)
  804ae8:	df000017 	ldw	fp,0(sp)
  804aec:	dec00204 	addi	sp,sp,8
  804af0:	f800283a 	ret

00804af4 <prvTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )

	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
  804af4:	defffd04 	addi	sp,sp,-12
  804af8:	df000215 	stw	fp,8(sp)
  804afc:	df000204 	addi	fp,sp,8
  804b00:	e13fff15 	stw	r4,-4(fp)
	uint32_t ulCount = 0U;
  804b04:	e03ffe15 	stw	zero,-8(fp)

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
  804b08:	00000606 	br	804b24 <prvTaskCheckFreeStackSpace+0x30>
		{
			pucStackByte -= portSTACK_GROWTH;
  804b0c:	e0bfff17 	ldw	r2,-4(fp)
  804b10:	10800044 	addi	r2,r2,1
  804b14:	e0bfff15 	stw	r2,-4(fp)
			ulCount++;
  804b18:	e0bffe17 	ldw	r2,-8(fp)
  804b1c:	10800044 	addi	r2,r2,1
  804b20:	e0bffe15 	stw	r2,-8(fp)

	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
	uint32_t ulCount = 0U;

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
  804b24:	e0bfff17 	ldw	r2,-4(fp)
  804b28:	10800003 	ldbu	r2,0(r2)
  804b2c:	10803fcc 	andi	r2,r2,255
  804b30:	10802960 	cmpeqi	r2,r2,165
  804b34:	103ff51e 	bne	r2,zero,804b0c <__alt_mem_onchip_memory2_0+0xff784b0c>
		{
			pucStackByte -= portSTACK_GROWTH;
			ulCount++;
		}

		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
  804b38:	e0bffe17 	ldw	r2,-8(fp)
  804b3c:	1004d0ba 	srli	r2,r2,2
  804b40:	e0bffe15 	stw	r2,-8(fp)

		return ( configSTACK_DEPTH_TYPE ) ulCount;
  804b44:	e0bffe17 	ldw	r2,-8(fp)
	}
  804b48:	e037883a 	mov	sp,fp
  804b4c:	df000017 	ldw	fp,0(sp)
  804b50:	dec00104 	addi	sp,sp,4
  804b54:	f800283a 	ret

00804b58 <uxTaskGetStackHighWaterMark>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
	{
  804b58:	defffa04 	addi	sp,sp,-24
  804b5c:	dfc00515 	stw	ra,20(sp)
  804b60:	df000415 	stw	fp,16(sp)
  804b64:	df000404 	addi	fp,sp,16
  804b68:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;
	uint8_t *pucEndOfStack;
	UBaseType_t uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
  804b6c:	e0bfff17 	ldw	r2,-4(fp)
  804b70:	1000021e 	bne	r2,zero,804b7c <uxTaskGetStackHighWaterMark+0x24>
  804b74:	d0a50517 	ldw	r2,-27628(gp)
  804b78:	00000106 	br	804b80 <uxTaskGetStackHighWaterMark+0x28>
  804b7c:	e0bfff17 	ldw	r2,-4(fp)
  804b80:	e0bffc15 	stw	r2,-16(fp)

		#if portSTACK_GROWTH < 0
		{
			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
  804b84:	e0bffc17 	ldw	r2,-16(fp)
  804b88:	10800c17 	ldw	r2,48(r2)
  804b8c:	e0bffd15 	stw	r2,-12(fp)
		{
			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
		}
		#endif

		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
  804b90:	e13ffd17 	ldw	r4,-12(fp)
  804b94:	0804af40 	call	804af4 <prvTaskCheckFreeStackSpace>
  804b98:	10bfffcc 	andi	r2,r2,65535
  804b9c:	e0bffe15 	stw	r2,-8(fp)

		return uxReturn;
  804ba0:	e0bffe17 	ldw	r2,-8(fp)
	}
  804ba4:	e037883a 	mov	sp,fp
  804ba8:	dfc00117 	ldw	ra,4(sp)
  804bac:	df000017 	ldw	fp,0(sp)
  804bb0:	dec00204 	addi	sp,sp,8
  804bb4:	f800283a 	ret

00804bb8 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
  804bb8:	defffd04 	addi	sp,sp,-12
  804bbc:	dfc00215 	stw	ra,8(sp)
  804bc0:	df000115 	stw	fp,4(sp)
  804bc4:	df000104 	addi	fp,sp,4
  804bc8:	e13fff15 	stw	r4,-4(fp)

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
  804bcc:	e0bfff17 	ldw	r2,-4(fp)
  804bd0:	10800c17 	ldw	r2,48(r2)
  804bd4:	1009883a 	mov	r4,r2
  804bd8:	08010dc0 	call	8010dc <vPortFree>
			vPortFree( pxTCB );
  804bdc:	e13fff17 	ldw	r4,-4(fp)
  804be0:	08010dc0 	call	8010dc <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
  804be4:	0001883a 	nop
  804be8:	e037883a 	mov	sp,fp
  804bec:	dfc00117 	ldw	ra,4(sp)
  804bf0:	df000017 	ldw	fp,0(sp)
  804bf4:	dec00204 	addi	sp,sp,8
  804bf8:	f800283a 	ret

00804bfc <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
  804bfc:	defffe04 	addi	sp,sp,-8
  804c00:	df000115 	stw	fp,4(sp)
  804c04:	df000104 	addi	fp,sp,4
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  804c08:	d0a50617 	ldw	r2,-27624(gp)
  804c0c:	10800017 	ldw	r2,0(r2)
  804c10:	1000031e 	bne	r2,zero,804c20 <prvResetNextTaskUnblockTime+0x24>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
  804c14:	00bfffc4 	movi	r2,-1
  804c18:	d0a51115 	stw	r2,-27580(gp)
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
  804c1c:	00000706 	br	804c3c <prvResetNextTaskUnblockTime+0x40>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  804c20:	d0a50617 	ldw	r2,-27624(gp)
  804c24:	10800317 	ldw	r2,12(r2)
  804c28:	10800317 	ldw	r2,12(r2)
  804c2c:	e0bfff15 	stw	r2,-4(fp)
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
  804c30:	e0bfff17 	ldw	r2,-4(fp)
  804c34:	10800117 	ldw	r2,4(r2)
  804c38:	d0a51115 	stw	r2,-27580(gp)
	}
}
  804c3c:	0001883a 	nop
  804c40:	e037883a 	mov	sp,fp
  804c44:	df000017 	ldw	fp,0(sp)
  804c48:	dec00104 	addi	sp,sp,4
  804c4c:	f800283a 	ret

00804c50 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
  804c50:	defffe04 	addi	sp,sp,-8
  804c54:	df000115 	stw	fp,4(sp)
  804c58:	df000104 	addi	fp,sp,4
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
  804c5c:	d0a50517 	ldw	r2,-27628(gp)
  804c60:	e0bfff15 	stw	r2,-4(fp)

		return xReturn;
  804c64:	e0bfff17 	ldw	r2,-4(fp)
	}
  804c68:	e037883a 	mov	sp,fp
  804c6c:	df000017 	ldw	fp,0(sp)
  804c70:	dec00104 	addi	sp,sp,4
  804c74:	f800283a 	ret

00804c78 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
  804c78:	defffb04 	addi	sp,sp,-20
  804c7c:	dfc00415 	stw	ra,16(sp)
  804c80:	df000315 	stw	fp,12(sp)
  804c84:	df000304 	addi	fp,sp,12
  804c88:	e13fff15 	stw	r4,-4(fp)
	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
  804c8c:	e0bfff17 	ldw	r2,-4(fp)
  804c90:	e0bffe15 	stw	r2,-8(fp)
	BaseType_t xReturn = pdFALSE;
  804c94:	e03ffd15 	stw	zero,-12(fp)

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
  804c98:	e0bfff17 	ldw	r2,-4(fp)
  804c9c:	10004026 	beq	r2,zero,804da0 <xTaskPriorityInherit+0x128>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
  804ca0:	e0bffe17 	ldw	r2,-8(fp)
  804ca4:	10c00b17 	ldw	r3,44(r2)
  804ca8:	d0a50517 	ldw	r2,-27628(gp)
  804cac:	10800b17 	ldw	r2,44(r2)
  804cb0:	1880342e 	bgeu	r3,r2,804d84 <xTaskPriorityInherit+0x10c>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
  804cb4:	e0bffe17 	ldw	r2,-8(fp)
  804cb8:	10800617 	ldw	r2,24(r2)
  804cbc:	10000616 	blt	r2,zero,804cd8 <xTaskPriorityInherit+0x60>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  804cc0:	d0a50517 	ldw	r2,-27628(gp)
  804cc4:	10800b17 	ldw	r2,44(r2)
  804cc8:	00c00144 	movi	r3,5
  804ccc:	1887c83a 	sub	r3,r3,r2
  804cd0:	e0bffe17 	ldw	r2,-8(fp)
  804cd4:	10c00615 	stw	r3,24(r2)
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
  804cd8:	e0bffe17 	ldw	r2,-8(fp)
  804cdc:	10c00517 	ldw	r3,20(r2)
  804ce0:	e0bffe17 	ldw	r2,-8(fp)
  804ce4:	10800b17 	ldw	r2,44(r2)
  804ce8:	11000524 	muli	r4,r2,20
  804cec:	00802174 	movhi	r2,133
  804cf0:	10a41e04 	addi	r2,r2,-28552
  804cf4:	2085883a 	add	r2,r4,r2
  804cf8:	18801b1e 	bne	r3,r2,804d68 <xTaskPriorityInherit+0xf0>
				{
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  804cfc:	e0bffe17 	ldw	r2,-8(fp)
  804d00:	10800104 	addi	r2,r2,4
  804d04:	1009883a 	mov	r4,r2
  804d08:	0800b980 	call	800b98 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
  804d0c:	d0a50517 	ldw	r2,-27628(gp)
  804d10:	10c00b17 	ldw	r3,44(r2)
  804d14:	e0bffe17 	ldw	r2,-8(fp)
  804d18:	10c00b15 	stw	r3,44(r2)
					prvAddTaskToReadyList( pxMutexHolderTCB );
  804d1c:	e0bffe17 	ldw	r2,-8(fp)
  804d20:	10800b17 	ldw	r2,44(r2)
  804d24:	d0e50b17 	ldw	r3,-27604(gp)
  804d28:	1880032e 	bgeu	r3,r2,804d38 <xTaskPriorityInherit+0xc0>
  804d2c:	e0bffe17 	ldw	r2,-8(fp)
  804d30:	10800b17 	ldw	r2,44(r2)
  804d34:	d0a50b15 	stw	r2,-27604(gp)
  804d38:	e0bffe17 	ldw	r2,-8(fp)
  804d3c:	10800b17 	ldw	r2,44(r2)
  804d40:	10c00524 	muli	r3,r2,20
  804d44:	00802174 	movhi	r2,133
  804d48:	10a41e04 	addi	r2,r2,-28552
  804d4c:	1887883a 	add	r3,r3,r2
  804d50:	e0bffe17 	ldw	r2,-8(fp)
  804d54:	10800104 	addi	r2,r2,4
  804d58:	100b883a 	mov	r5,r2
  804d5c:	1809883a 	mov	r4,r3
  804d60:	0800a340 	call	800a34 <vListInsertEnd>
  804d64:	00000406 	br	804d78 <xTaskPriorityInherit+0x100>
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
  804d68:	d0a50517 	ldw	r2,-27628(gp)
  804d6c:	10c00b17 	ldw	r3,44(r2)
  804d70:	e0bffe17 	ldw	r2,-8(fp)
  804d74:	10c00b15 	stw	r3,44(r2)
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
  804d78:	00800044 	movi	r2,1
  804d7c:	e0bffd15 	stw	r2,-12(fp)
  804d80:	00000706 	br	804da0 <xTaskPriorityInherit+0x128>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
  804d84:	e0bffe17 	ldw	r2,-8(fp)
  804d88:	10c01017 	ldw	r3,64(r2)
  804d8c:	d0a50517 	ldw	r2,-27628(gp)
  804d90:	10800b17 	ldw	r2,44(r2)
  804d94:	1880022e 	bgeu	r3,r2,804da0 <xTaskPriorityInherit+0x128>
					current priority of the mutex holder is not lower than the
					priority of the task attempting to take the mutex.
					Therefore the mutex holder must have already inherited a
					priority, but inheritance would have occurred if that had
					not been the case. */
					xReturn = pdTRUE;
  804d98:	00800044 	movi	r2,1
  804d9c:	e0bffd15 	stw	r2,-12(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
  804da0:	e0bffd17 	ldw	r2,-12(fp)
	}
  804da4:	e037883a 	mov	sp,fp
  804da8:	dfc00117 	ldw	ra,4(sp)
  804dac:	df000017 	ldw	fp,0(sp)
  804db0:	dec00204 	addi	sp,sp,8
  804db4:	f800283a 	ret

00804db8 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
  804db8:	defffb04 	addi	sp,sp,-20
  804dbc:	dfc00415 	stw	ra,16(sp)
  804dc0:	df000315 	stw	fp,12(sp)
  804dc4:	df000304 	addi	fp,sp,12
  804dc8:	e13fff15 	stw	r4,-4(fp)
	TCB_t * const pxTCB = pxMutexHolder;
  804dcc:	e0bfff17 	ldw	r2,-4(fp)
  804dd0:	e0bffe15 	stw	r2,-8(fp)
	BaseType_t xReturn = pdFALSE;
  804dd4:	e03ffd15 	stw	zero,-12(fp)

		if( pxMutexHolder != NULL )
  804dd8:	e0bfff17 	ldw	r2,-4(fp)
  804ddc:	10002f26 	beq	r2,zero,804e9c <xTaskPriorityDisinherit+0xe4>
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
  804de0:	e0bffe17 	ldw	r2,-8(fp)
  804de4:	10801117 	ldw	r2,68(r2)
  804de8:	10ffffc4 	addi	r3,r2,-1
  804dec:	e0bffe17 	ldw	r2,-8(fp)
  804df0:	10c01115 	stw	r3,68(r2)

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
  804df4:	e0bffe17 	ldw	r2,-8(fp)
  804df8:	10c00b17 	ldw	r3,44(r2)
  804dfc:	e0bffe17 	ldw	r2,-8(fp)
  804e00:	10801017 	ldw	r2,64(r2)
  804e04:	18802526 	beq	r3,r2,804e9c <xTaskPriorityDisinherit+0xe4>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
  804e08:	e0bffe17 	ldw	r2,-8(fp)
  804e0c:	10801117 	ldw	r2,68(r2)
  804e10:	1000221e 	bne	r2,zero,804e9c <xTaskPriorityDisinherit+0xe4>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready/delayed list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  804e14:	e0bffe17 	ldw	r2,-8(fp)
  804e18:	10800104 	addi	r2,r2,4
  804e1c:	1009883a 	mov	r4,r2
  804e20:	0800b980 	call	800b98 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
  804e24:	e0bffe17 	ldw	r2,-8(fp)
  804e28:	10c01017 	ldw	r3,64(r2)
  804e2c:	e0bffe17 	ldw	r2,-8(fp)
  804e30:	10c00b15 	stw	r3,44(r2)

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  804e34:	e0bffe17 	ldw	r2,-8(fp)
  804e38:	10800b17 	ldw	r2,44(r2)
  804e3c:	00c00144 	movi	r3,5
  804e40:	1887c83a 	sub	r3,r3,r2
  804e44:	e0bffe17 	ldw	r2,-8(fp)
  804e48:	10c00615 	stw	r3,24(r2)
					prvAddTaskToReadyList( pxTCB );
  804e4c:	e0bffe17 	ldw	r2,-8(fp)
  804e50:	10800b17 	ldw	r2,44(r2)
  804e54:	d0e50b17 	ldw	r3,-27604(gp)
  804e58:	1880032e 	bgeu	r3,r2,804e68 <xTaskPriorityDisinherit+0xb0>
  804e5c:	e0bffe17 	ldw	r2,-8(fp)
  804e60:	10800b17 	ldw	r2,44(r2)
  804e64:	d0a50b15 	stw	r2,-27604(gp)
  804e68:	e0bffe17 	ldw	r2,-8(fp)
  804e6c:	10800b17 	ldw	r2,44(r2)
  804e70:	10c00524 	muli	r3,r2,20
  804e74:	00802174 	movhi	r2,133
  804e78:	10a41e04 	addi	r2,r2,-28552
  804e7c:	1887883a 	add	r3,r3,r2
  804e80:	e0bffe17 	ldw	r2,-8(fp)
  804e84:	10800104 	addi	r2,r2,4
  804e88:	100b883a 	mov	r5,r2
  804e8c:	1809883a 	mov	r4,r3
  804e90:	0800a340 	call	800a34 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
  804e94:	00800044 	movi	r2,1
  804e98:	e0bffd15 	stw	r2,-12(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
  804e9c:	e0bffd17 	ldw	r2,-12(fp)
	}
  804ea0:	e037883a 	mov	sp,fp
  804ea4:	dfc00117 	ldw	ra,4(sp)
  804ea8:	df000017 	ldw	fp,0(sp)
  804eac:	dec00204 	addi	sp,sp,8
  804eb0:	f800283a 	ret

00804eb4 <vTaskPriorityDisinheritAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
	{
  804eb4:	defff804 	addi	sp,sp,-32
  804eb8:	dfc00715 	stw	ra,28(sp)
  804ebc:	df000615 	stw	fp,24(sp)
  804ec0:	df000604 	addi	fp,sp,24
  804ec4:	e13ffe15 	stw	r4,-8(fp)
  804ec8:	e17fff15 	stw	r5,-4(fp)
	TCB_t * const pxTCB = pxMutexHolder;
  804ecc:	e0bffe17 	ldw	r2,-8(fp)
  804ed0:	e0bffb15 	stw	r2,-20(fp)
	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
  804ed4:	00800044 	movi	r2,1
  804ed8:	e0bffc15 	stw	r2,-16(fp)

		if( pxMutexHolder != NULL )
  804edc:	e0bffe17 	ldw	r2,-8(fp)
  804ee0:	10003e26 	beq	r2,zero,804fdc <vTaskPriorityDisinheritAfterTimeout+0x128>

			/* Determine the priority to which the priority of the task that
			holds the mutex should be set.  This will be the greater of the
			holding task's base priority and the priority of the highest
			priority task that is waiting to obtain the mutex. */
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
  804ee4:	e0bffb17 	ldw	r2,-20(fp)
  804ee8:	10c01017 	ldw	r3,64(r2)
  804eec:	e0bfff17 	ldw	r2,-4(fp)
  804ef0:	1880032e 	bgeu	r3,r2,804f00 <vTaskPriorityDisinheritAfterTimeout+0x4c>
			{
				uxPriorityToUse = uxHighestPriorityWaitingTask;
  804ef4:	e0bfff17 	ldw	r2,-4(fp)
  804ef8:	e0bffa15 	stw	r2,-24(fp)
  804efc:	00000306 	br	804f0c <vTaskPriorityDisinheritAfterTimeout+0x58>
			}
			else
			{
				uxPriorityToUse = pxTCB->uxBasePriority;
  804f00:	e0bffb17 	ldw	r2,-20(fp)
  804f04:	10801017 	ldw	r2,64(r2)
  804f08:	e0bffa15 	stw	r2,-24(fp)
			}

			/* Does the priority need to change? */
			if( pxTCB->uxPriority != uxPriorityToUse )
  804f0c:	e0bffb17 	ldw	r2,-20(fp)
  804f10:	10c00b17 	ldw	r3,44(r2)
  804f14:	e0bffa17 	ldw	r2,-24(fp)
  804f18:	18803026 	beq	r3,r2,804fdc <vTaskPriorityDisinheritAfterTimeout+0x128>
			{
				/* Only disinherit if no other mutexes are held.  This is a
				simplification in the priority inheritance implementation.  If
				the task that holds the mutex is also holding other mutexes then
				the other mutexes may have caused the priority inheritance. */
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
  804f1c:	e0bffb17 	ldw	r2,-20(fp)
  804f20:	10c01117 	ldw	r3,68(r2)
  804f24:	e0bffc17 	ldw	r2,-16(fp)
  804f28:	18802c1e 	bne	r3,r2,804fdc <vTaskPriorityDisinheritAfterTimeout+0x128>

					/* Disinherit the priority, remembering the previous
					priority to facilitate determining the subject task's
					state. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
  804f2c:	e0bffb17 	ldw	r2,-20(fp)
  804f30:	10800b17 	ldw	r2,44(r2)
  804f34:	e0bffd15 	stw	r2,-12(fp)
					pxTCB->uxPriority = uxPriorityToUse;
  804f38:	e0bffb17 	ldw	r2,-20(fp)
  804f3c:	e0fffa17 	ldw	r3,-24(fp)
  804f40:	10c00b15 	stw	r3,44(r2)

					/* Only reset the event list item value if the value is not
					being used for anything else. */
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
  804f44:	e0bffb17 	ldw	r2,-20(fp)
  804f48:	10800617 	ldw	r2,24(r2)
  804f4c:	10000516 	blt	r2,zero,804f64 <vTaskPriorityDisinheritAfterTimeout+0xb0>
					{
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  804f50:	00c00144 	movi	r3,5
  804f54:	e0bffa17 	ldw	r2,-24(fp)
  804f58:	1887c83a 	sub	r3,r3,r2
  804f5c:	e0bffb17 	ldw	r2,-20(fp)
  804f60:	10c00615 	stw	r3,24(r2)
					then the task that holds the mutex could be in either the
					Ready, Blocked or Suspended states.  Only remove the task
					from its current state list if it is in the Ready state as
					the task's priority is going to change and there is one
					Ready list per priority. */
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
  804f64:	e0bffb17 	ldw	r2,-20(fp)
  804f68:	10c00517 	ldw	r3,20(r2)
  804f6c:	e0bffd17 	ldw	r2,-12(fp)
  804f70:	11000524 	muli	r4,r2,20
  804f74:	00802174 	movhi	r2,133
  804f78:	10a41e04 	addi	r2,r2,-28552
  804f7c:	2085883a 	add	r2,r4,r2
  804f80:	1880161e 	bne	r3,r2,804fdc <vTaskPriorityDisinheritAfterTimeout+0x128>
					{
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  804f84:	e0bffb17 	ldw	r2,-20(fp)
  804f88:	10800104 	addi	r2,r2,4
  804f8c:	1009883a 	mov	r4,r2
  804f90:	0800b980 	call	800b98 <uxListRemove>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
  804f94:	e0bffb17 	ldw	r2,-20(fp)
  804f98:	10800b17 	ldw	r2,44(r2)
  804f9c:	d0e50b17 	ldw	r3,-27604(gp)
  804fa0:	1880032e 	bgeu	r3,r2,804fb0 <vTaskPriorityDisinheritAfterTimeout+0xfc>
  804fa4:	e0bffb17 	ldw	r2,-20(fp)
  804fa8:	10800b17 	ldw	r2,44(r2)
  804fac:	d0a50b15 	stw	r2,-27604(gp)
  804fb0:	e0bffb17 	ldw	r2,-20(fp)
  804fb4:	10800b17 	ldw	r2,44(r2)
  804fb8:	10c00524 	muli	r3,r2,20
  804fbc:	00802174 	movhi	r2,133
  804fc0:	10a41e04 	addi	r2,r2,-28552
  804fc4:	1887883a 	add	r3,r3,r2
  804fc8:	e0bffb17 	ldw	r2,-20(fp)
  804fcc:	10800104 	addi	r2,r2,4
  804fd0:	100b883a 	mov	r5,r2
  804fd4:	1809883a 	mov	r4,r3
  804fd8:	0800a340 	call	800a34 <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  804fdc:	0001883a 	nop
  804fe0:	e037883a 	mov	sp,fp
  804fe4:	dfc00117 	ldw	ra,4(sp)
  804fe8:	df000017 	ldw	fp,0(sp)
  804fec:	dec00204 	addi	sp,sp,8
  804ff0:	f800283a 	ret

00804ff4 <vTaskEnterCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskEnterCritical( void )
	{
  804ff4:	defffe04 	addi	sp,sp,-8
  804ff8:	df000115 	stw	fp,4(sp)
  804ffc:	df000104 	addi	fp,sp,4
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  805000:	0005303a 	rdctl	r2,status
  805004:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  805008:	e0ffff17 	ldw	r3,-4(fp)
  80500c:	00bfff84 	movi	r2,-2
  805010:	1884703a 	and	r2,r3,r2
  805014:	1001703a 	wrctl	status,r2
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
  805018:	d0a50c17 	ldw	r2,-27600(gp)
  80501c:	10000526 	beq	r2,zero,805034 <vTaskEnterCritical+0x40>
		{
			( pxCurrentTCB->uxCriticalNesting )++;
  805020:	d0a50517 	ldw	r2,-27628(gp)
  805024:	10c00f17 	ldw	r3,60(r2)
  805028:	18c00044 	addi	r3,r3,1
  80502c:	10c00f15 	stw	r3,60(r2)
			function so	assert() if it is being called from an interrupt
			context.  Only API functions that end in "FromISR" can be used in an
			interrupt.  Only assert if the critical nesting count is 1 to
			protect against recursive calls if the assert function also uses a
			critical section. */
			if( pxCurrentTCB->uxCriticalNesting == 1 )
  805030:	d0a50517 	ldw	r2,-27628(gp)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  805034:	0001883a 	nop
  805038:	e037883a 	mov	sp,fp
  80503c:	df000017 	ldw	fp,0(sp)
  805040:	dec00104 	addi	sp,sp,4
  805044:	f800283a 	ret

00805048 <vTaskExitCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
  805048:	defffe04 	addi	sp,sp,-8
  80504c:	df000115 	stw	fp,4(sp)
  805050:	df000104 	addi	fp,sp,4
		if( xSchedulerRunning != pdFALSE )
  805054:	d0a50c17 	ldw	r2,-27600(gp)
  805058:	10000e26 	beq	r2,zero,805094 <vTaskExitCritical+0x4c>
		{
			if( pxCurrentTCB->uxCriticalNesting > 0U )
  80505c:	d0a50517 	ldw	r2,-27628(gp)
  805060:	10800f17 	ldw	r2,60(r2)
  805064:	10000b26 	beq	r2,zero,805094 <vTaskExitCritical+0x4c>
			{
				( pxCurrentTCB->uxCriticalNesting )--;
  805068:	d0a50517 	ldw	r2,-27628(gp)
  80506c:	10c00f17 	ldw	r3,60(r2)
  805070:	18ffffc4 	addi	r3,r3,-1
  805074:	10c00f15 	stw	r3,60(r2)

				if( pxCurrentTCB->uxCriticalNesting == 0U )
  805078:	d0a50517 	ldw	r2,-27628(gp)
  80507c:	10800f17 	ldw	r2,60(r2)
  805080:	1000041e 	bne	r2,zero,805094 <vTaskExitCritical+0x4c>
  805084:	00800044 	movi	r2,1
  805088:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  80508c:	e0bfff17 	ldw	r2,-4(fp)
  805090:	1001703a 	wrctl	status,r2
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  805094:	0001883a 	nop
  805098:	e037883a 	mov	sp,fp
  80509c:	df000017 	ldw	fp,0(sp)
  8050a0:	dec00104 	addi	sp,sp,4
  8050a4:	f800283a 	ret

008050a8 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
  8050a8:	defffe04 	addi	sp,sp,-8
  8050ac:	df000115 	stw	fp,4(sp)
  8050b0:	df000104 	addi	fp,sp,4
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
  8050b4:	d0a50517 	ldw	r2,-27628(gp)
  8050b8:	10800617 	ldw	r2,24(r2)
  8050bc:	e0bfff15 	stw	r2,-4(fp)

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  8050c0:	d0a50517 	ldw	r2,-27628(gp)
  8050c4:	d0e50517 	ldw	r3,-27628(gp)
  8050c8:	18c00b17 	ldw	r3,44(r3)
  8050cc:	01000144 	movi	r4,5
  8050d0:	20c7c83a 	sub	r3,r4,r3
  8050d4:	10c00615 	stw	r3,24(r2)

	return uxReturn;
  8050d8:	e0bfff17 	ldw	r2,-4(fp)
}
  8050dc:	e037883a 	mov	sp,fp
  8050e0:	df000017 	ldw	fp,0(sp)
  8050e4:	dec00104 	addi	sp,sp,4
  8050e8:	f800283a 	ret

008050ec <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
	{
  8050ec:	deffff04 	addi	sp,sp,-4
  8050f0:	df000015 	stw	fp,0(sp)
  8050f4:	d839883a 	mov	fp,sp
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
  8050f8:	d0a50517 	ldw	r2,-27628(gp)
  8050fc:	10000426 	beq	r2,zero,805110 <pvTaskIncrementMutexHeldCount+0x24>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
  805100:	d0a50517 	ldw	r2,-27628(gp)
  805104:	10c01117 	ldw	r3,68(r2)
  805108:	18c00044 	addi	r3,r3,1
  80510c:	10c01115 	stw	r3,68(r2)
		}

		return pxCurrentTCB;
  805110:	d0a50517 	ldw	r2,-27628(gp)
	}
  805114:	e037883a 	mov	sp,fp
  805118:	df000017 	ldw	fp,0(sp)
  80511c:	dec00104 	addi	sp,sp,4
  805120:	f800283a 	ret

00805124 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
  805124:	defffb04 	addi	sp,sp,-20
  805128:	dfc00415 	stw	ra,16(sp)
  80512c:	df000315 	stw	fp,12(sp)
  805130:	df000304 	addi	fp,sp,12
  805134:	e13ffe15 	stw	r4,-8(fp)
  805138:	e17fff15 	stw	r5,-4(fp)
	uint32_t ulReturn;

		taskENTER_CRITICAL();
  80513c:	0804ff40 	call	804ff4 <vTaskEnterCritical>
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
  805140:	d0a50517 	ldw	r2,-27628(gp)
  805144:	10801217 	ldw	r2,72(r2)
  805148:	1000091e 	bne	r2,zero,805170 <ulTaskNotifyTake+0x4c>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
  80514c:	d0a50517 	ldw	r2,-27628(gp)
  805150:	00c00044 	movi	r3,1
  805154:	10c01305 	stb	r3,76(r2)

				if( xTicksToWait > ( TickType_t ) 0 )
  805158:	e0bfff17 	ldw	r2,-4(fp)
  80515c:	10000426 	beq	r2,zero,805170 <ulTaskNotifyTake+0x4c>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
  805160:	01400044 	movi	r5,1
  805164:	e13fff17 	ldw	r4,-4(fp)
  805168:	08058680 	call	805868 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
  80516c:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
  805170:	08050480 	call	805048 <vTaskExitCritical>

		taskENTER_CRITICAL();
  805174:	0804ff40 	call	804ff4 <vTaskEnterCritical>
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
  805178:	d0a50517 	ldw	r2,-27628(gp)
  80517c:	10801217 	ldw	r2,72(r2)
  805180:	e0bffd15 	stw	r2,-12(fp)

			if( ulReturn != 0UL )
  805184:	e0bffd17 	ldw	r2,-12(fp)
  805188:	10000926 	beq	r2,zero,8051b0 <ulTaskNotifyTake+0x8c>
			{
				if( xClearCountOnExit != pdFALSE )
  80518c:	e0bffe17 	ldw	r2,-8(fp)
  805190:	10000326 	beq	r2,zero,8051a0 <ulTaskNotifyTake+0x7c>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
  805194:	d0a50517 	ldw	r2,-27628(gp)
  805198:	10001215 	stw	zero,72(r2)
  80519c:	00000406 	br	8051b0 <ulTaskNotifyTake+0x8c>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
  8051a0:	d0a50517 	ldw	r2,-27628(gp)
  8051a4:	e0fffd17 	ldw	r3,-12(fp)
  8051a8:	18ffffc4 	addi	r3,r3,-1
  8051ac:	10c01215 	stw	r3,72(r2)
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
  8051b0:	d0a50517 	ldw	r2,-27628(gp)
  8051b4:	10001305 	stb	zero,76(r2)
		}
		taskEXIT_CRITICAL();
  8051b8:	08050480 	call	805048 <vTaskExitCritical>

		return ulReturn;
  8051bc:	e0bffd17 	ldw	r2,-12(fp)
	}
  8051c0:	e037883a 	mov	sp,fp
  8051c4:	dfc00117 	ldw	ra,4(sp)
  8051c8:	df000017 	ldw	fp,0(sp)
  8051cc:	dec00204 	addi	sp,sp,8
  8051d0:	f800283a 	ret

008051d4 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
  8051d4:	defff904 	addi	sp,sp,-28
  8051d8:	dfc00615 	stw	ra,24(sp)
  8051dc:	df000515 	stw	fp,20(sp)
  8051e0:	df000504 	addi	fp,sp,20
  8051e4:	e13ffc15 	stw	r4,-16(fp)
  8051e8:	e17ffd15 	stw	r5,-12(fp)
  8051ec:	e1bffe15 	stw	r6,-8(fp)
  8051f0:	e1ffff15 	stw	r7,-4(fp)
	BaseType_t xReturn;

		taskENTER_CRITICAL();
  8051f4:	0804ff40 	call	804ff4 <vTaskEnterCritical>
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
  8051f8:	d0a50517 	ldw	r2,-27628(gp)
  8051fc:	10801303 	ldbu	r2,76(r2)
  805200:	10803fcc 	andi	r2,r2,255
  805204:	108000a0 	cmpeqi	r2,r2,2
  805208:	10000f1e 	bne	r2,zero,805248 <xTaskNotifyWait+0x74>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
  80520c:	d0a50517 	ldw	r2,-27628(gp)
  805210:	11001217 	ldw	r4,72(r2)
  805214:	e0fffc17 	ldw	r3,-16(fp)
  805218:	00c6303a 	nor	r3,zero,r3
  80521c:	20c6703a 	and	r3,r4,r3
  805220:	10c01215 	stw	r3,72(r2)

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
  805224:	d0a50517 	ldw	r2,-27628(gp)
  805228:	00c00044 	movi	r3,1
  80522c:	10c01305 	stb	r3,76(r2)

				if( xTicksToWait > ( TickType_t ) 0 )
  805230:	e0bfff17 	ldw	r2,-4(fp)
  805234:	10000426 	beq	r2,zero,805248 <xTaskNotifyWait+0x74>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
  805238:	01400044 	movi	r5,1
  80523c:	e13fff17 	ldw	r4,-4(fp)
  805240:	08058680 	call	805868 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
  805244:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
  805248:	08050480 	call	805048 <vTaskExitCritical>

		taskENTER_CRITICAL();
  80524c:	0804ff40 	call	804ff4 <vTaskEnterCritical>
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
  805250:	e0bffe17 	ldw	r2,-8(fp)
  805254:	10000426 	beq	r2,zero,805268 <xTaskNotifyWait+0x94>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
  805258:	d0a50517 	ldw	r2,-27628(gp)
  80525c:	10c01217 	ldw	r3,72(r2)
  805260:	e0bffe17 	ldw	r2,-8(fp)
  805264:	10c00015 	stw	r3,0(r2)

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
  805268:	d0a50517 	ldw	r2,-27628(gp)
  80526c:	10801303 	ldbu	r2,76(r2)
  805270:	10803fcc 	andi	r2,r2,255
  805274:	108000a0 	cmpeqi	r2,r2,2
  805278:	1000021e 	bne	r2,zero,805284 <xTaskNotifyWait+0xb0>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
  80527c:	e03ffb15 	stw	zero,-20(fp)
  805280:	00000806 	br	8052a4 <xTaskNotifyWait+0xd0>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
  805284:	d0a50517 	ldw	r2,-27628(gp)
  805288:	11001217 	ldw	r4,72(r2)
  80528c:	e0fffd17 	ldw	r3,-12(fp)
  805290:	00c6303a 	nor	r3,zero,r3
  805294:	20c6703a 	and	r3,r4,r3
  805298:	10c01215 	stw	r3,72(r2)
				xReturn = pdTRUE;
  80529c:	00800044 	movi	r2,1
  8052a0:	e0bffb15 	stw	r2,-20(fp)
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
  8052a4:	d0a50517 	ldw	r2,-27628(gp)
  8052a8:	10001305 	stb	zero,76(r2)
		}
		taskEXIT_CRITICAL();
  8052ac:	08050480 	call	805048 <vTaskExitCritical>

		return xReturn;
  8052b0:	e0bffb17 	ldw	r2,-20(fp)
	}
  8052b4:	e037883a 	mov	sp,fp
  8052b8:	dfc00117 	ldw	ra,4(sp)
  8052bc:	df000017 	ldw	fp,0(sp)
  8052c0:	dec00204 	addi	sp,sp,8
  8052c4:	f800283a 	ret

008052c8 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
  8052c8:	defff704 	addi	sp,sp,-36
  8052cc:	dfc00815 	stw	ra,32(sp)
  8052d0:	df000715 	stw	fp,28(sp)
  8052d4:	df000704 	addi	fp,sp,28
  8052d8:	e13ffc15 	stw	r4,-16(fp)
  8052dc:	e17ffd15 	stw	r5,-12(fp)
  8052e0:	e1bffe15 	stw	r6,-8(fp)
  8052e4:	e1ffff15 	stw	r7,-4(fp)
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
  8052e8:	00800044 	movi	r2,1
  8052ec:	e0bff915 	stw	r2,-28(fp)
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
  8052f0:	e0bffc17 	ldw	r2,-16(fp)
  8052f4:	e0bffa15 	stw	r2,-24(fp)

		taskENTER_CRITICAL();
  8052f8:	0804ff40 	call	804ff4 <vTaskEnterCritical>
		{
			if( pulPreviousNotificationValue != NULL )
  8052fc:	e0bfff17 	ldw	r2,-4(fp)
  805300:	10000426 	beq	r2,zero,805314 <xTaskGenericNotify+0x4c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
  805304:	e0bffa17 	ldw	r2,-24(fp)
  805308:	10c01217 	ldw	r3,72(r2)
  80530c:	e0bfff17 	ldw	r2,-4(fp)
  805310:	10c00015 	stw	r3,0(r2)
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
  805314:	e0bffa17 	ldw	r2,-24(fp)
  805318:	10801303 	ldbu	r2,76(r2)
  80531c:	e0bffb05 	stb	r2,-20(fp)

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
  805320:	e0bffa17 	ldw	r2,-24(fp)
  805324:	00c00084 	movi	r3,2
  805328:	10c01305 	stb	r3,76(r2)

			switch( eAction )
  80532c:	e0bffe17 	ldw	r2,-8(fp)
  805330:	10800168 	cmpgeui	r2,r2,5
  805334:	1000261e 	bne	r2,zero,8053d0 <xTaskGenericNotify+0x108>
  805338:	e0bffe17 	ldw	r2,-8(fp)
  80533c:	100690ba 	slli	r3,r2,2
  805340:	00802034 	movhi	r2,128
  805344:	1094d504 	addi	r2,r2,21332
  805348:	1885883a 	add	r2,r3,r2
  80534c:	10800017 	ldw	r2,0(r2)
  805350:	1000683a 	jmp	r2
  805354:	008053d8 	cmpnei	r2,zero,335
  805358:	00805368 	cmpgeui	r2,zero,333
  80535c:	00805384 	movi	r2,334
  805360:	0080539c 	xori	r2,zero,334
  805364:	008053ac 	andhi	r2,zero,334
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
  805368:	e0bffa17 	ldw	r2,-24(fp)
  80536c:	10c01217 	ldw	r3,72(r2)
  805370:	e0bffd17 	ldw	r2,-12(fp)
  805374:	1886b03a 	or	r3,r3,r2
  805378:	e0bffa17 	ldw	r2,-24(fp)
  80537c:	10c01215 	stw	r3,72(r2)
					break;
  805380:	00001606 	br	8053dc <xTaskGenericNotify+0x114>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
  805384:	e0bffa17 	ldw	r2,-24(fp)
  805388:	10801217 	ldw	r2,72(r2)
  80538c:	10c00044 	addi	r3,r2,1
  805390:	e0bffa17 	ldw	r2,-24(fp)
  805394:	10c01215 	stw	r3,72(r2)
					break;
  805398:	00001006 	br	8053dc <xTaskGenericNotify+0x114>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
  80539c:	e0bffa17 	ldw	r2,-24(fp)
  8053a0:	e0fffd17 	ldw	r3,-12(fp)
  8053a4:	10c01215 	stw	r3,72(r2)
					break;
  8053a8:	00000c06 	br	8053dc <xTaskGenericNotify+0x114>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
  8053ac:	e0bffb03 	ldbu	r2,-20(fp)
  8053b0:	108000a0 	cmpeqi	r2,r2,2
  8053b4:	1000041e 	bne	r2,zero,8053c8 <xTaskGenericNotify+0x100>
					{
						pxTCB->ulNotifiedValue = ulValue;
  8053b8:	e0bffa17 	ldw	r2,-24(fp)
  8053bc:	e0fffd17 	ldw	r3,-12(fp)
  8053c0:	10c01215 	stw	r3,72(r2)
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
  8053c4:	00000506 	br	8053dc <xTaskGenericNotify+0x114>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
  8053c8:	e03ff915 	stw	zero,-28(fp)
					}
					break;
  8053cc:	00000306 	br	8053dc <xTaskGenericNotify+0x114>
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );

					break;
  8053d0:	0001883a 	nop
  8053d4:	00000106 	br	8053dc <xTaskGenericNotify+0x114>
					break;

				case eNoAction:
					/* The task is being notified without its notify value being
					updated. */
					break;
  8053d8:	0001883a 	nop

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
  8053dc:	e0bffb03 	ldbu	r2,-20(fp)
  8053e0:	10800058 	cmpnei	r2,r2,1
  8053e4:	10001c1e 	bne	r2,zero,805458 <xTaskGenericNotify+0x190>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  8053e8:	e0bffa17 	ldw	r2,-24(fp)
  8053ec:	10800104 	addi	r2,r2,4
  8053f0:	1009883a 	mov	r4,r2
  8053f4:	0800b980 	call	800b98 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
  8053f8:	e0bffa17 	ldw	r2,-24(fp)
  8053fc:	10800b17 	ldw	r2,44(r2)
  805400:	d0e50b17 	ldw	r3,-27604(gp)
  805404:	1880032e 	bgeu	r3,r2,805414 <xTaskGenericNotify+0x14c>
  805408:	e0bffa17 	ldw	r2,-24(fp)
  80540c:	10800b17 	ldw	r2,44(r2)
  805410:	d0a50b15 	stw	r2,-27604(gp)
  805414:	e0bffa17 	ldw	r2,-24(fp)
  805418:	10800b17 	ldw	r2,44(r2)
  80541c:	10c00524 	muli	r3,r2,20
  805420:	00802174 	movhi	r2,133
  805424:	10a41e04 	addi	r2,r2,-28552
  805428:	1887883a 	add	r3,r3,r2
  80542c:	e0bffa17 	ldw	r2,-24(fp)
  805430:	10800104 	addi	r2,r2,4
  805434:	100b883a 	mov	r5,r2
  805438:	1809883a 	mov	r4,r3
  80543c:	0800a340 	call	800a34 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
  805440:	e0bffa17 	ldw	r2,-24(fp)
  805444:	10800b17 	ldw	r2,44(r2)
  805448:	d0e50517 	ldw	r3,-27628(gp)
  80544c:	18c00b17 	ldw	r3,44(r3)
  805450:	1880012e 	bgeu	r3,r2,805458 <xTaskGenericNotify+0x190>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
  805454:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
  805458:	08050480 	call	805048 <vTaskExitCritical>

		return xReturn;
  80545c:	e0bff917 	ldw	r2,-28(fp)
	}
  805460:	e037883a 	mov	sp,fp
  805464:	dfc00117 	ldw	ra,4(sp)
  805468:	df000017 	ldw	fp,0(sp)
  80546c:	dec00204 	addi	sp,sp,8
  805470:	f800283a 	ret

00805474 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
  805474:	defff604 	addi	sp,sp,-40
  805478:	dfc00915 	stw	ra,36(sp)
  80547c:	df000815 	stw	fp,32(sp)
  805480:	df000804 	addi	fp,sp,32
  805484:	e13ffc15 	stw	r4,-16(fp)
  805488:	e17ffd15 	stw	r5,-12(fp)
  80548c:	e1bffe15 	stw	r6,-8(fp)
  805490:	e1ffff15 	stw	r7,-4(fp)
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
  805494:	00800044 	movi	r2,1
  805498:	e0bff815 	stw	r2,-32(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
  80549c:	e0bffc17 	ldw	r2,-16(fp)
  8054a0:	e0bff915 	stw	r2,-28(fp)

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  8054a4:	e03ffa15 	stw	zero,-24(fp)
		{
			if( pulPreviousNotificationValue != NULL )
  8054a8:	e0bfff17 	ldw	r2,-4(fp)
  8054ac:	10000426 	beq	r2,zero,8054c0 <xTaskGenericNotifyFromISR+0x4c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
  8054b0:	e0bff917 	ldw	r2,-28(fp)
  8054b4:	10c01217 	ldw	r3,72(r2)
  8054b8:	e0bfff17 	ldw	r2,-4(fp)
  8054bc:	10c00015 	stw	r3,0(r2)
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
  8054c0:	e0bff917 	ldw	r2,-28(fp)
  8054c4:	10801303 	ldbu	r2,76(r2)
  8054c8:	e0bffb05 	stb	r2,-20(fp)
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
  8054cc:	e0bff917 	ldw	r2,-28(fp)
  8054d0:	00c00084 	movi	r3,2
  8054d4:	10c01305 	stb	r3,76(r2)

			switch( eAction )
  8054d8:	e0bffe17 	ldw	r2,-8(fp)
  8054dc:	10800168 	cmpgeui	r2,r2,5
  8054e0:	1000261e 	bne	r2,zero,80557c <xTaskGenericNotifyFromISR+0x108>
  8054e4:	e0bffe17 	ldw	r2,-8(fp)
  8054e8:	100690ba 	slli	r3,r2,2
  8054ec:	00802034 	movhi	r2,128
  8054f0:	10954004 	addi	r2,r2,21760
  8054f4:	1885883a 	add	r2,r3,r2
  8054f8:	10800017 	ldw	r2,0(r2)
  8054fc:	1000683a 	jmp	r2
  805500:	00805584 	movi	r2,342
  805504:	00805514 	movui	r2,340
  805508:	00805530 	cmpltui	r2,zero,340
  80550c:	00805548 	cmpgei	r2,zero,341
  805510:	00805558 	cmpnei	r2,zero,341
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
  805514:	e0bff917 	ldw	r2,-28(fp)
  805518:	10c01217 	ldw	r3,72(r2)
  80551c:	e0bffd17 	ldw	r2,-12(fp)
  805520:	1886b03a 	or	r3,r3,r2
  805524:	e0bff917 	ldw	r2,-28(fp)
  805528:	10c01215 	stw	r3,72(r2)
					break;
  80552c:	00001606 	br	805588 <xTaskGenericNotifyFromISR+0x114>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
  805530:	e0bff917 	ldw	r2,-28(fp)
  805534:	10801217 	ldw	r2,72(r2)
  805538:	10c00044 	addi	r3,r2,1
  80553c:	e0bff917 	ldw	r2,-28(fp)
  805540:	10c01215 	stw	r3,72(r2)
					break;
  805544:	00001006 	br	805588 <xTaskGenericNotifyFromISR+0x114>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
  805548:	e0bff917 	ldw	r2,-28(fp)
  80554c:	e0fffd17 	ldw	r3,-12(fp)
  805550:	10c01215 	stw	r3,72(r2)
					break;
  805554:	00000c06 	br	805588 <xTaskGenericNotifyFromISR+0x114>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
  805558:	e0bffb03 	ldbu	r2,-20(fp)
  80555c:	108000a0 	cmpeqi	r2,r2,2
  805560:	1000041e 	bne	r2,zero,805574 <xTaskGenericNotifyFromISR+0x100>
					{
						pxTCB->ulNotifiedValue = ulValue;
  805564:	e0bff917 	ldw	r2,-28(fp)
  805568:	e0fffd17 	ldw	r3,-12(fp)
  80556c:	10c01215 	stw	r3,72(r2)
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
  805570:	00000506 	br	805588 <xTaskGenericNotifyFromISR+0x114>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
  805574:	e03ff815 	stw	zero,-32(fp)
					}
					break;
  805578:	00000306 	br	805588 <xTaskGenericNotifyFromISR+0x114>
				default:
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
					break;
  80557c:	0001883a 	nop
  805580:	00000106 	br	805588 <xTaskGenericNotifyFromISR+0x114>
					break;

				case eNoAction :
					/* The task is being notified without its notify value being
					updated. */
					break;
  805584:	0001883a 	nop

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
  805588:	e0bffb03 	ldbu	r2,-20(fp)
  80558c:	10800058 	cmpnei	r2,r2,1
  805590:	10002b1e 	bne	r2,zero,805640 <xTaskGenericNotifyFromISR+0x1cc>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  805594:	d0a51317 	ldw	r2,-27572(gp)
  805598:	1000171e 	bne	r2,zero,8055f8 <xTaskGenericNotifyFromISR+0x184>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  80559c:	e0bff917 	ldw	r2,-28(fp)
  8055a0:	10800104 	addi	r2,r2,4
  8055a4:	1009883a 	mov	r4,r2
  8055a8:	0800b980 	call	800b98 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
  8055ac:	e0bff917 	ldw	r2,-28(fp)
  8055b0:	10800b17 	ldw	r2,44(r2)
  8055b4:	d0e50b17 	ldw	r3,-27604(gp)
  8055b8:	1880032e 	bgeu	r3,r2,8055c8 <xTaskGenericNotifyFromISR+0x154>
  8055bc:	e0bff917 	ldw	r2,-28(fp)
  8055c0:	10800b17 	ldw	r2,44(r2)
  8055c4:	d0a50b15 	stw	r2,-27604(gp)
  8055c8:	e0bff917 	ldw	r2,-28(fp)
  8055cc:	10800b17 	ldw	r2,44(r2)
  8055d0:	10c00524 	muli	r3,r2,20
  8055d4:	00802174 	movhi	r2,133
  8055d8:	10a41e04 	addi	r2,r2,-28552
  8055dc:	1887883a 	add	r3,r3,r2
  8055e0:	e0bff917 	ldw	r2,-28(fp)
  8055e4:	10800104 	addi	r2,r2,4
  8055e8:	100b883a 	mov	r5,r2
  8055ec:	1809883a 	mov	r4,r3
  8055f0:	0800a340 	call	800a34 <vListInsertEnd>
  8055f4:	00000606 	br	805610 <xTaskGenericNotifyFromISR+0x19c>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
  8055f8:	e0bff917 	ldw	r2,-28(fp)
  8055fc:	10800604 	addi	r2,r2,24
  805600:	100b883a 	mov	r5,r2
  805604:	01002174 	movhi	r4,133
  805608:	21244104 	addi	r4,r4,-28412
  80560c:	0800a340 	call	800a34 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
  805610:	e0bff917 	ldw	r2,-28(fp)
  805614:	10800b17 	ldw	r2,44(r2)
  805618:	d0e50517 	ldw	r3,-27628(gp)
  80561c:	18c00b17 	ldw	r3,44(r3)
  805620:	1880072e 	bgeu	r3,r2,805640 <xTaskGenericNotifyFromISR+0x1cc>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
  805624:	e0800217 	ldw	r2,8(fp)
  805628:	10000326 	beq	r2,zero,805638 <xTaskGenericNotifyFromISR+0x1c4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
  80562c:	e0800217 	ldw	r2,8(fp)
  805630:	00c00044 	movi	r3,1
  805634:	10c00015 	stw	r3,0(r2)
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
  805638:	00800044 	movi	r2,1
  80563c:	d0a50e15 	stw	r2,-27592(gp)
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
  805640:	e0bff817 	ldw	r2,-32(fp)
	}
  805644:	e037883a 	mov	sp,fp
  805648:	dfc00117 	ldw	ra,4(sp)
  80564c:	df000017 	ldw	fp,0(sp)
  805650:	dec00204 	addi	sp,sp,8
  805654:	f800283a 	ret

00805658 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
  805658:	defff904 	addi	sp,sp,-28
  80565c:	dfc00615 	stw	ra,24(sp)
  805660:	df000515 	stw	fp,20(sp)
  805664:	df000504 	addi	fp,sp,20
  805668:	e13ffe15 	stw	r4,-8(fp)
  80566c:	e17fff15 	stw	r5,-4(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
  805670:	e0bffe17 	ldw	r2,-8(fp)
  805674:	e0bffb15 	stw	r2,-20(fp)

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  805678:	e03ffc15 	stw	zero,-16(fp)
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
  80567c:	e0bffb17 	ldw	r2,-20(fp)
  805680:	10801303 	ldbu	r2,76(r2)
  805684:	e0bffd05 	stb	r2,-12(fp)
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
  805688:	e0bffb17 	ldw	r2,-20(fp)
  80568c:	00c00084 	movi	r3,2
  805690:	10c01305 	stb	r3,76(r2)

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
  805694:	e0bffb17 	ldw	r2,-20(fp)
  805698:	10801217 	ldw	r2,72(r2)
  80569c:	10c00044 	addi	r3,r2,1
  8056a0:	e0bffb17 	ldw	r2,-20(fp)
  8056a4:	10c01215 	stw	r3,72(r2)

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
  8056a8:	e0bffd03 	ldbu	r2,-12(fp)
  8056ac:	10800058 	cmpnei	r2,r2,1
  8056b0:	10002b1e 	bne	r2,zero,805760 <vTaskNotifyGiveFromISR+0x108>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  8056b4:	d0a51317 	ldw	r2,-27572(gp)
  8056b8:	1000171e 	bne	r2,zero,805718 <vTaskNotifyGiveFromISR+0xc0>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  8056bc:	e0bffb17 	ldw	r2,-20(fp)
  8056c0:	10800104 	addi	r2,r2,4
  8056c4:	1009883a 	mov	r4,r2
  8056c8:	0800b980 	call	800b98 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
  8056cc:	e0bffb17 	ldw	r2,-20(fp)
  8056d0:	10800b17 	ldw	r2,44(r2)
  8056d4:	d0e50b17 	ldw	r3,-27604(gp)
  8056d8:	1880032e 	bgeu	r3,r2,8056e8 <vTaskNotifyGiveFromISR+0x90>
  8056dc:	e0bffb17 	ldw	r2,-20(fp)
  8056e0:	10800b17 	ldw	r2,44(r2)
  8056e4:	d0a50b15 	stw	r2,-27604(gp)
  8056e8:	e0bffb17 	ldw	r2,-20(fp)
  8056ec:	10800b17 	ldw	r2,44(r2)
  8056f0:	10c00524 	muli	r3,r2,20
  8056f4:	00802174 	movhi	r2,133
  8056f8:	10a41e04 	addi	r2,r2,-28552
  8056fc:	1887883a 	add	r3,r3,r2
  805700:	e0bffb17 	ldw	r2,-20(fp)
  805704:	10800104 	addi	r2,r2,4
  805708:	100b883a 	mov	r5,r2
  80570c:	1809883a 	mov	r4,r3
  805710:	0800a340 	call	800a34 <vListInsertEnd>
  805714:	00000606 	br	805730 <vTaskNotifyGiveFromISR+0xd8>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
  805718:	e0bffb17 	ldw	r2,-20(fp)
  80571c:	10800604 	addi	r2,r2,24
  805720:	100b883a 	mov	r5,r2
  805724:	01002174 	movhi	r4,133
  805728:	21244104 	addi	r4,r4,-28412
  80572c:	0800a340 	call	800a34 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
  805730:	e0bffb17 	ldw	r2,-20(fp)
  805734:	10800b17 	ldw	r2,44(r2)
  805738:	d0e50517 	ldw	r3,-27628(gp)
  80573c:	18c00b17 	ldw	r3,44(r3)
  805740:	1880072e 	bgeu	r3,r2,805760 <vTaskNotifyGiveFromISR+0x108>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
  805744:	e0bfff17 	ldw	r2,-4(fp)
  805748:	10000326 	beq	r2,zero,805758 <vTaskNotifyGiveFromISR+0x100>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
  80574c:	e0bfff17 	ldw	r2,-4(fp)
  805750:	00c00044 	movi	r3,1
  805754:	10c00015 	stw	r3,0(r2)
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
  805758:	00800044 	movi	r2,1
  80575c:	d0a50e15 	stw	r2,-27592(gp)
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
  805760:	0001883a 	nop
  805764:	e037883a 	mov	sp,fp
  805768:	dfc00117 	ldw	ra,4(sp)
  80576c:	df000017 	ldw	fp,0(sp)
  805770:	dec00204 	addi	sp,sp,8
  805774:	f800283a 	ret

00805778 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
  805778:	defffb04 	addi	sp,sp,-20
  80577c:	dfc00415 	stw	ra,16(sp)
  805780:	df000315 	stw	fp,12(sp)
  805784:	df000304 	addi	fp,sp,12
  805788:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
  80578c:	e0bfff17 	ldw	r2,-4(fp)
  805790:	1000021e 	bne	r2,zero,80579c <xTaskNotifyStateClear+0x24>
  805794:	d0a50517 	ldw	r2,-27628(gp)
  805798:	00000106 	br	8057a0 <xTaskNotifyStateClear+0x28>
  80579c:	e0bfff17 	ldw	r2,-4(fp)
  8057a0:	e0bffe15 	stw	r2,-8(fp)

		taskENTER_CRITICAL();
  8057a4:	0804ff40 	call	804ff4 <vTaskEnterCritical>
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
  8057a8:	e0bffe17 	ldw	r2,-8(fp)
  8057ac:	10801303 	ldbu	r2,76(r2)
  8057b0:	10803fcc 	andi	r2,r2,255
  8057b4:	10800098 	cmpnei	r2,r2,2
  8057b8:	1000051e 	bne	r2,zero,8057d0 <xTaskNotifyStateClear+0x58>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
  8057bc:	e0bffe17 	ldw	r2,-8(fp)
  8057c0:	10001305 	stb	zero,76(r2)
				xReturn = pdPASS;
  8057c4:	00800044 	movi	r2,1
  8057c8:	e0bffd15 	stw	r2,-12(fp)
  8057cc:	00000106 	br	8057d4 <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
  8057d0:	e03ffd15 	stw	zero,-12(fp)
			}
		}
		taskEXIT_CRITICAL();
  8057d4:	08050480 	call	805048 <vTaskExitCritical>

		return xReturn;
  8057d8:	e0bffd17 	ldw	r2,-12(fp)
	}
  8057dc:	e037883a 	mov	sp,fp
  8057e0:	dfc00117 	ldw	ra,4(sp)
  8057e4:	df000017 	ldw	fp,0(sp)
  8057e8:	dec00204 	addi	sp,sp,8
  8057ec:	f800283a 	ret

008057f0 <ulTaskNotifyValueClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyValueClear( TaskHandle_t xTask, uint32_t ulBitsToClear )
	{
  8057f0:	defffa04 	addi	sp,sp,-24
  8057f4:	dfc00515 	stw	ra,20(sp)
  8057f8:	df000415 	stw	fp,16(sp)
  8057fc:	df000404 	addi	fp,sp,16
  805800:	e13ffe15 	stw	r4,-8(fp)
  805804:	e17fff15 	stw	r5,-4(fp)
	TCB_t *pxTCB;
	uint32_t ulReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
  805808:	e0bffe17 	ldw	r2,-8(fp)
  80580c:	1000021e 	bne	r2,zero,805818 <ulTaskNotifyValueClear+0x28>
  805810:	d0a50517 	ldw	r2,-27628(gp)
  805814:	00000106 	br	80581c <ulTaskNotifyValueClear+0x2c>
  805818:	e0bffe17 	ldw	r2,-8(fp)
  80581c:	e0bffc15 	stw	r2,-16(fp)

		taskENTER_CRITICAL();
  805820:	0804ff40 	call	804ff4 <vTaskEnterCritical>
		{
			/* Return the notification as it was before the bits were cleared,
			then clear the bit mask. */
			ulReturn = pxCurrentTCB->ulNotifiedValue;
  805824:	d0a50517 	ldw	r2,-27628(gp)
  805828:	10801217 	ldw	r2,72(r2)
  80582c:	e0bffd15 	stw	r2,-12(fp)
			pxTCB->ulNotifiedValue &= ~ulBitsToClear;
  805830:	e0bffc17 	ldw	r2,-16(fp)
  805834:	10c01217 	ldw	r3,72(r2)
  805838:	e0bfff17 	ldw	r2,-4(fp)
  80583c:	0084303a 	nor	r2,zero,r2
  805840:	1886703a 	and	r3,r3,r2
  805844:	e0bffc17 	ldw	r2,-16(fp)
  805848:	10c01215 	stw	r3,72(r2)
		}
		taskEXIT_CRITICAL();
  80584c:	08050480 	call	805048 <vTaskExitCritical>

		return ulReturn;
  805850:	e0bffd17 	ldw	r2,-12(fp)
	}
  805854:	e037883a 	mov	sp,fp
  805858:	dfc00117 	ldw	ra,4(sp)
  80585c:	df000017 	ldw	fp,0(sp)
  805860:	dec00204 	addi	sp,sp,8
  805864:	f800283a 	ret

00805868 <prvAddCurrentTaskToDelayedList>:

#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
  805868:	defffa04 	addi	sp,sp,-24
  80586c:	dfc00515 	stw	ra,20(sp)
  805870:	df000415 	stw	fp,16(sp)
  805874:	df000404 	addi	fp,sp,16
  805878:	e13ffe15 	stw	r4,-8(fp)
  80587c:	e17fff15 	stw	r5,-4(fp)
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
  805880:	d0a50a17 	ldw	r2,-27608(gp)
  805884:	e0bffc15 	stw	r2,-16(fp)
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  805888:	d0a50517 	ldw	r2,-27628(gp)
  80588c:	10800104 	addi	r2,r2,4
  805890:	1009883a 	mov	r4,r2
  805894:	0800b980 	call	800b98 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
  805898:	e0bffe17 	ldw	r2,-8(fp)
  80589c:	10bfffd8 	cmpnei	r2,r2,-1
  8058a0:	1000091e 	bne	r2,zero,8058c8 <prvAddCurrentTaskToDelayedList+0x60>
  8058a4:	e0bfff17 	ldw	r2,-4(fp)
  8058a8:	10000726 	beq	r2,zero,8058c8 <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
  8058ac:	d0a50517 	ldw	r2,-27628(gp)
  8058b0:	10800104 	addi	r2,r2,4
  8058b4:	100b883a 	mov	r5,r2
  8058b8:	01002174 	movhi	r4,133
  8058bc:	21244b04 	addi	r4,r4,-28372
  8058c0:	0800a340 	call	800a34 <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
  8058c4:	00001c06 	br	805938 <prvAddCurrentTaskToDelayedList+0xd0>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
  8058c8:	e0fffc17 	ldw	r3,-16(fp)
  8058cc:	e0bffe17 	ldw	r2,-8(fp)
  8058d0:	1885883a 	add	r2,r3,r2
  8058d4:	e0bffd15 	stw	r2,-12(fp)

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
  8058d8:	d0a50517 	ldw	r2,-27628(gp)
  8058dc:	e0fffd17 	ldw	r3,-12(fp)
  8058e0:	10c00115 	stw	r3,4(r2)

			if( xTimeToWake < xConstTickCount )
  8058e4:	e0fffd17 	ldw	r3,-12(fp)
  8058e8:	e0bffc17 	ldw	r2,-16(fp)
  8058ec:	1880072e 	bgeu	r3,r2,80590c <prvAddCurrentTaskToDelayedList+0xa4>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
  8058f0:	d0e50717 	ldw	r3,-27620(gp)
  8058f4:	d0a50517 	ldw	r2,-27628(gp)
  8058f8:	10800104 	addi	r2,r2,4
  8058fc:	100b883a 	mov	r5,r2
  805900:	1809883a 	mov	r4,r3
  805904:	0800ac00 	call	800ac0 <vListInsert>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
  805908:	00000b06 	br	805938 <prvAddCurrentTaskToDelayedList+0xd0>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
  80590c:	d0e50617 	ldw	r3,-27624(gp)
  805910:	d0a50517 	ldw	r2,-27628(gp)
  805914:	10800104 	addi	r2,r2,4
  805918:	100b883a 	mov	r5,r2
  80591c:	1809883a 	mov	r4,r3
  805920:	0800ac00 	call	800ac0 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
  805924:	d0a51117 	ldw	r2,-27580(gp)
  805928:	e0fffd17 	ldw	r3,-12(fp)
  80592c:	1880022e 	bgeu	r3,r2,805938 <prvAddCurrentTaskToDelayedList+0xd0>
				{
					xNextTaskUnblockTime = xTimeToWake;
  805930:	e0bffd17 	ldw	r2,-12(fp)
  805934:	d0a51115 	stw	r2,-27580(gp)

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
  805938:	0001883a 	nop
  80593c:	e037883a 	mov	sp,fp
  805940:	dfc00117 	ldw	ra,4(sp)
  805944:	df000017 	ldw	fp,0(sp)
  805948:	dec00204 	addi	sp,sp,8
  80594c:	f800283a 	ret

00805950 <set_output>:
char rus_letter_mas[] = "";
//char rus_letter_mas[] = {'', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '','', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''};
//char rus_letter_mas[] = {"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "","", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""};

static void set_output(const bool output)
{
  805950:	defffe04 	addi	sp,sp,-8
  805954:	df000115 	stw	fp,4(sp)
  805958:	df000104 	addi	fp,sp,4
  80595c:	e13fff15 	stw	r4,-4(fp)

	IOWR_ALTERA_AVALON_PIO_DIRECTION(LCD_DATA_BASE, 0);
  805960:	0007883a 	mov	r3,zero
  805964:	00804434 	movhi	r2,272
  805968:	10841904 	addi	r2,r2,4196
  80596c:	10c00035 	stwio	r3,0(r2)
	if (output)
  805970:	e0bfff17 	ldw	r2,-4(fp)
  805974:	10000426 	beq	r2,zero,805988 <set_output+0x38>
		IOWR_ALTERA_AVALON_PIO_DIRECTION(LCD_DATA_BASE, 0xFF);
  805978:	00c03fc4 	movi	r3,255
  80597c:	00804434 	movhi	r2,272
  805980:	10841904 	addi	r2,r2,4196
  805984:	10c00035 	stwio	r3,0(r2)
}
  805988:	0001883a 	nop
  80598c:	e037883a 	mov	sp,fp
  805990:	df000017 	ldw	fp,0(sp)
  805994:	dec00104 	addi	sp,sp,4
  805998:	f800283a 	ret

0080599c <enable>:

static void enable(const bool pulse)
{
  80599c:	defffd04 	addi	sp,sp,-12
  8059a0:	dfc00215 	stw	ra,8(sp)
  8059a4:	df000115 	stw	fp,4(sp)
  8059a8:	df000104 	addi	fp,sp,4
  8059ac:	e13fff15 	stw	r4,-4(fp)
	if (pulse)
  8059b0:	e0bfff17 	ldw	r2,-4(fp)
  8059b4:	10000626 	beq	r2,zero,8059d0 <enable+0x34>
	{
		IOWR_ALTERA_AVALON_PIO_DATA(LCD_E_BASE, 0x01);
  8059b8:	00c00044 	movi	r3,1
  8059bc:	00804434 	movhi	r2,272
  8059c0:	10840c04 	addi	r2,r2,4144
  8059c4:	10c00035 	stwio	r3,0(r2)
		vTaskDelay(1);
  8059c8:	01000044 	movi	r4,1
  8059cc:	0803a040 	call	803a04 <vTaskDelay>
	}
	IOWR_ALTERA_AVALON_PIO_DATA(LCD_E_BASE, 0);
  8059d0:	0007883a 	mov	r3,zero
  8059d4:	00804434 	movhi	r2,272
  8059d8:	10840c04 	addi	r2,r2,4144
  8059dc:	10c00035 	stwio	r3,0(r2)
	vTaskDelay(1);
  8059e0:	01000044 	movi	r4,1
  8059e4:	0803a040 	call	803a04 <vTaskDelay>
}
  8059e8:	0001883a 	nop
  8059ec:	e037883a 	mov	sp,fp
  8059f0:	dfc00117 	ldw	ra,4(sp)
  8059f4:	df000017 	ldw	fp,0(sp)
  8059f8:	dec00204 	addi	sp,sp,8
  8059fc:	f800283a 	ret

00805a00 <read_busy>:

static bool read_busy(void)
{
  805a00:	defffd04 	addi	sp,sp,-12
  805a04:	dfc00215 	stw	ra,8(sp)
  805a08:	df000115 	stw	fp,4(sp)
  805a0c:	df000104 	addi	fp,sp,4
	alt_u8 data;

	set_output(FALSE);
  805a10:	0009883a 	mov	r4,zero
  805a14:	08059500 	call	805950 <set_output>
	IOWR_ALTERA_AVALON_PIO_DATA(LCD_RS_BASE, 0);
  805a18:	0007883a 	mov	r3,zero
  805a1c:	00804434 	movhi	r2,272
  805a20:	10841404 	addi	r2,r2,4176
  805a24:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_AVALON_PIO_DATA(LCD_RW_BASE, 0x01);
  805a28:	00c00044 	movi	r3,1
  805a2c:	00804434 	movhi	r2,272
  805a30:	10841004 	addi	r2,r2,4160
  805a34:	10c00035 	stwio	r3,0(r2)
	enable(FALSE);
  805a38:	0009883a 	mov	r4,zero
  805a3c:	080599c0 	call	80599c <enable>
	data = IORD_ALTERA_AVALON_PIO_DATA(LCD_DATA_BASE);
  805a40:	00804434 	movhi	r2,272
  805a44:	10841804 	addi	r2,r2,4192
  805a48:	10800037 	ldwio	r2,0(r2)
  805a4c:	e0bfff05 	stb	r2,-4(fp)
	enable(FALSE);
  805a50:	0009883a 	mov	r4,zero
  805a54:	080599c0 	call	80599c <enable>
	enable(TRUE);
  805a58:	01000044 	movi	r4,1
  805a5c:	080599c0 	call	80599c <enable>

	if (data >> 7 == 1)
  805a60:	e0bfff03 	ldbu	r2,-4(fp)
  805a64:	1004d1fa 	srli	r2,r2,7
  805a68:	10803fcc 	andi	r2,r2,255
  805a6c:	10800058 	cmpnei	r2,r2,1
  805a70:	1000021e 	bne	r2,zero,805a7c <read_busy+0x7c>
		return (TRUE);
  805a74:	00800044 	movi	r2,1
  805a78:	00000106 	br	805a80 <read_busy+0x80>

	return (FALSE);
  805a7c:	0005883a 	mov	r2,zero

}
  805a80:	e037883a 	mov	sp,fp
  805a84:	dfc00117 	ldw	ra,4(sp)
  805a88:	df000017 	ldw	fp,0(sp)
  805a8c:	dec00204 	addi	sp,sp,8
  805a90:	f800283a 	ret

00805a94 <hd44780_write>:

static void hd44780_write(const alt_u8 data, const bool reg)
{
  805a94:	defffc04 	addi	sp,sp,-16
  805a98:	dfc00315 	stw	ra,12(sp)
  805a9c:	df000215 	stw	fp,8(sp)
  805aa0:	df000204 	addi	fp,sp,8
  805aa4:	2005883a 	mov	r2,r4
  805aa8:	e17fff15 	stw	r5,-4(fp)
  805aac:	e0bffe05 	stb	r2,-8(fp)
	set_output(TRUE);
  805ab0:	01000044 	movi	r4,1
  805ab4:	08059500 	call	805950 <set_output>
	//alt_putstr("set_output TRUE\n");
	
	IOWR_ALTERA_AVALON_PIO_DATA(LCD_RW_BASE, 0);
  805ab8:	0007883a 	mov	r3,zero
  805abc:	00804434 	movhi	r2,272
  805ac0:	10841004 	addi	r2,r2,4160
  805ac4:	10c00035 	stwio	r3,0(r2)
	//alt_putstr("RW 0\n");
	IOWR_ALTERA_AVALON_PIO_DATA(LCD_RS_BASE, reg);
  805ac8:	00804434 	movhi	r2,272
  805acc:	10841404 	addi	r2,r2,4176
  805ad0:	e0ffff17 	ldw	r3,-4(fp)
  805ad4:	10c00035 	stwio	r3,0(r2)
	//alt_putstr("RS installed\n");
	
	if (MODE_8_OR_4 == 8) IOWR_ALTERA_AVALON_PIO_DATA(LCD_DATA_BASE, data);
  805ad8:	e0fffe03 	ldbu	r3,-8(fp)
  805adc:	00804434 	movhi	r2,272
  805ae0:	10841804 	addi	r2,r2,4192
  805ae4:	10c00035 	stwio	r3,0(r2)
	else IOWR_ALTERA_AVALON_PIO_DATA(LCD_DATA_BASE, data << 4);
	//alt_putstr("data installed\n");
	
	enable(TRUE);
  805ae8:	01000044 	movi	r4,1
  805aec:	080599c0 	call	80599c <enable>
	//alt_putstr("enable\n");
	while(!read_busy());
  805af0:	0001883a 	nop
  805af4:	0805a000 	call	805a00 <read_busy>
  805af8:	103ffe26 	beq	r2,zero,805af4 <__alt_mem_onchip_memory2_0+0xff785af4>
}
  805afc:	0001883a 	nop
  805b00:	e037883a 	mov	sp,fp
  805b04:	dfc00117 	ldw	ra,4(sp)
  805b08:	df000017 	ldw	fp,0(sp)
  805b0c:	dec00204 	addi	sp,sp,8
  805b10:	f800283a 	ret

00805b14 <hd44780_clear>:

/**
 * Clear the LCD
 */
void hd44780_clear(xQueueHandle Queue_lcd_data, xQueueHandle Queue_lcd_rs, xSemaphoreHandle Mutex_write_lcd)
{
  805b14:	defff904 	addi	sp,sp,-28
  805b18:	dfc00615 	stw	ra,24(sp)
  805b1c:	df000515 	stw	fp,20(sp)
  805b20:	df000504 	addi	fp,sp,20
  805b24:	e13ffd15 	stw	r4,-12(fp)
  805b28:	e17ffe15 	stw	r5,-8(fp)
  805b2c:	e1bfff15 	stw	r6,-4(fp)
	int data = 0x01;
  805b30:	00800044 	movi	r2,1
  805b34:	e0bffb15 	stw	r2,-20(fp)
	int rs = 0;
  805b38:	e03ffc15 	stw	zero,-16(fp)
	if( xSemaphoreTake( Mutex_write_lcd, portMAX_DELAY ) == pdTRUE )
  805b3c:	017fffc4 	movi	r5,-1
  805b40:	e13fff17 	ldw	r4,-4(fp)
  805b44:	0801aec0 	call	801aec <xQueueSemaphoreTake>
  805b48:	10800058 	cmpnei	r2,r2,1
  805b4c:	1000101e 	bne	r2,zero,805b90 <hd44780_clear+0x7c>
	{
		xQueueSendToBack(Queue_lcd_data, &data, portMAX_DELAY);
  805b50:	000f883a 	mov	r7,zero
  805b54:	01bfffc4 	movi	r6,-1
  805b58:	e17ffb04 	addi	r5,fp,-20
  805b5c:	e13ffd17 	ldw	r4,-12(fp)
  805b60:	08015c00 	call	8015c0 <xQueueGenericSend>
		xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
  805b64:	e0bffc04 	addi	r2,fp,-16
  805b68:	000f883a 	mov	r7,zero
  805b6c:	01bfffc4 	movi	r6,-1
  805b70:	100b883a 	mov	r5,r2
  805b74:	e13ffe17 	ldw	r4,-8(fp)
  805b78:	08015c00 	call	8015c0 <xQueueGenericSend>
		xSemaphoreGive( Mutex_write_lcd );
  805b7c:	000f883a 	mov	r7,zero
  805b80:	000d883a 	mov	r6,zero
  805b84:	000b883a 	mov	r5,zero
  805b88:	e13fff17 	ldw	r4,-4(fp)
  805b8c:	08015c00 	call	8015c0 <xQueueGenericSend>
	}
}
  805b90:	0001883a 	nop
  805b94:	e037883a 	mov	sp,fp
  805b98:	dfc00117 	ldw	ra,4(sp)
  805b9c:	df000017 	ldw	fp,0(sp)
  805ba0:	dec00204 	addi	sp,sp,8
  805ba4:	f800283a 	ret

00805ba8 <hd44780_home>:

/**
 * Move cursor home
 */
void hd44780_home(xQueueHandle Queue_lcd_data, xQueueHandle Queue_lcd_rs, xSemaphoreHandle Mutex_write_lcd)
{
  805ba8:	defff904 	addi	sp,sp,-28
  805bac:	dfc00615 	stw	ra,24(sp)
  805bb0:	df000515 	stw	fp,20(sp)
  805bb4:	df000504 	addi	fp,sp,20
  805bb8:	e13ffd15 	stw	r4,-12(fp)
  805bbc:	e17ffe15 	stw	r5,-8(fp)
  805bc0:	e1bfff15 	stw	r6,-4(fp)
	int data = 0x02;
  805bc4:	00800084 	movi	r2,2
  805bc8:	e0bffb15 	stw	r2,-20(fp)
	int rs = 0;
  805bcc:	e03ffc15 	stw	zero,-16(fp)
	if( xSemaphoreTake( Mutex_write_lcd, portMAX_DELAY ) == pdTRUE )
  805bd0:	017fffc4 	movi	r5,-1
  805bd4:	e13fff17 	ldw	r4,-4(fp)
  805bd8:	0801aec0 	call	801aec <xQueueSemaphoreTake>
  805bdc:	10800058 	cmpnei	r2,r2,1
  805be0:	1000101e 	bne	r2,zero,805c24 <hd44780_home+0x7c>
	{
		xQueueSendToBack(Queue_lcd_data, &data, portMAX_DELAY);
  805be4:	000f883a 	mov	r7,zero
  805be8:	01bfffc4 	movi	r6,-1
  805bec:	e17ffb04 	addi	r5,fp,-20
  805bf0:	e13ffd17 	ldw	r4,-12(fp)
  805bf4:	08015c00 	call	8015c0 <xQueueGenericSend>
		xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
  805bf8:	e0bffc04 	addi	r2,fp,-16
  805bfc:	000f883a 	mov	r7,zero
  805c00:	01bfffc4 	movi	r6,-1
  805c04:	100b883a 	mov	r5,r2
  805c08:	e13ffe17 	ldw	r4,-8(fp)
  805c0c:	08015c00 	call	8015c0 <xQueueGenericSend>
		xSemaphoreGive( Mutex_write_lcd );
  805c10:	000f883a 	mov	r7,zero
  805c14:	000d883a 	mov	r6,zero
  805c18:	000b883a 	mov	r5,zero
  805c1c:	e13fff17 	ldw	r4,-4(fp)
  805c20:	08015c00 	call	8015c0 <xQueueGenericSend>
	}
}
  805c24:	0001883a 	nop
  805c28:	e037883a 	mov	sp,fp
  805c2c:	dfc00117 	ldw	ra,4(sp)
  805c30:	df000017 	ldw	fp,0(sp)
  805c34:	dec00204 	addi	sp,sp,8
  805c38:	f800283a 	ret

00805c3c <hd44780_display>:
 * @param cursor	Cursor on/off
 * @param blink		Blinking cursor on/off
 *
 */
void hd44780_display(xQueueHandle Queue_lcd_data, xQueueHandle Queue_lcd_rs, xSemaphoreHandle Mutex_write_lcd, const bool enable, const bool cursor, const bool blink)
{
  805c3c:	defff804 	addi	sp,sp,-32
  805c40:	dfc00715 	stw	ra,28(sp)
  805c44:	df000615 	stw	fp,24(sp)
  805c48:	df000604 	addi	fp,sp,24
  805c4c:	e13ffc15 	stw	r4,-16(fp)
  805c50:	e17ffd15 	stw	r5,-12(fp)
  805c54:	e1bffe15 	stw	r6,-8(fp)
  805c58:	e1ffff15 	stw	r7,-4(fp)
	alt_u16 command = HD44780_DISPLAY;
  805c5c:	00800204 	movi	r2,8
  805c60:	e0bffa0d 	sth	r2,-24(fp)

	if (enable)
  805c64:	e0bfff17 	ldw	r2,-4(fp)
  805c68:	10000326 	beq	r2,zero,805c78 <hd44780_display+0x3c>
		command |= HD44780_DISPLAY_ON;
  805c6c:	e0bffa0b 	ldhu	r2,-24(fp)
  805c70:	10800114 	ori	r2,r2,4
  805c74:	e0bffa0d 	sth	r2,-24(fp)
	/*else
  {
		Queue_Head = Queue_Tail = 0;
	}*/
	if (cursor)
  805c78:	e0800217 	ldw	r2,8(fp)
  805c7c:	10000326 	beq	r2,zero,805c8c <hd44780_display+0x50>
		command |= HD44780_CURSOR_ON;
  805c80:	e0bffa0b 	ldhu	r2,-24(fp)
  805c84:	10800094 	ori	r2,r2,2
  805c88:	e0bffa0d 	sth	r2,-24(fp)
	if (blink)
  805c8c:	e0800317 	ldw	r2,12(fp)
  805c90:	10000326 	beq	r2,zero,805ca0 <hd44780_display+0x64>
		command |= HD44780_BLINK_ON;
  805c94:	e0bffa0b 	ldhu	r2,-24(fp)
  805c98:	10800054 	ori	r2,r2,1
  805c9c:	e0bffa0d 	sth	r2,-24(fp)

	int rs = 0;
  805ca0:	e03ffb15 	stw	zero,-20(fp)
	if( xSemaphoreTake( Mutex_write_lcd, portMAX_DELAY ) == pdTRUE )
  805ca4:	017fffc4 	movi	r5,-1
  805ca8:	e13ffe17 	ldw	r4,-8(fp)
  805cac:	0801aec0 	call	801aec <xQueueSemaphoreTake>
  805cb0:	10800058 	cmpnei	r2,r2,1
  805cb4:	1000101e 	bne	r2,zero,805cf8 <hd44780_display+0xbc>
	{
		xQueueSendToBack(Queue_lcd_data, &command, portMAX_DELAY);
  805cb8:	000f883a 	mov	r7,zero
  805cbc:	01bfffc4 	movi	r6,-1
  805cc0:	e17ffa04 	addi	r5,fp,-24
  805cc4:	e13ffc17 	ldw	r4,-16(fp)
  805cc8:	08015c00 	call	8015c0 <xQueueGenericSend>
		xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
  805ccc:	e0bffb04 	addi	r2,fp,-20
  805cd0:	000f883a 	mov	r7,zero
  805cd4:	01bfffc4 	movi	r6,-1
  805cd8:	100b883a 	mov	r5,r2
  805cdc:	e13ffd17 	ldw	r4,-12(fp)
  805ce0:	08015c00 	call	8015c0 <xQueueGenericSend>
		xSemaphoreGive( Mutex_write_lcd );
  805ce4:	000f883a 	mov	r7,zero
  805ce8:	000d883a 	mov	r6,zero
  805cec:	000b883a 	mov	r5,zero
  805cf0:	e13ffe17 	ldw	r4,-8(fp)
  805cf4:	08015c00 	call	8015c0 <xQueueGenericSend>
	}
}
  805cf8:	0001883a 	nop
  805cfc:	e037883a 	mov	sp,fp
  805d00:	dfc00117 	ldw	ra,4(sp)
  805d04:	df000017 	ldw	fp,0(sp)
  805d08:	dec00204 	addi	sp,sp,8
  805d0c:	f800283a 	ret

00805d10 <hd44780_position>:
 *
 * @param row	Row
 * @param col	Column
 */
void hd44780_position(xQueueHandle Queue_lcd_data, xQueueHandle Queue_lcd_rs, xSemaphoreHandle Mutex_write_lcd, const alt_u8 row, const alt_u8 col)
{
  805d10:	defff604 	addi	sp,sp,-40
  805d14:	dfc00915 	stw	ra,36(sp)
  805d18:	df000815 	stw	fp,32(sp)
  805d1c:	df000804 	addi	fp,sp,32
  805d20:	e13ffb15 	stw	r4,-20(fp)
  805d24:	e17ffc15 	stw	r5,-16(fp)
  805d28:	e1bffd15 	stw	r6,-12(fp)
  805d2c:	3807883a 	mov	r3,r7
  805d30:	e0800217 	ldw	r2,8(fp)
  805d34:	e0fffe05 	stb	r3,-8(fp)
  805d38:	e0bfff05 	stb	r2,-4(fp)
	alt_u16 command = HD44780_DGRAM;
  805d3c:	00802004 	movi	r2,128
  805d40:	e0bff80d 	sth	r2,-32(fp)
	const alt_u8 offsets[] = { 0x00, 0x40, 0x14, 0x54 };
  805d44:	e03ff885 	stb	zero,-30(fp)
  805d48:	00801004 	movi	r2,64
  805d4c:	e0bff8c5 	stb	r2,-29(fp)
  805d50:	00800504 	movi	r2,20
  805d54:	e0bff905 	stb	r2,-28(fp)
  805d58:	00801504 	movi	r2,84
  805d5c:	e0bff945 	stb	r2,-27(fp)

	command |= col + offsets[row];
  805d60:	e0ffff03 	ldbu	r3,-4(fp)
  805d64:	e0bffe03 	ldbu	r2,-8(fp)
  805d68:	e13ff884 	addi	r4,fp,-30
  805d6c:	2085883a 	add	r2,r4,r2
  805d70:	10800003 	ldbu	r2,0(r2)
  805d74:	10803fcc 	andi	r2,r2,255
  805d78:	1885883a 	add	r2,r3,r2
  805d7c:	1007883a 	mov	r3,r2
  805d80:	e0bff80b 	ldhu	r2,-32(fp)
  805d84:	1884b03a 	or	r2,r3,r2
  805d88:	e0bff80d 	sth	r2,-32(fp)
	int rs = 0;
  805d8c:	e03ffa15 	stw	zero,-24(fp)
	if( xSemaphoreTake( Mutex_write_lcd, portMAX_DELAY ) == pdTRUE )
  805d90:	017fffc4 	movi	r5,-1
  805d94:	e13ffd17 	ldw	r4,-12(fp)
  805d98:	0801aec0 	call	801aec <xQueueSemaphoreTake>
  805d9c:	10800058 	cmpnei	r2,r2,1
  805da0:	1000101e 	bne	r2,zero,805de4 <hd44780_position+0xd4>
	{
		xQueueSendToBack(Queue_lcd_data, &command, portMAX_DELAY);
  805da4:	000f883a 	mov	r7,zero
  805da8:	01bfffc4 	movi	r6,-1
  805dac:	e17ff804 	addi	r5,fp,-32
  805db0:	e13ffb17 	ldw	r4,-20(fp)
  805db4:	08015c00 	call	8015c0 <xQueueGenericSend>
		xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
  805db8:	e0bffa04 	addi	r2,fp,-24
  805dbc:	000f883a 	mov	r7,zero
  805dc0:	01bfffc4 	movi	r6,-1
  805dc4:	100b883a 	mov	r5,r2
  805dc8:	e13ffc17 	ldw	r4,-16(fp)
  805dcc:	08015c00 	call	8015c0 <xQueueGenericSend>
		xSemaphoreGive( Mutex_write_lcd );
  805dd0:	000f883a 	mov	r7,zero
  805dd4:	000d883a 	mov	r6,zero
  805dd8:	000b883a 	mov	r5,zero
  805ddc:	e13ffd17 	ldw	r4,-12(fp)
  805de0:	08015c00 	call	8015c0 <xQueueGenericSend>
	}
}
  805de4:	0001883a 	nop
  805de8:	e037883a 	mov	sp,fp
  805dec:	dfc00117 	ldw	ra,4(sp)
  805df0:	df000017 	ldw	fp,0(sp)
  805df4:	dec00204 	addi	sp,sp,8
  805df8:	f800283a 	ret

00805dfc <hd44780_cgram>:
 *
 * @param pos	UDG number
 * @param udg	UDG definition
 */
void hd44780_cgram(xQueueHandle Queue_lcd_data, xQueueHandle Queue_lcd_rs, xSemaphoreHandle Mutex_write_lcd, const alt_u8 pos, const char udg[8])
{
  805dfc:	defff804 	addi	sp,sp,-32
  805e00:	dfc00715 	stw	ra,28(sp)
  805e04:	df000615 	stw	fp,24(sp)
  805e08:	df000604 	addi	fp,sp,24
  805e0c:	e13ffc15 	stw	r4,-16(fp)
  805e10:	e17ffd15 	stw	r5,-12(fp)
  805e14:	e1bffe15 	stw	r6,-8(fp)
  805e18:	3805883a 	mov	r2,r7
  805e1c:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 i;
	alt_u16 command = HD44780_CGRAM;
  805e20:	00801004 	movi	r2,64
  805e24:	e0bffa8d 	sth	r2,-22(fp)

	if (pos < 8) alt_putstr("pos cgram failed");
  805e28:	e0bfff03 	ldbu	r2,-4(fp)
  805e2c:	10800228 	cmpgeui	r2,r2,8
  805e30:	1000031e 	bne	r2,zero,805e40 <hd44780_cgram+0x44>
  805e34:	01002074 	movhi	r4,129
  805e38:	21259504 	addi	r4,r4,-27052
  805e3c:	0807a640 	call	807a64 <alt_putstr>

	command |= pos * 8;
  805e40:	e0bfff03 	ldbu	r2,-4(fp)
  805e44:	100490fa 	slli	r2,r2,3
  805e48:	1007883a 	mov	r3,r2
  805e4c:	e0bffa8b 	ldhu	r2,-22(fp)
  805e50:	1884b03a 	or	r2,r3,r2
  805e54:	e0bffa8d 	sth	r2,-22(fp)

	int rs = 0;
  805e58:	e03ffb15 	stw	zero,-20(fp)
	if( xSemaphoreTake( Mutex_write_lcd, portMAX_DELAY ) == pdTRUE )
  805e5c:	017fffc4 	movi	r5,-1
  805e60:	e13ffe17 	ldw	r4,-8(fp)
  805e64:	0801aec0 	call	801aec <xQueueSemaphoreTake>
  805e68:	10800058 	cmpnei	r2,r2,1
  805e6c:	1000291e 	bne	r2,zero,805f14 <hd44780_cgram+0x118>
	{
		xQueueSendToBack(Queue_lcd_data, &command, portMAX_DELAY);
  805e70:	e0bffa84 	addi	r2,fp,-22
  805e74:	000f883a 	mov	r7,zero
  805e78:	01bfffc4 	movi	r6,-1
  805e7c:	100b883a 	mov	r5,r2
  805e80:	e13ffc17 	ldw	r4,-16(fp)
  805e84:	08015c00 	call	8015c0 <xQueueGenericSend>
		xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
  805e88:	e0bffb04 	addi	r2,fp,-20
  805e8c:	000f883a 	mov	r7,zero
  805e90:	01bfffc4 	movi	r6,-1
  805e94:	100b883a 	mov	r5,r2
  805e98:	e13ffd17 	ldw	r4,-12(fp)
  805e9c:	08015c00 	call	8015c0 <xQueueGenericSend>
		
		rs = 1;
  805ea0:	00800044 	movi	r2,1
  805ea4:	e0bffb15 	stw	r2,-20(fp)
		for (i = 0; i < 8; i++)
  805ea8:	e03ffa05 	stb	zero,-24(fp)
  805eac:	00001106 	br	805ef4 <hd44780_cgram+0xf8>
		{
				xQueueSendToBack(Queue_lcd_data, &udg[i], portMAX_DELAY);
  805eb0:	e0bffa03 	ldbu	r2,-24(fp)
  805eb4:	e0c00217 	ldw	r3,8(fp)
  805eb8:	1885883a 	add	r2,r3,r2
  805ebc:	000f883a 	mov	r7,zero
  805ec0:	01bfffc4 	movi	r6,-1
  805ec4:	100b883a 	mov	r5,r2
  805ec8:	e13ffc17 	ldw	r4,-16(fp)
  805ecc:	08015c00 	call	8015c0 <xQueueGenericSend>
				xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
  805ed0:	e0bffb04 	addi	r2,fp,-20
  805ed4:	000f883a 	mov	r7,zero
  805ed8:	01bfffc4 	movi	r6,-1
  805edc:	100b883a 	mov	r5,r2
  805ee0:	e13ffd17 	ldw	r4,-12(fp)
  805ee4:	08015c00 	call	8015c0 <xQueueGenericSend>
	{
		xQueueSendToBack(Queue_lcd_data, &command, portMAX_DELAY);
		xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
		
		rs = 1;
		for (i = 0; i < 8; i++)
  805ee8:	e0bffa03 	ldbu	r2,-24(fp)
  805eec:	10800044 	addi	r2,r2,1
  805ef0:	e0bffa05 	stb	r2,-24(fp)
  805ef4:	e0bffa03 	ldbu	r2,-24(fp)
  805ef8:	10800230 	cmpltui	r2,r2,8
  805efc:	103fec1e 	bne	r2,zero,805eb0 <__alt_mem_onchip_memory2_0+0xff785eb0>
		{
				xQueueSendToBack(Queue_lcd_data, &udg[i], portMAX_DELAY);
				xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
		}
		xSemaphoreGive( Mutex_write_lcd );
  805f00:	000f883a 	mov	r7,zero
  805f04:	000d883a 	mov	r6,zero
  805f08:	000b883a 	mov	r5,zero
  805f0c:	e13ffe17 	ldw	r4,-8(fp)
  805f10:	08015c00 	call	8015c0 <xQueueGenericSend>
	}
}
  805f14:	0001883a 	nop
  805f18:	e037883a 	mov	sp,fp
  805f1c:	dfc00117 	ldw	ra,4(sp)
  805f20:	df000017 	ldw	fp,0(sp)
  805f24:	dec00204 	addi	sp,sp,8
  805f28:	f800283a 	ret

00805f2c <hd44780_put>:
 * Send a single character to the LCD
 *
 * @param chr	Character to send
 */
void hd44780_put(xQueueHandle Queue_lcd_data, xQueueHandle Queue_lcd_rs, xSemaphoreHandle Mutex_write_lcd, const char chr)
{
  805f2c:	defff904 	addi	sp,sp,-28
  805f30:	dfc00615 	stw	ra,24(sp)
  805f34:	df000515 	stw	fp,20(sp)
  805f38:	df000504 	addi	fp,sp,20
  805f3c:	e13ffc15 	stw	r4,-16(fp)
  805f40:	e17ffd15 	stw	r5,-12(fp)
  805f44:	e1bffe15 	stw	r6,-8(fp)
  805f48:	3805883a 	mov	r2,r7
  805f4c:	e0bfff05 	stb	r2,-4(fp)
	int rs = 1;
  805f50:	00800044 	movi	r2,1
  805f54:	e0bffb15 	stw	r2,-20(fp)
	if( xSemaphoreTake( Mutex_write_lcd, portMAX_DELAY ) == pdTRUE )
  805f58:	017fffc4 	movi	r5,-1
  805f5c:	e13ffe17 	ldw	r4,-8(fp)
  805f60:	0801aec0 	call	801aec <xQueueSemaphoreTake>
  805f64:	10800058 	cmpnei	r2,r2,1
  805f68:	1000101e 	bne	r2,zero,805fac <hd44780_put+0x80>
		//char * char_pos = strchr(rus_letter_mas, (int)chr);
		//char * char_pos = strstr(rus_letter_mas, &chr);
		//printf("char = %s, char_pos = %d\n", chr, (int)char_pos);
		/*if (char_pos == NULL)
		{*/
			xQueueSendToBack(Queue_lcd_data, &chr, portMAX_DELAY);
  805f6c:	e0bfff04 	addi	r2,fp,-4
  805f70:	000f883a 	mov	r7,zero
  805f74:	01bfffc4 	movi	r6,-1
  805f78:	100b883a 	mov	r5,r2
  805f7c:	e13ffc17 	ldw	r4,-16(fp)
  805f80:	08015c00 	call	8015c0 <xQueueGenericSend>
			xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
  805f84:	000f883a 	mov	r7,zero
  805f88:	01bfffc4 	movi	r6,-1
  805f8c:	e17ffb04 	addi	r5,fp,-20
  805f90:	e13ffd17 	ldw	r4,-12(fp)
  805f94:	08015c00 	call	8015c0 <xQueueGenericSend>
			xSemaphoreGive( Mutex_write_lcd );
  805f98:	000f883a 	mov	r7,zero
  805f9c:	000d883a 	mov	r6,zero
  805fa0:	000b883a 	mov	r5,zero
  805fa4:	e13ffe17 	ldw	r4,-8(fp)
  805fa8:	08015c00 	call	8015c0 <xQueueGenericSend>
			xQueueSendToBack(Queue_lcd_data, &rus_code_mas[(int)char_pos], portMAX_DELAY);
			xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
			xSemaphoreGive( Mutex_write_lcd );
		}*/
	}
}
  805fac:	0001883a 	nop
  805fb0:	e037883a 	mov	sp,fp
  805fb4:	dfc00117 	ldw	ra,4(sp)
  805fb8:	df000017 	ldw	fp,0(sp)
  805fbc:	dec00204 	addi	sp,sp,8
  805fc0:	f800283a 	ret

00805fc4 <hd44780_print>:
 * Send a string to the LCD
 *
 * @param string	String to send
 */
void hd44780_print(xQueueHandle Queue_lcd_data, xQueueHandle Queue_lcd_rs, xSemaphoreHandle Mutex_write_lcd, const char* string)
{
  805fc4:	defff704 	addi	sp,sp,-36
  805fc8:	dfc00815 	stw	ra,32(sp)
  805fcc:	df000715 	stw	fp,28(sp)
  805fd0:	dc000615 	stw	r16,24(sp)
  805fd4:	df000704 	addi	fp,sp,28
  805fd8:	e13ffb15 	stw	r4,-20(fp)
  805fdc:	e17ffc15 	stw	r5,-16(fp)
  805fe0:	e1bffd15 	stw	r6,-12(fp)
  805fe4:	e1fffe15 	stw	r7,-8(fp)
	alt_u8 i = 0;
  805fe8:	e03ff905 	stb	zero,-28(fp)
	int rs = 1;
  805fec:	00800044 	movi	r2,1
  805ff0:	e0bffa15 	stw	r2,-24(fp)
	
	for(; i < strlen(string); i++)
  805ff4:	00000f06 	br	806034 <hd44780_print+0x70>
	{
		hd44780_put(Queue_lcd_data, Queue_lcd_rs, Mutex_write_lcd, string[i]);
  805ff8:	e0bff903 	ldbu	r2,-28(fp)
  805ffc:	e0fffe17 	ldw	r3,-8(fp)
  806000:	1885883a 	add	r2,r3,r2
  806004:	10800003 	ldbu	r2,0(r2)
  806008:	10803fcc 	andi	r2,r2,255
  80600c:	1080201c 	xori	r2,r2,128
  806010:	10bfe004 	addi	r2,r2,-128
  806014:	100f883a 	mov	r7,r2
  806018:	e1bffd17 	ldw	r6,-12(fp)
  80601c:	e17ffc17 	ldw	r5,-16(fp)
  806020:	e13ffb17 	ldw	r4,-20(fp)
  806024:	0805f2c0 	call	805f2c <hd44780_put>
void hd44780_print(xQueueHandle Queue_lcd_data, xQueueHandle Queue_lcd_rs, xSemaphoreHandle Mutex_write_lcd, const char* string)
{
	alt_u8 i = 0;
	int rs = 1;
	
	for(; i < strlen(string); i++)
  806028:	e0bff903 	ldbu	r2,-28(fp)
  80602c:	10800044 	addi	r2,r2,1
  806030:	e0bff905 	stb	r2,-28(fp)
  806034:	e43ff903 	ldbu	r16,-28(fp)
  806038:	e13ffe17 	ldw	r4,-8(fp)
  80603c:	08068540 	call	806854 <strlen>
  806040:	80bfed36 	bltu	r16,r2,805ff8 <__alt_mem_onchip_memory2_0+0xff785ff8>
	{
		hd44780_put(Queue_lcd_data, Queue_lcd_rs, Mutex_write_lcd, string[i]);
	}
}
  806044:	0001883a 	nop
  806048:	e6ffff04 	addi	sp,fp,-4
  80604c:	dfc00217 	ldw	ra,8(sp)
  806050:	df000117 	ldw	fp,4(sp)
  806054:	dc000017 	ldw	r16,0(sp)
  806058:	dec00304 	addi	sp,sp,12
  80605c:	f800283a 	ret

00806060 <hd44780_printf>:
 *
 * @param fmt	String format
 * @param ...	Variable arguments (see printf())
 */
void hd44780_printf(xQueueHandle Queue_lcd_data, xQueueHandle Queue_lcd_rs, xSemaphoreHandle Mutex_write_lcd, const char *fmt, ...)
{
  806060:	deffee04 	addi	sp,sp,-72
  806064:	dfc01115 	stw	ra,68(sp)
  806068:	df001015 	stw	fp,64(sp)
  80606c:	df001004 	addi	fp,sp,64
  806070:	e13ffc15 	stw	r4,-16(fp)
  806074:	e17ffd15 	stw	r5,-12(fp)
  806078:	e1bffe15 	stw	r6,-8(fp)
  80607c:	e1ffff15 	stw	r7,-4(fp)
	alt_u16 i;
	alt_u16 size;
	alt_u8 character;
	char buffer[32];
	va_list args;
	int rs = 1;
  806080:	00800044 	movi	r2,1
  806084:	e0bff115 	stw	r2,-60(fp)

	va_start(args, fmt);
  806088:	e0800204 	addi	r2,fp,8
  80608c:	e0bffb15 	stw	r2,-20(fp)
	size = vsprintf(buffer, fmt, args);
  806090:	e0fffb17 	ldw	r3,-20(fp)
  806094:	e0bff2c4 	addi	r2,fp,-53
  806098:	180d883a 	mov	r6,r3
  80609c:	e17fff17 	ldw	r5,-4(fp)
  8060a0:	1009883a 	mov	r4,r2
  8060a4:	0806f780 	call	806f78 <vsprintf>
  8060a8:	e0bff20d 	sth	r2,-56(fp)
	for (i = 0; i < size; i++)
  8060ac:	e03ff00d 	sth	zero,-64(fp)
  8060b0:	00001106 	br	8060f8 <hd44780_printf+0x98>
	{
		character = buffer[i];
  8060b4:	e0bff00b 	ldhu	r2,-64(fp)
  8060b8:	e0fff2c4 	addi	r3,fp,-53
  8060bc:	1885883a 	add	r2,r3,r2
  8060c0:	10800003 	ldbu	r2,0(r2)
  8060c4:	e0bff285 	stb	r2,-54(fp)
		hd44780_put(Queue_lcd_data, Queue_lcd_rs, Mutex_write_lcd, character);
  8060c8:	e0bff283 	ldbu	r2,-54(fp)
  8060cc:	10803fcc 	andi	r2,r2,255
  8060d0:	1080201c 	xori	r2,r2,128
  8060d4:	10bfe004 	addi	r2,r2,-128
  8060d8:	100f883a 	mov	r7,r2
  8060dc:	e1bffe17 	ldw	r6,-8(fp)
  8060e0:	e17ffd17 	ldw	r5,-12(fp)
  8060e4:	e13ffc17 	ldw	r4,-16(fp)
  8060e8:	0805f2c0 	call	805f2c <hd44780_put>
	va_list args;
	int rs = 1;

	va_start(args, fmt);
	size = vsprintf(buffer, fmt, args);
	for (i = 0; i < size; i++)
  8060ec:	e0bff00b 	ldhu	r2,-64(fp)
  8060f0:	10800044 	addi	r2,r2,1
  8060f4:	e0bff00d 	sth	r2,-64(fp)
  8060f8:	e0fff00b 	ldhu	r3,-64(fp)
  8060fc:	e0bff20b 	ldhu	r2,-56(fp)
  806100:	18bfec36 	bltu	r3,r2,8060b4 <__alt_mem_onchip_memory2_0+0xff7860b4>
	{
		character = buffer[i];
		hd44780_put(Queue_lcd_data, Queue_lcd_rs, Mutex_write_lcd, character);
	}
}
  806104:	0001883a 	nop
  806108:	e037883a 	mov	sp,fp
  80610c:	dfc00117 	ldw	ra,4(sp)
  806110:	df000017 	ldw	fp,0(sp)
  806114:	dec00204 	addi	sp,sp,8
  806118:	f800283a 	ret

0080611c <hd44780_init>:

/**
 * Initialise the LCD
 */
void hd44780_init(xQueueHandle Queue_lcd_data, xQueueHandle Queue_lcd_rs, xSemaphoreHandle Mutex_write_lcd)
{
  80611c:	defff904 	addi	sp,sp,-28
  806120:	dfc00615 	stw	ra,24(sp)
  806124:	df000515 	stw	fp,20(sp)
  806128:	df000504 	addi	fp,sp,20
  80612c:	e13ffd15 	stw	r4,-12(fp)
  806130:	e17ffe15 	stw	r5,-8(fp)
  806134:	e1bfff15 	stw	r6,-4(fp)
	int data, rs = 0;
  806138:	e03ffc15 	stw	zero,-16(fp)
	alt_putstr("initialisation start\n");
  80613c:	01002074 	movhi	r4,129
  806140:	21259a04 	addi	r4,r4,-27032
  806144:	0807a640 	call	807a64 <alt_putstr>
	//function set
	if( xSemaphoreTake( Mutex_write_lcd, portMAX_DELAY ) == pdTRUE )
  806148:	017fffc4 	movi	r5,-1
  80614c:	e13fff17 	ldw	r4,-4(fp)
  806150:	0801aec0 	call	801aec <xQueueSemaphoreTake>
  806154:	10800058 	cmpnei	r2,r2,1
  806158:	1000441e 	bne	r2,zero,80626c <hd44780_init+0x150>
	{
		vTaskDelay(35*10);
  80615c:	01005784 	movi	r4,350
  806160:	0803a040 	call	803a04 <vTaskDelay>
		data = 0x3C;
  806164:	00800f04 	movi	r2,60
  806168:	e0bffb15 	stw	r2,-20(fp)
		xQueueSendToBack(Queue_lcd_data, &data, portMAX_DELAY);
  80616c:	000f883a 	mov	r7,zero
  806170:	01bfffc4 	movi	r6,-1
  806174:	e17ffb04 	addi	r5,fp,-20
  806178:	e13ffd17 	ldw	r4,-12(fp)
  80617c:	08015c00 	call	8015c0 <xQueueGenericSend>
		xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
  806180:	e0bffc04 	addi	r2,fp,-16
  806184:	000f883a 	mov	r7,zero
  806188:	01bfffc4 	movi	r6,-1
  80618c:	100b883a 	mov	r5,r2
  806190:	e13ffe17 	ldw	r4,-8(fp)
  806194:	08015c00 	call	8015c0 <xQueueGenericSend>
		alt_putstr("initialisation function\n");
  806198:	01002074 	movhi	r4,129
  80619c:	2125a004 	addi	r4,r4,-27008
  8061a0:	0807a640 	call	807a64 <alt_putstr>
		//display and cursor control
		data = 0x0C;
  8061a4:	00800304 	movi	r2,12
  8061a8:	e0bffb15 	stw	r2,-20(fp)
		xQueueSendToBack(Queue_lcd_data, &data, portMAX_DELAY);
  8061ac:	000f883a 	mov	r7,zero
  8061b0:	01bfffc4 	movi	r6,-1
  8061b4:	e17ffb04 	addi	r5,fp,-20
  8061b8:	e13ffd17 	ldw	r4,-12(fp)
  8061bc:	08015c00 	call	8015c0 <xQueueGenericSend>
		xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
  8061c0:	e0bffc04 	addi	r2,fp,-16
  8061c4:	000f883a 	mov	r7,zero
  8061c8:	01bfffc4 	movi	r6,-1
  8061cc:	100b883a 	mov	r5,r2
  8061d0:	e13ffe17 	ldw	r4,-8(fp)
  8061d4:	08015c00 	call	8015c0 <xQueueGenericSend>
		alt_putstr("initialisation display\n");
  8061d8:	01002074 	movhi	r4,129
  8061dc:	2125a704 	addi	r4,r4,-26980
  8061e0:	0807a640 	call	807a64 <alt_putstr>
		//display clear
		data = 0x01;
  8061e4:	00800044 	movi	r2,1
  8061e8:	e0bffb15 	stw	r2,-20(fp)
		xQueueSendToBack(Queue_lcd_data, &data, portMAX_DELAY);
  8061ec:	000f883a 	mov	r7,zero
  8061f0:	01bfffc4 	movi	r6,-1
  8061f4:	e17ffb04 	addi	r5,fp,-20
  8061f8:	e13ffd17 	ldw	r4,-12(fp)
  8061fc:	08015c00 	call	8015c0 <xQueueGenericSend>
		xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
  806200:	e0bffc04 	addi	r2,fp,-16
  806204:	000f883a 	mov	r7,zero
  806208:	01bfffc4 	movi	r6,-1
  80620c:	100b883a 	mov	r5,r2
  806210:	e13ffe17 	ldw	r4,-8(fp)
  806214:	08015c00 	call	8015c0 <xQueueGenericSend>
		alt_putstr("clear display\n");
  806218:	01002074 	movhi	r4,129
  80621c:	2125ad04 	addi	r4,r4,-26956
  806220:	0807a640 	call	807a64 <alt_putstr>
		//entry mode set
		data = 0x07;
  806224:	008001c4 	movi	r2,7
  806228:	e0bffb15 	stw	r2,-20(fp)
		xQueueSendToBack(Queue_lcd_data, &data, portMAX_DELAY);
  80622c:	000f883a 	mov	r7,zero
  806230:	01bfffc4 	movi	r6,-1
  806234:	e17ffb04 	addi	r5,fp,-20
  806238:	e13ffd17 	ldw	r4,-12(fp)
  80623c:	08015c00 	call	8015c0 <xQueueGenericSend>
		xQueueSendToBack(Queue_lcd_rs, &rs, portMAX_DELAY);
  806240:	e0bffc04 	addi	r2,fp,-16
  806244:	000f883a 	mov	r7,zero
  806248:	01bfffc4 	movi	r6,-1
  80624c:	100b883a 	mov	r5,r2
  806250:	e13ffe17 	ldw	r4,-8(fp)
  806254:	08015c00 	call	8015c0 <xQueueGenericSend>
		xSemaphoreGive( Mutex_write_lcd );
  806258:	000f883a 	mov	r7,zero
  80625c:	000d883a 	mov	r6,zero
  806260:	000b883a 	mov	r5,zero
  806264:	e13fff17 	ldw	r4,-4(fp)
  806268:	08015c00 	call	8015c0 <xQueueGenericSend>
	}
	alt_putstr("initialisation finished\n");
  80626c:	01002074 	movhi	r4,129
  806270:	2125b104 	addi	r4,r4,-26940
  806274:	0807a640 	call	807a64 <alt_putstr>
	/* hd44780_clear();
	hd44780_home(); */
}
  806278:	0001883a 	nop
  80627c:	e037883a 	mov	sp,fp
  806280:	dfc00117 	ldw	ra,4(sp)
  806284:	df000017 	ldw	fp,0(sp)
  806288:	dec00204 	addi	sp,sp,8
  80628c:	f800283a 	ret

00806290 <sayHello>:

xQueueHandle Queue_lcd_data, Queue_lcd_rs;
xSemaphoreHandle Mutex_write_lcd;
int n = 0;

void sayHello( void *p){
  806290:	defffd04 	addi	sp,sp,-12
  806294:	dfc00215 	stw	ra,8(sp)
  806298:	df000115 	stw	fp,4(sp)
  80629c:	df000104 	addi	fp,sp,4
  8062a0:	e13fff15 	stw	r4,-4(fp)
	//char data[] = "%s, %s, %d, ", data2[] = "asd", data3[] = "sdf";
	//int data4 = 20;
while(1){
	printf("Hello, world!\n");
  8062a4:	01002074 	movhi	r4,129
  8062a8:	2125b804 	addi	r4,r4,-26912
  8062ac:	08068400 	call	806840 <puts>
	//hd44780_printf(Queue_lcd_data, Queue_lcd_rs, Mutex_write_lcd, data, data2, data3, data4);

	vTaskDelay(1000*10);
  8062b0:	0109c404 	movi	r4,10000
  8062b4:	0803a040 	call	803a04 <vTaskDelay>
 }
  8062b8:	003ffa06 	br	8062a4 <__alt_mem_onchip_memory2_0+0xff7862a4>

008062bc <sayInBitween>:
}


void sayInBitween (void *p){
  8062bc:	defffd04 	addi	sp,sp,-12
  8062c0:	dfc00215 	stw	ra,8(sp)
  8062c4:	df000115 	stw	fp,4(sp)
  8062c8:	df000104 	addi	fp,sp,4
  8062cc:	e13fff15 	stw	r4,-4(fp)
while(1){
 printf("In between\n");
  8062d0:	01002074 	movhi	r4,129
  8062d4:	2125bc04 	addi	r4,r4,-26896
  8062d8:	08068400 	call	806840 <puts>
 /*IOWR_ALTERA_AVALON_PIO_DATA(LED_BASE, 1 << n);
 n++;
 if (n == 10) n = 0;*/
 vTaskDelay(300*10);
  8062dc:	0102ee04 	movi	r4,3000
  8062e0:	0803a040 	call	803a04 <vTaskDelay>
 }
  8062e4:	003ffa06 	br	8062d0 <__alt_mem_onchip_memory2_0+0xff7862d0>

008062e8 <task_lcd_write>:
}
void task_lcd_write(void *p)
{
  8062e8:	defffb04 	addi	sp,sp,-20
  8062ec:	dfc00415 	stw	ra,16(sp)
  8062f0:	df000315 	stw	fp,12(sp)
  8062f4:	df000304 	addi	fp,sp,12
  8062f8:	e13fff15 	stw	r4,-4(fp)
	hd44780_init(Queue_lcd_data, Queue_lcd_rs, Mutex_write_lcd);
  8062fc:	00802074 	movhi	r2,129
  806300:	10aff104 	addi	r2,r2,-16444
  806304:	10c00017 	ldw	r3,0(r2)
  806308:	00802074 	movhi	r2,129
  80630c:	10aff004 	addi	r2,r2,-16448
  806310:	11000017 	ldw	r4,0(r2)
  806314:	00802074 	movhi	r2,129
  806318:	10aff204 	addi	r2,r2,-16440
  80631c:	10800017 	ldw	r2,0(r2)
  806320:	100d883a 	mov	r6,r2
  806324:	200b883a 	mov	r5,r4
  806328:	1809883a 	mov	r4,r3
  80632c:	080611c0 	call	80611c <hd44780_init>
	int data, rs;
	while(1)
	{
		xQueueReceive(Queue_lcd_data, &data, portMAX_DELAY);
  806330:	00802074 	movhi	r2,129
  806334:	10aff104 	addi	r2,r2,-16444
  806338:	10800017 	ldw	r2,0(r2)
  80633c:	01bfffc4 	movi	r6,-1
  806340:	e17ffd04 	addi	r5,fp,-12
  806344:	1009883a 	mov	r4,r2
  806348:	08019440 	call	801944 <xQueueReceive>
		xQueueReceive(Queue_lcd_rs, &rs, portMAX_DELAY);
  80634c:	00802074 	movhi	r2,129
  806350:	10aff004 	addi	r2,r2,-16448
  806354:	10800017 	ldw	r2,0(r2)
  806358:	e0fffe04 	addi	r3,fp,-8
  80635c:	01bfffc4 	movi	r6,-1
  806360:	180b883a 	mov	r5,r3
  806364:	1009883a 	mov	r4,r2
  806368:	08019440 	call	801944 <xQueueReceive>
		hd44780_write(data, rs);
  80636c:	e0bffd17 	ldw	r2,-12(fp)
  806370:	10803fcc 	andi	r2,r2,255
  806374:	e0fffe17 	ldw	r3,-8(fp)
  806378:	180b883a 	mov	r5,r3
  80637c:	1009883a 	mov	r4,r2
  806380:	0805a940 	call	805a94 <hd44780_write>
	}
  806384:	003fea06 	br	806330 <__alt_mem_onchip_memory2_0+0xff786330>

00806388 <freq_to_lcd>:
}

void freq_to_lcd(void *p)
{
  806388:	defffa04 	addi	sp,sp,-24
  80638c:	dfc00515 	stw	ra,20(sp)
  806390:	df000415 	stw	fp,16(sp)
  806394:	df000404 	addi	fp,sp,16
  806398:	e13fff15 	stw	r4,-4(fp)
	int write_en = 0;
  80639c:	e03ffc15 	stw	zero,-16(fp)
	char zagolovok [] = {0xAB,0x61,0x63,0xBF,0x6F,0xBF,0x61}, znachenie;
  8063a0:	00bfeac4 	movi	r2,-85
  8063a4:	e0bffd45 	stb	r2,-11(fp)
  8063a8:	00801844 	movi	r2,97
  8063ac:	e0bffd85 	stb	r2,-10(fp)
  8063b0:	008018c4 	movi	r2,99
  8063b4:	e0bffdc5 	stb	r2,-9(fp)
  8063b8:	00bfefc4 	movi	r2,-65
  8063bc:	e0bffe05 	stb	r2,-8(fp)
  8063c0:	00801bc4 	movi	r2,111
  8063c4:	e0bffe45 	stb	r2,-7(fp)
  8063c8:	00bfefc4 	movi	r2,-65
  8063cc:	e0bffe85 	stb	r2,-6(fp)
  8063d0:	00801844 	movi	r2,97
  8063d4:	e0bffec5 	stb	r2,-5(fp)
	while(1)
	{
		//printf("to lcd");
		if(IORD_ALTERA_AVALON_PIO_DATA(FREQ_EN_BASE))
  8063d8:	00804434 	movhi	r2,272
  8063dc:	10840804 	addi	r2,r2,4128
  8063e0:	10800037 	ldwio	r2,0(r2)
  8063e4:	10005926 	beq	r2,zero,80654c <freq_to_lcd+0x1c4>
		{
			printf("to lcd");
  8063e8:	01002074 	movhi	r4,129
  8063ec:	2125bf04 	addi	r4,r4,-26884
  8063f0:	08067740 	call	806774 <printf>
			write_en++;
  8063f4:	e0bffc17 	ldw	r2,-16(fp)
  8063f8:	10800044 	addi	r2,r2,1
  8063fc:	e0bffc15 	stw	r2,-16(fp)
			if (write_en == 1)
  806400:	e0bffc17 	ldw	r2,-16(fp)
  806404:	10800058 	cmpnei	r2,r2,1
  806408:	103ff31e 	bne	r2,zero,8063d8 <__alt_mem_onchip_memory2_0+0xff7863d8>
			{
				hd44780_home(Queue_lcd_data, Queue_lcd_rs, Mutex_write_lcd);
  80640c:	00802074 	movhi	r2,129
  806410:	10aff104 	addi	r2,r2,-16444
  806414:	10c00017 	ldw	r3,0(r2)
  806418:	00802074 	movhi	r2,129
  80641c:	10aff004 	addi	r2,r2,-16448
  806420:	11000017 	ldw	r4,0(r2)
  806424:	00802074 	movhi	r2,129
  806428:	10aff204 	addi	r2,r2,-16440
  80642c:	10800017 	ldw	r2,0(r2)
  806430:	100d883a 	mov	r6,r2
  806434:	200b883a 	mov	r5,r4
  806438:	1809883a 	mov	r4,r3
  80643c:	0805ba80 	call	805ba8 <hd44780_home>
				hd44780_print(Queue_lcd_data, Queue_lcd_rs, Mutex_write_lcd, zagolovok);
  806440:	00802074 	movhi	r2,129
  806444:	10aff104 	addi	r2,r2,-16444
  806448:	10c00017 	ldw	r3,0(r2)
  80644c:	00802074 	movhi	r2,129
  806450:	10aff004 	addi	r2,r2,-16448
  806454:	11000017 	ldw	r4,0(r2)
  806458:	00802074 	movhi	r2,129
  80645c:	10aff204 	addi	r2,r2,-16440
  806460:	10800017 	ldw	r2,0(r2)
  806464:	e17ffd44 	addi	r5,fp,-11
  806468:	280f883a 	mov	r7,r5
  80646c:	100d883a 	mov	r6,r2
  806470:	200b883a 	mov	r5,r4
  806474:	1809883a 	mov	r4,r3
  806478:	0805fc40 	call	805fc4 <hd44780_print>
				hd44780_print(Queue_lcd_data, Queue_lcd_rs, Mutex_write_lcd, " = ");
  80647c:	00802074 	movhi	r2,129
  806480:	10aff104 	addi	r2,r2,-16444
  806484:	10c00017 	ldw	r3,0(r2)
  806488:	00802074 	movhi	r2,129
  80648c:	10aff004 	addi	r2,r2,-16448
  806490:	11000017 	ldw	r4,0(r2)
  806494:	00802074 	movhi	r2,129
  806498:	10aff204 	addi	r2,r2,-16440
  80649c:	10800017 	ldw	r2,0(r2)
  8064a0:	01c02074 	movhi	r7,129
  8064a4:	39e5c104 	addi	r7,r7,-26876
  8064a8:	100d883a 	mov	r6,r2
  8064ac:	200b883a 	mov	r5,r4
  8064b0:	1809883a 	mov	r4,r3
  8064b4:	0805fc40 	call	805fc4 <hd44780_print>
				itoa(IORD_ALTERA_AVALON_PIO_DATA(FREQ_BASE), znachenie, 10);
  8064b8:	00804434 	movhi	r2,272
  8064bc:	10842004 	addi	r2,r2,4224
  8064c0:	10800037 	ldwio	r2,0(r2)
  8064c4:	e0fffd07 	ldb	r3,-12(fp)
  8064c8:	01800284 	movi	r6,10
  8064cc:	180b883a 	mov	r5,r3
  8064d0:	1009883a 	mov	r4,r2
  8064d4:	08066ec0 	call	8066ec <itoa>
				hd44780_print(Queue_lcd_data, Queue_lcd_rs, Mutex_write_lcd, znachenie);
  8064d8:	00802074 	movhi	r2,129
  8064dc:	10aff104 	addi	r2,r2,-16444
  8064e0:	10c00017 	ldw	r3,0(r2)
  8064e4:	00802074 	movhi	r2,129
  8064e8:	10aff004 	addi	r2,r2,-16448
  8064ec:	11000017 	ldw	r4,0(r2)
  8064f0:	00802074 	movhi	r2,129
  8064f4:	10aff204 	addi	r2,r2,-16440
  8064f8:	10800017 	ldw	r2,0(r2)
  8064fc:	e17ffd07 	ldb	r5,-12(fp)
  806500:	280f883a 	mov	r7,r5
  806504:	100d883a 	mov	r6,r2
  806508:	200b883a 	mov	r5,r4
  80650c:	1809883a 	mov	r4,r3
  806510:	0805fc40 	call	805fc4 <hd44780_print>
				//printf("%X\n", '');
				//printf("%s", rus_letter_mas[0]);
				IOWR_ALTERA_AVALON_PIO_DATA(LED_BASE, 1 << n);
  806514:	d0a51417 	ldw	r2,-27568(gp)
  806518:	00c00044 	movi	r3,1
  80651c:	1886983a 	sll	r3,r3,r2
  806520:	00804434 	movhi	r2,272
  806524:	10842404 	addi	r2,r2,4240
  806528:	10c00035 	stwio	r3,0(r2)
				n++;
  80652c:	d0a51417 	ldw	r2,-27568(gp)
  806530:	10800044 	addi	r2,r2,1
  806534:	d0a51415 	stw	r2,-27568(gp)
				if (n == 10) n = 0;
  806538:	d0a51417 	ldw	r2,-27568(gp)
  80653c:	10800298 	cmpnei	r2,r2,10
  806540:	103fa51e 	bne	r2,zero,8063d8 <__alt_mem_onchip_memory2_0+0xff7863d8>
  806544:	d0251415 	stw	zero,-27568(gp)
  806548:	003fa306 	br	8063d8 <__alt_mem_onchip_memory2_0+0xff7863d8>
			}
		}
		else write_en = 0;
  80654c:	e03ffc15 	stw	zero,-16(fp)
	}
  806550:	003fa106 	br	8063d8 <__alt_mem_onchip_memory2_0+0xff7863d8>

00806554 <main>:

}

int main()
{
  806554:	defffc04 	addi	sp,sp,-16
  806558:	dfc00315 	stw	ra,12(sp)
  80655c:	df000215 	stw	fp,8(sp)
  806560:	df000204 	addi	fp,sp,8
	alt_putstr("Hello from Nios II!\n");
  806564:	01002074 	movhi	r4,129
  806568:	2125c204 	addi	r4,r4,-26872
  80656c:	0807a640 	call	807a64 <alt_putstr>
	Queue_lcd_data = xQueueCreate(100, 1);
  806570:	000d883a 	mov	r6,zero
  806574:	01400044 	movi	r5,1
  806578:	01001904 	movi	r4,100
  80657c:	08012640 	call	801264 <xQueueGenericCreate>
  806580:	1007883a 	mov	r3,r2
  806584:	00802074 	movhi	r2,129
  806588:	10aff104 	addi	r2,r2,-16444
  80658c:	10c00015 	stw	r3,0(r2)
	Queue_lcd_rs = xQueueCreate(100, 1);
  806590:	000d883a 	mov	r6,zero
  806594:	01400044 	movi	r5,1
  806598:	01001904 	movi	r4,100
  80659c:	08012640 	call	801264 <xQueueGenericCreate>
  8065a0:	1007883a 	mov	r3,r2
  8065a4:	00802074 	movhi	r2,129
  8065a8:	10aff004 	addi	r2,r2,-16448
  8065ac:	10c00015 	stw	r3,0(r2)
	Mutex_write_lcd = xSemaphoreCreateMutex();
  8065b0:	01000044 	movi	r4,1
  8065b4:	08013e00 	call	8013e0 <xQueueCreateMutex>
  8065b8:	1007883a 	mov	r3,r2
  8065bc:	00802074 	movhi	r2,129
  8065c0:	10aff204 	addi	r2,r2,-16440
  8065c4:	10c00015 	stw	r3,0(r2)
	xTaskCreate(task_lcd_write, "task_lcd_write", configMINIMAL_STACK_SIZE, NULL, 2, NULL);
  8065c8:	d8000115 	stw	zero,4(sp)
  8065cc:	00800084 	movi	r2,2
  8065d0:	d8800015 	stw	r2,0(sp)
  8065d4:	000f883a 	mov	r7,zero
  8065d8:	01810004 	movi	r6,1024
  8065dc:	01402074 	movhi	r5,129
  8065e0:	2965c804 	addi	r5,r5,-26848
  8065e4:	01002034 	movhi	r4,128
  8065e8:	2118ba04 	addi	r4,r4,25320
  8065ec:	08034640 	call	803464 <xTaskCreate>
	xTaskCreate(sayHello, "sayHello", configMINIMAL_STACK_SIZE, NULL, 2, NULL);
  8065f0:	d8000115 	stw	zero,4(sp)
  8065f4:	00800084 	movi	r2,2
  8065f8:	d8800015 	stw	r2,0(sp)
  8065fc:	000f883a 	mov	r7,zero
  806600:	01810004 	movi	r6,1024
  806604:	01402074 	movhi	r5,129
  806608:	2965cc04 	addi	r5,r5,-26832
  80660c:	01002034 	movhi	r4,128
  806610:	2118a404 	addi	r4,r4,25232
  806614:	08034640 	call	803464 <xTaskCreate>
	xTaskCreate(freq_to_lcd, "freq_to_lcd", configMINIMAL_STACK_SIZE, NULL, 2, NULL);
  806618:	d8000115 	stw	zero,4(sp)
  80661c:	00800084 	movi	r2,2
  806620:	d8800015 	stw	r2,0(sp)
  806624:	000f883a 	mov	r7,zero
  806628:	01810004 	movi	r6,1024
  80662c:	01402074 	movhi	r5,129
  806630:	2965cf04 	addi	r5,r5,-26820
  806634:	01002034 	movhi	r4,128
  806638:	2118e204 	addi	r4,r4,25480
  80663c:	08034640 	call	803464 <xTaskCreate>
	//printf("sayHello inst\n");
	xTaskCreate(sayInBitween, "sayInBitween",configMINIMAL_STACK_SIZE,NULL,2,NULL);
  806640:	d8000115 	stw	zero,4(sp)
  806644:	00800084 	movi	r2,2
  806648:	d8800015 	stw	r2,0(sp)
  80664c:	000f883a 	mov	r7,zero
  806650:	01810004 	movi	r6,1024
  806654:	01402074 	movhi	r5,129
  806658:	2965d204 	addi	r5,r5,-26808
  80665c:	01002034 	movhi	r4,128
  806660:	2118af04 	addi	r4,r4,25276
  806664:	08034640 	call	803464 <xTaskCreate>
	//printf("sayInBitween inst\n");
	vTaskStartScheduler();
  806668:	0803fbc0 	call	803fbc <vTaskStartScheduler>
	return 0;
  80666c:	0005883a 	mov	r2,zero
}
  806670:	e037883a 	mov	sp,fp
  806674:	dfc00117 	ldw	ra,4(sp)
  806678:	df000017 	ldw	fp,0(sp)
  80667c:	dec00204 	addi	sp,sp,8
  806680:	f800283a 	ret

00806684 <__itoa>:
  806684:	30bfff84 	addi	r2,r6,-2
  806688:	00c00884 	movi	r3,34
  80668c:	1880032e 	bgeu	r3,r2,80669c <__itoa+0x18>
  806690:	28000005 	stb	zero,0(r5)
  806694:	0005883a 	mov	r2,zero
  806698:	f800283a 	ret
  80669c:	defffe04 	addi	sp,sp,-8
  8066a0:	dfc00115 	stw	ra,4(sp)
  8066a4:	dc000015 	stw	r16,0(sp)
  8066a8:	00800284 	movi	r2,10
  8066ac:	3080061e 	bne	r6,r2,8066c8 <__itoa+0x44>
  8066b0:	2000050e 	bge	r4,zero,8066c8 <__itoa+0x44>
  8066b4:	00800b44 	movi	r2,45
  8066b8:	28800005 	stb	r2,0(r5)
  8066bc:	0109c83a 	sub	r4,zero,r4
  8066c0:	00800044 	movi	r2,1
  8066c4:	00000106 	br	8066cc <__itoa+0x48>
  8066c8:	0005883a 	mov	r2,zero
  8066cc:	2821883a 	mov	r16,r5
  8066d0:	288b883a 	add	r5,r5,r2
  8066d4:	08068700 	call	806870 <__utoa>
  8066d8:	8005883a 	mov	r2,r16
  8066dc:	dfc00117 	ldw	ra,4(sp)
  8066e0:	dc000017 	ldw	r16,0(sp)
  8066e4:	dec00204 	addi	sp,sp,8
  8066e8:	f800283a 	ret

008066ec <itoa>:
  8066ec:	08066841 	jmpi	806684 <__itoa>

008066f0 <memcpy>:
  8066f0:	2005883a 	mov	r2,r4
  8066f4:	2007883a 	mov	r3,r4
  8066f8:	218d883a 	add	r6,r4,r6
  8066fc:	19800526 	beq	r3,r6,806714 <memcpy+0x24>
  806700:	29000003 	ldbu	r4,0(r5)
  806704:	18c00044 	addi	r3,r3,1
  806708:	29400044 	addi	r5,r5,1
  80670c:	193fffc5 	stb	r4,-1(r3)
  806710:	003ffa06 	br	8066fc <__alt_mem_onchip_memory2_0+0xff7866fc>
  806714:	f800283a 	ret

00806718 <memset>:
  806718:	2005883a 	mov	r2,r4
  80671c:	2007883a 	mov	r3,r4
  806720:	218d883a 	add	r6,r4,r6
  806724:	19800326 	beq	r3,r6,806734 <memset+0x1c>
  806728:	19400005 	stb	r5,0(r3)
  80672c:	18c00044 	addi	r3,r3,1
  806730:	003ffc06 	br	806724 <__alt_mem_onchip_memory2_0+0xff786724>
  806734:	f800283a 	ret

00806738 <_printf_r>:
  806738:	defffd04 	addi	sp,sp,-12
  80673c:	dfc00015 	stw	ra,0(sp)
  806740:	d9800115 	stw	r6,4(sp)
  806744:	d9c00215 	stw	r7,8(sp)
  806748:	20c00217 	ldw	r3,8(r4)
  80674c:	01802034 	movhi	r6,128
  806750:	319be504 	addi	r6,r6,28564
  806754:	19800115 	stw	r6,4(r3)
  806758:	280d883a 	mov	r6,r5
  80675c:	21400217 	ldw	r5,8(r4)
  806760:	d9c00104 	addi	r7,sp,4
  806764:	08069dc0 	call	8069dc <___vfprintf_internal_r>
  806768:	dfc00017 	ldw	ra,0(sp)
  80676c:	dec00304 	addi	sp,sp,12
  806770:	f800283a 	ret

00806774 <printf>:
  806774:	defffc04 	addi	sp,sp,-16
  806778:	dfc00015 	stw	ra,0(sp)
  80677c:	d9400115 	stw	r5,4(sp)
  806780:	d9800215 	stw	r6,8(sp)
  806784:	d9c00315 	stw	r7,12(sp)
  806788:	00802074 	movhi	r2,129
  80678c:	10aadc04 	addi	r2,r2,-21648
  806790:	10800017 	ldw	r2,0(r2)
  806794:	01402034 	movhi	r5,128
  806798:	295be504 	addi	r5,r5,28564
  80679c:	10c00217 	ldw	r3,8(r2)
  8067a0:	d9800104 	addi	r6,sp,4
  8067a4:	19400115 	stw	r5,4(r3)
  8067a8:	200b883a 	mov	r5,r4
  8067ac:	11000217 	ldw	r4,8(r2)
  8067b0:	0806f000 	call	806f00 <__vfprintf_internal>
  8067b4:	dfc00017 	ldw	ra,0(sp)
  8067b8:	dec00404 	addi	sp,sp,16
  8067bc:	f800283a 	ret

008067c0 <_puts_r>:
  8067c0:	defffd04 	addi	sp,sp,-12
  8067c4:	dc000015 	stw	r16,0(sp)
  8067c8:	2021883a 	mov	r16,r4
  8067cc:	2809883a 	mov	r4,r5
  8067d0:	dfc00215 	stw	ra,8(sp)
  8067d4:	dc400115 	stw	r17,4(sp)
  8067d8:	2823883a 	mov	r17,r5
  8067dc:	08068540 	call	806854 <strlen>
  8067e0:	81400217 	ldw	r5,8(r16)
  8067e4:	01002034 	movhi	r4,128
  8067e8:	211be504 	addi	r4,r4,28564
  8067ec:	29000115 	stw	r4,4(r5)
  8067f0:	100f883a 	mov	r7,r2
  8067f4:	880d883a 	mov	r6,r17
  8067f8:	8009883a 	mov	r4,r16
  8067fc:	0806f940 	call	806f94 <__sfvwrite_small_dev>
  806800:	00ffffc4 	movi	r3,-1
  806804:	10c00926 	beq	r2,r3,80682c <_puts_r+0x6c>
  806808:	81400217 	ldw	r5,8(r16)
  80680c:	01802074 	movhi	r6,129
  806810:	01c00044 	movi	r7,1
  806814:	28800117 	ldw	r2,4(r5)
  806818:	31a5d604 	addi	r6,r6,-26792
  80681c:	8009883a 	mov	r4,r16
  806820:	103ee83a 	callr	r2
  806824:	10bfffe0 	cmpeqi	r2,r2,-1
  806828:	0085c83a 	sub	r2,zero,r2
  80682c:	dfc00217 	ldw	ra,8(sp)
  806830:	dc400117 	ldw	r17,4(sp)
  806834:	dc000017 	ldw	r16,0(sp)
  806838:	dec00304 	addi	sp,sp,12
  80683c:	f800283a 	ret

00806840 <puts>:
  806840:	00802074 	movhi	r2,129
  806844:	10aadc04 	addi	r2,r2,-21648
  806848:	200b883a 	mov	r5,r4
  80684c:	11000017 	ldw	r4,0(r2)
  806850:	08067c01 	jmpi	8067c0 <_puts_r>

00806854 <strlen>:
  806854:	2005883a 	mov	r2,r4
  806858:	10c00007 	ldb	r3,0(r2)
  80685c:	18000226 	beq	r3,zero,806868 <strlen+0x14>
  806860:	10800044 	addi	r2,r2,1
  806864:	003ffc06 	br	806858 <__alt_mem_onchip_memory2_0+0xff786858>
  806868:	1105c83a 	sub	r2,r2,r4
  80686c:	f800283a 	ret

00806870 <__utoa>:
  806870:	deffef04 	addi	sp,sp,-68
  806874:	dc000a15 	stw	r16,40(sp)
  806878:	2821883a 	mov	r16,r5
  80687c:	01402074 	movhi	r5,129
  806880:	dd400f15 	stw	r21,60(sp)
  806884:	dcc00d15 	stw	r19,52(sp)
  806888:	302b883a 	mov	r21,r6
  80688c:	2027883a 	mov	r19,r4
  806890:	01800944 	movi	r6,37
  806894:	2965d704 	addi	r5,r5,-26788
  806898:	d809883a 	mov	r4,sp
  80689c:	dfc01015 	stw	ra,64(sp)
  8068a0:	dd000e15 	stw	r20,56(sp)
  8068a4:	dc800c15 	stw	r18,48(sp)
  8068a8:	dc400b15 	stw	r17,44(sp)
  8068ac:	08066f00 	call	8066f0 <memcpy>
  8068b0:	a8bfff84 	addi	r2,r21,-2
  8068b4:	00c00884 	movi	r3,34
  8068b8:	1880032e 	bgeu	r3,r2,8068c8 <__utoa+0x58>
  8068bc:	80000005 	stb	zero,0(r16)
  8068c0:	0005883a 	mov	r2,zero
  8068c4:	00002006 	br	806948 <__utoa+0xd8>
  8068c8:	8029883a 	mov	r20,r16
  8068cc:	0023883a 	mov	r17,zero
  8068d0:	9809883a 	mov	r4,r19
  8068d4:	a80b883a 	mov	r5,r21
  8068d8:	08078b40 	call	8078b4 <__umodsi3>
  8068dc:	d885883a 	add	r2,sp,r2
  8068e0:	10800003 	ldbu	r2,0(r2)
  8068e4:	9809883a 	mov	r4,r19
  8068e8:	a80b883a 	mov	r5,r21
  8068ec:	a0800005 	stb	r2,0(r20)
  8068f0:	08078500 	call	807850 <__udivsi3>
  8068f4:	8c800044 	addi	r18,r17,1
  8068f8:	1027883a 	mov	r19,r2
  8068fc:	a5000044 	addi	r20,r20,1
  806900:	10000226 	beq	r2,zero,80690c <__utoa+0x9c>
  806904:	9023883a 	mov	r17,r18
  806908:	003ff106 	br	8068d0 <__alt_mem_onchip_memory2_0+0xff7868d0>
  80690c:	84a5883a 	add	r18,r16,r18
  806910:	90000005 	stb	zero,0(r18)
  806914:	8445883a 	add	r2,r16,r17
  806918:	8007883a 	mov	r3,r16
  80691c:	1409c83a 	sub	r4,r2,r16
  806920:	1c0bc83a 	sub	r5,r3,r16
  806924:	2900070e 	bge	r5,r4,806944 <__utoa+0xd4>
  806928:	11400003 	ldbu	r5,0(r2)
  80692c:	19000003 	ldbu	r4,0(r3)
  806930:	10bfffc4 	addi	r2,r2,-1
  806934:	19400005 	stb	r5,0(r3)
  806938:	11000045 	stb	r4,1(r2)
  80693c:	18c00044 	addi	r3,r3,1
  806940:	003ff606 	br	80691c <__alt_mem_onchip_memory2_0+0xff78691c>
  806944:	8005883a 	mov	r2,r16
  806948:	dfc01017 	ldw	ra,64(sp)
  80694c:	dd400f17 	ldw	r21,60(sp)
  806950:	dd000e17 	ldw	r20,56(sp)
  806954:	dcc00d17 	ldw	r19,52(sp)
  806958:	dc800c17 	ldw	r18,48(sp)
  80695c:	dc400b17 	ldw	r17,44(sp)
  806960:	dc000a17 	ldw	r16,40(sp)
  806964:	dec01104 	addi	sp,sp,68
  806968:	f800283a 	ret

0080696c <utoa>:
  80696c:	08068701 	jmpi	806870 <__utoa>

00806970 <print_repeat>:
  806970:	defffb04 	addi	sp,sp,-20
  806974:	dc800315 	stw	r18,12(sp)
  806978:	dc400215 	stw	r17,8(sp)
  80697c:	dc000115 	stw	r16,4(sp)
  806980:	dfc00415 	stw	ra,16(sp)
  806984:	2025883a 	mov	r18,r4
  806988:	2823883a 	mov	r17,r5
  80698c:	d9800005 	stb	r6,0(sp)
  806990:	3821883a 	mov	r16,r7
  806994:	04000a0e 	bge	zero,r16,8069c0 <print_repeat+0x50>
  806998:	88800117 	ldw	r2,4(r17)
  80699c:	01c00044 	movi	r7,1
  8069a0:	d80d883a 	mov	r6,sp
  8069a4:	880b883a 	mov	r5,r17
  8069a8:	9009883a 	mov	r4,r18
  8069ac:	103ee83a 	callr	r2
  8069b0:	843fffc4 	addi	r16,r16,-1
  8069b4:	103ff726 	beq	r2,zero,806994 <__alt_mem_onchip_memory2_0+0xff786994>
  8069b8:	00bfffc4 	movi	r2,-1
  8069bc:	00000106 	br	8069c4 <print_repeat+0x54>
  8069c0:	0005883a 	mov	r2,zero
  8069c4:	dfc00417 	ldw	ra,16(sp)
  8069c8:	dc800317 	ldw	r18,12(sp)
  8069cc:	dc400217 	ldw	r17,8(sp)
  8069d0:	dc000117 	ldw	r16,4(sp)
  8069d4:	dec00504 	addi	sp,sp,20
  8069d8:	f800283a 	ret

008069dc <___vfprintf_internal_r>:
  8069dc:	deffe504 	addi	sp,sp,-108
  8069e0:	d8c00804 	addi	r3,sp,32
  8069e4:	df001915 	stw	fp,100(sp)
  8069e8:	ddc01815 	stw	r23,96(sp)
  8069ec:	dd801715 	stw	r22,92(sp)
  8069f0:	dd401615 	stw	r21,88(sp)
  8069f4:	dd001515 	stw	r20,84(sp)
  8069f8:	dcc01415 	stw	r19,80(sp)
  8069fc:	dc801315 	stw	r18,76(sp)
  806a00:	dc401215 	stw	r17,72(sp)
  806a04:	dc001115 	stw	r16,68(sp)
  806a08:	dfc01a15 	stw	ra,104(sp)
  806a0c:	2027883a 	mov	r19,r4
  806a10:	2839883a 	mov	fp,r5
  806a14:	382d883a 	mov	r22,r7
  806a18:	d9800f15 	stw	r6,60(sp)
  806a1c:	0021883a 	mov	r16,zero
  806a20:	d8000e15 	stw	zero,56(sp)
  806a24:	002f883a 	mov	r23,zero
  806a28:	002b883a 	mov	r21,zero
  806a2c:	0025883a 	mov	r18,zero
  806a30:	0023883a 	mov	r17,zero
  806a34:	d8000c15 	stw	zero,48(sp)
  806a38:	d8000b15 	stw	zero,44(sp)
  806a3c:	0029883a 	mov	r20,zero
  806a40:	d8c00915 	stw	r3,36(sp)
  806a44:	d8c00f17 	ldw	r3,60(sp)
  806a48:	19000003 	ldbu	r4,0(r3)
  806a4c:	20803fcc 	andi	r2,r4,255
  806a50:	1080201c 	xori	r2,r2,128
  806a54:	10bfe004 	addi	r2,r2,-128
  806a58:	10011c26 	beq	r2,zero,806ecc <___vfprintf_internal_r+0x4f0>
  806a5c:	00c00044 	movi	r3,1
  806a60:	a0c01426 	beq	r20,r3,806ab4 <___vfprintf_internal_r+0xd8>
  806a64:	1d000216 	blt	r3,r20,806a70 <___vfprintf_internal_r+0x94>
  806a68:	a0000626 	beq	r20,zero,806a84 <___vfprintf_internal_r+0xa8>
  806a6c:	00011306 	br	806ebc <___vfprintf_internal_r+0x4e0>
  806a70:	01400084 	movi	r5,2
  806a74:	a1401d26 	beq	r20,r5,806aec <___vfprintf_internal_r+0x110>
  806a78:	014000c4 	movi	r5,3
  806a7c:	a1402926 	beq	r20,r5,806b24 <___vfprintf_internal_r+0x148>
  806a80:	00010e06 	br	806ebc <___vfprintf_internal_r+0x4e0>
  806a84:	01400944 	movi	r5,37
  806a88:	1140fb26 	beq	r2,r5,806e78 <___vfprintf_internal_r+0x49c>
  806a8c:	e0800117 	ldw	r2,4(fp)
  806a90:	d9000005 	stb	r4,0(sp)
  806a94:	01c00044 	movi	r7,1
  806a98:	d80d883a 	mov	r6,sp
  806a9c:	e00b883a 	mov	r5,fp
  806aa0:	9809883a 	mov	r4,r19
  806aa4:	103ee83a 	callr	r2
  806aa8:	1000d61e 	bne	r2,zero,806e04 <___vfprintf_internal_r+0x428>
  806aac:	84000044 	addi	r16,r16,1
  806ab0:	00010206 	br	806ebc <___vfprintf_internal_r+0x4e0>
  806ab4:	01400c04 	movi	r5,48
  806ab8:	1140f826 	beq	r2,r5,806e9c <___vfprintf_internal_r+0x4c0>
  806abc:	01400944 	movi	r5,37
  806ac0:	11400a1e 	bne	r2,r5,806aec <___vfprintf_internal_r+0x110>
  806ac4:	d8800005 	stb	r2,0(sp)
  806ac8:	e0800117 	ldw	r2,4(fp)
  806acc:	a00f883a 	mov	r7,r20
  806ad0:	d80d883a 	mov	r6,sp
  806ad4:	e00b883a 	mov	r5,fp
  806ad8:	9809883a 	mov	r4,r19
  806adc:	103ee83a 	callr	r2
  806ae0:	1000c81e 	bne	r2,zero,806e04 <___vfprintf_internal_r+0x428>
  806ae4:	84000044 	addi	r16,r16,1
  806ae8:	0000f306 	br	806eb8 <___vfprintf_internal_r+0x4dc>
  806aec:	217ff404 	addi	r5,r4,-48
  806af0:	29403fcc 	andi	r5,r5,255
  806af4:	00c00244 	movi	r3,9
  806af8:	19400736 	bltu	r3,r5,806b18 <___vfprintf_internal_r+0x13c>
  806afc:	00bfffc4 	movi	r2,-1
  806b00:	88800226 	beq	r17,r2,806b0c <___vfprintf_internal_r+0x130>
  806b04:	8c4002a4 	muli	r17,r17,10
  806b08:	00000106 	br	806b10 <___vfprintf_internal_r+0x134>
  806b0c:	0023883a 	mov	r17,zero
  806b10:	2c63883a 	add	r17,r5,r17
  806b14:	0000e206 	br	806ea0 <___vfprintf_internal_r+0x4c4>
  806b18:	01400b84 	movi	r5,46
  806b1c:	1140e426 	beq	r2,r5,806eb0 <___vfprintf_internal_r+0x4d4>
  806b20:	05000084 	movi	r20,2
  806b24:	213ff404 	addi	r4,r4,-48
  806b28:	21003fcc 	andi	r4,r4,255
  806b2c:	00c00244 	movi	r3,9
  806b30:	19000736 	bltu	r3,r4,806b50 <___vfprintf_internal_r+0x174>
  806b34:	00bfffc4 	movi	r2,-1
  806b38:	90800226 	beq	r18,r2,806b44 <___vfprintf_internal_r+0x168>
  806b3c:	948002a4 	muli	r18,r18,10
  806b40:	00000106 	br	806b48 <___vfprintf_internal_r+0x16c>
  806b44:	0025883a 	mov	r18,zero
  806b48:	24a5883a 	add	r18,r4,r18
  806b4c:	0000db06 	br	806ebc <___vfprintf_internal_r+0x4e0>
  806b50:	00c01b04 	movi	r3,108
  806b54:	10c0d426 	beq	r2,r3,806ea8 <___vfprintf_internal_r+0x4cc>
  806b58:	013fffc4 	movi	r4,-1
  806b5c:	91000226 	beq	r18,r4,806b68 <___vfprintf_internal_r+0x18c>
  806b60:	d8000b15 	stw	zero,44(sp)
  806b64:	00000106 	br	806b6c <___vfprintf_internal_r+0x190>
  806b68:	04800044 	movi	r18,1
  806b6c:	01001a44 	movi	r4,105
  806b70:	11001626 	beq	r2,r4,806bcc <___vfprintf_internal_r+0x1f0>
  806b74:	20800916 	blt	r4,r2,806b9c <___vfprintf_internal_r+0x1c0>
  806b78:	010018c4 	movi	r4,99
  806b7c:	11008a26 	beq	r2,r4,806da8 <___vfprintf_internal_r+0x3cc>
  806b80:	01001904 	movi	r4,100
  806b84:	11001126 	beq	r2,r4,806bcc <___vfprintf_internal_r+0x1f0>
  806b88:	01001604 	movi	r4,88
  806b8c:	1100ca1e 	bne	r2,r4,806eb8 <___vfprintf_internal_r+0x4dc>
  806b90:	00c00044 	movi	r3,1
  806b94:	d8c00e15 	stw	r3,56(sp)
  806b98:	00001406 	br	806bec <___vfprintf_internal_r+0x210>
  806b9c:	01001cc4 	movi	r4,115
  806ba0:	11009a26 	beq	r2,r4,806e0c <___vfprintf_internal_r+0x430>
  806ba4:	20800416 	blt	r4,r2,806bb8 <___vfprintf_internal_r+0x1dc>
  806ba8:	01001bc4 	movi	r4,111
  806bac:	1100c21e 	bne	r2,r4,806eb8 <___vfprintf_internal_r+0x4dc>
  806bb0:	05400204 	movi	r21,8
  806bb4:	00000e06 	br	806bf0 <___vfprintf_internal_r+0x214>
  806bb8:	01001d44 	movi	r4,117
  806bbc:	11000c26 	beq	r2,r4,806bf0 <___vfprintf_internal_r+0x214>
  806bc0:	01001e04 	movi	r4,120
  806bc4:	11000926 	beq	r2,r4,806bec <___vfprintf_internal_r+0x210>
  806bc8:	0000bb06 	br	806eb8 <___vfprintf_internal_r+0x4dc>
  806bcc:	b5000104 	addi	r20,r22,4
  806bd0:	b8000726 	beq	r23,zero,806bf0 <___vfprintf_internal_r+0x214>
  806bd4:	dd000d15 	stw	r20,52(sp)
  806bd8:	b5800017 	ldw	r22,0(r22)
  806bdc:	b000080e 	bge	r22,zero,806c00 <___vfprintf_internal_r+0x224>
  806be0:	05adc83a 	sub	r22,zero,r22
  806be4:	02800044 	movi	r10,1
  806be8:	00000606 	br	806c04 <___vfprintf_internal_r+0x228>
  806bec:	05400404 	movi	r21,16
  806bf0:	b0c00104 	addi	r3,r22,4
  806bf4:	d8c00d15 	stw	r3,52(sp)
  806bf8:	b5800017 	ldw	r22,0(r22)
  806bfc:	002f883a 	mov	r23,zero
  806c00:	0015883a 	mov	r10,zero
  806c04:	d829883a 	mov	r20,sp
  806c08:	b0001426 	beq	r22,zero,806c5c <___vfprintf_internal_r+0x280>
  806c0c:	b009883a 	mov	r4,r22
  806c10:	a80b883a 	mov	r5,r21
  806c14:	da801015 	stw	r10,64(sp)
  806c18:	08078500 	call	807850 <__udivsi3>
  806c1c:	1549383a 	mul	r4,r2,r21
  806c20:	00c00244 	movi	r3,9
  806c24:	da801017 	ldw	r10,64(sp)
  806c28:	b12dc83a 	sub	r22,r22,r4
  806c2c:	1d800216 	blt	r3,r22,806c38 <___vfprintf_internal_r+0x25c>
  806c30:	b5800c04 	addi	r22,r22,48
  806c34:	00000506 	br	806c4c <___vfprintf_internal_r+0x270>
  806c38:	d8c00e17 	ldw	r3,56(sp)
  806c3c:	18000226 	beq	r3,zero,806c48 <___vfprintf_internal_r+0x26c>
  806c40:	b5800dc4 	addi	r22,r22,55
  806c44:	00000106 	br	806c4c <___vfprintf_internal_r+0x270>
  806c48:	b58015c4 	addi	r22,r22,87
  806c4c:	a5800005 	stb	r22,0(r20)
  806c50:	a5000044 	addi	r20,r20,1
  806c54:	102d883a 	mov	r22,r2
  806c58:	003feb06 	br	806c08 <__alt_mem_onchip_memory2_0+0xff786c08>
  806c5c:	a6c7c83a 	sub	r3,r20,sp
  806c60:	d8c00a15 	stw	r3,40(sp)
  806c64:	90c5c83a 	sub	r2,r18,r3
  806c68:	00800a0e 	bge	zero,r2,806c94 <___vfprintf_internal_r+0x2b8>
  806c6c:	a085883a 	add	r2,r20,r2
  806c70:	01400c04 	movi	r5,48
  806c74:	d8c00917 	ldw	r3,36(sp)
  806c78:	a009883a 	mov	r4,r20
  806c7c:	a0c0032e 	bgeu	r20,r3,806c8c <___vfprintf_internal_r+0x2b0>
  806c80:	a5000044 	addi	r20,r20,1
  806c84:	21400005 	stb	r5,0(r4)
  806c88:	a0bffa1e 	bne	r20,r2,806c74 <__alt_mem_onchip_memory2_0+0xff786c74>
  806c8c:	a6c7c83a 	sub	r3,r20,sp
  806c90:	d8c00a15 	stw	r3,40(sp)
  806c94:	d8c00a17 	ldw	r3,40(sp)
  806c98:	50d3883a 	add	r9,r10,r3
  806c9c:	d8c00b17 	ldw	r3,44(sp)
  806ca0:	8a6dc83a 	sub	r22,r17,r9
  806ca4:	18001726 	beq	r3,zero,806d04 <___vfprintf_internal_r+0x328>
  806ca8:	50000a26 	beq	r10,zero,806cd4 <___vfprintf_internal_r+0x2f8>
  806cac:	00800b44 	movi	r2,45
  806cb0:	d8800805 	stb	r2,32(sp)
  806cb4:	e0800117 	ldw	r2,4(fp)
  806cb8:	01c00044 	movi	r7,1
  806cbc:	d9800804 	addi	r6,sp,32
  806cc0:	e00b883a 	mov	r5,fp
  806cc4:	9809883a 	mov	r4,r19
  806cc8:	103ee83a 	callr	r2
  806ccc:	10004d1e 	bne	r2,zero,806e04 <___vfprintf_internal_r+0x428>
  806cd0:	84000044 	addi	r16,r16,1
  806cd4:	0580070e 	bge	zero,r22,806cf4 <___vfprintf_internal_r+0x318>
  806cd8:	b00f883a 	mov	r7,r22
  806cdc:	01800c04 	movi	r6,48
  806ce0:	e00b883a 	mov	r5,fp
  806ce4:	9809883a 	mov	r4,r19
  806ce8:	08069700 	call	806970 <print_repeat>
  806cec:	1000451e 	bne	r2,zero,806e04 <___vfprintf_internal_r+0x428>
  806cf0:	85a1883a 	add	r16,r16,r22
  806cf4:	d8c00a17 	ldw	r3,40(sp)
  806cf8:	a013883a 	mov	r9,r20
  806cfc:	1d2dc83a 	sub	r22,r3,r20
  806d00:	00002206 	br	806d8c <___vfprintf_internal_r+0x3b0>
  806d04:	0580090e 	bge	zero,r22,806d2c <___vfprintf_internal_r+0x350>
  806d08:	b00f883a 	mov	r7,r22
  806d0c:	01800804 	movi	r6,32
  806d10:	e00b883a 	mov	r5,fp
  806d14:	9809883a 	mov	r4,r19
  806d18:	da801015 	stw	r10,64(sp)
  806d1c:	08069700 	call	806970 <print_repeat>
  806d20:	da801017 	ldw	r10,64(sp)
  806d24:	1000371e 	bne	r2,zero,806e04 <___vfprintf_internal_r+0x428>
  806d28:	85a1883a 	add	r16,r16,r22
  806d2c:	503ff126 	beq	r10,zero,806cf4 <__alt_mem_onchip_memory2_0+0xff786cf4>
  806d30:	00800b44 	movi	r2,45
  806d34:	d8800805 	stb	r2,32(sp)
  806d38:	e0800117 	ldw	r2,4(fp)
  806d3c:	01c00044 	movi	r7,1
  806d40:	d9800804 	addi	r6,sp,32
  806d44:	e00b883a 	mov	r5,fp
  806d48:	9809883a 	mov	r4,r19
  806d4c:	103ee83a 	callr	r2
  806d50:	10002c1e 	bne	r2,zero,806e04 <___vfprintf_internal_r+0x428>
  806d54:	84000044 	addi	r16,r16,1
  806d58:	003fe606 	br	806cf4 <__alt_mem_onchip_memory2_0+0xff786cf4>
  806d5c:	4a7fffc4 	addi	r9,r9,-1
  806d60:	48800003 	ldbu	r2,0(r9)
  806d64:	01c00044 	movi	r7,1
  806d68:	d9800804 	addi	r6,sp,32
  806d6c:	d8800805 	stb	r2,32(sp)
  806d70:	e0800117 	ldw	r2,4(fp)
  806d74:	e00b883a 	mov	r5,fp
  806d78:	da401015 	stw	r9,64(sp)
  806d7c:	9809883a 	mov	r4,r19
  806d80:	103ee83a 	callr	r2
  806d84:	da401017 	ldw	r9,64(sp)
  806d88:	10001e1e 	bne	r2,zero,806e04 <___vfprintf_internal_r+0x428>
  806d8c:	8245c83a 	sub	r2,r16,r9
  806d90:	4d89883a 	add	r4,r9,r22
  806d94:	a085883a 	add	r2,r20,r2
  806d98:	013ff016 	blt	zero,r4,806d5c <__alt_mem_onchip_memory2_0+0xff786d5c>
  806d9c:	1021883a 	mov	r16,r2
  806da0:	dd800d17 	ldw	r22,52(sp)
  806da4:	00004406 	br	806eb8 <___vfprintf_internal_r+0x4dc>
  806da8:	00800044 	movi	r2,1
  806dac:	1440080e 	bge	r2,r17,806dd0 <___vfprintf_internal_r+0x3f4>
  806db0:	8d3fffc4 	addi	r20,r17,-1
  806db4:	a00f883a 	mov	r7,r20
  806db8:	01800804 	movi	r6,32
  806dbc:	e00b883a 	mov	r5,fp
  806dc0:	9809883a 	mov	r4,r19
  806dc4:	08069700 	call	806970 <print_repeat>
  806dc8:	10000e1e 	bne	r2,zero,806e04 <___vfprintf_internal_r+0x428>
  806dcc:	8521883a 	add	r16,r16,r20
  806dd0:	b0800017 	ldw	r2,0(r22)
  806dd4:	01c00044 	movi	r7,1
  806dd8:	d80d883a 	mov	r6,sp
  806ddc:	d8800005 	stb	r2,0(sp)
  806de0:	e0800117 	ldw	r2,4(fp)
  806de4:	e00b883a 	mov	r5,fp
  806de8:	9809883a 	mov	r4,r19
  806dec:	b5000104 	addi	r20,r22,4
  806df0:	103ee83a 	callr	r2
  806df4:	1000031e 	bne	r2,zero,806e04 <___vfprintf_internal_r+0x428>
  806df8:	84000044 	addi	r16,r16,1
  806dfc:	a02d883a 	mov	r22,r20
  806e00:	00002d06 	br	806eb8 <___vfprintf_internal_r+0x4dc>
  806e04:	00bfffc4 	movi	r2,-1
  806e08:	00003106 	br	806ed0 <___vfprintf_internal_r+0x4f4>
  806e0c:	b5000017 	ldw	r20,0(r22)
  806e10:	b0c00104 	addi	r3,r22,4
  806e14:	d8c00a15 	stw	r3,40(sp)
  806e18:	a009883a 	mov	r4,r20
  806e1c:	08068540 	call	806854 <strlen>
  806e20:	8893c83a 	sub	r9,r17,r2
  806e24:	102d883a 	mov	r22,r2
  806e28:	0240090e 	bge	zero,r9,806e50 <___vfprintf_internal_r+0x474>
  806e2c:	480f883a 	mov	r7,r9
  806e30:	01800804 	movi	r6,32
  806e34:	e00b883a 	mov	r5,fp
  806e38:	9809883a 	mov	r4,r19
  806e3c:	da401015 	stw	r9,64(sp)
  806e40:	08069700 	call	806970 <print_repeat>
  806e44:	da401017 	ldw	r9,64(sp)
  806e48:	103fee1e 	bne	r2,zero,806e04 <__alt_mem_onchip_memory2_0+0xff786e04>
  806e4c:	8261883a 	add	r16,r16,r9
  806e50:	e0800117 	ldw	r2,4(fp)
  806e54:	b00f883a 	mov	r7,r22
  806e58:	a00d883a 	mov	r6,r20
  806e5c:	e00b883a 	mov	r5,fp
  806e60:	9809883a 	mov	r4,r19
  806e64:	103ee83a 	callr	r2
  806e68:	103fe61e 	bne	r2,zero,806e04 <__alt_mem_onchip_memory2_0+0xff786e04>
  806e6c:	85a1883a 	add	r16,r16,r22
  806e70:	dd800a17 	ldw	r22,40(sp)
  806e74:	00001006 	br	806eb8 <___vfprintf_internal_r+0x4dc>
  806e78:	05c00044 	movi	r23,1
  806e7c:	04bfffc4 	movi	r18,-1
  806e80:	d8000e15 	stw	zero,56(sp)
  806e84:	05400284 	movi	r21,10
  806e88:	9023883a 	mov	r17,r18
  806e8c:	d8000c15 	stw	zero,48(sp)
  806e90:	d8000b15 	stw	zero,44(sp)
  806e94:	b829883a 	mov	r20,r23
  806e98:	00000806 	br	806ebc <___vfprintf_internal_r+0x4e0>
  806e9c:	dd000b15 	stw	r20,44(sp)
  806ea0:	05000084 	movi	r20,2
  806ea4:	00000506 	br	806ebc <___vfprintf_internal_r+0x4e0>
  806ea8:	00c00044 	movi	r3,1
  806eac:	d8c00c15 	stw	r3,48(sp)
  806eb0:	050000c4 	movi	r20,3
  806eb4:	00000106 	br	806ebc <___vfprintf_internal_r+0x4e0>
  806eb8:	0029883a 	mov	r20,zero
  806ebc:	d8c00f17 	ldw	r3,60(sp)
  806ec0:	18c00044 	addi	r3,r3,1
  806ec4:	d8c00f15 	stw	r3,60(sp)
  806ec8:	003ede06 	br	806a44 <__alt_mem_onchip_memory2_0+0xff786a44>
  806ecc:	8005883a 	mov	r2,r16
  806ed0:	dfc01a17 	ldw	ra,104(sp)
  806ed4:	df001917 	ldw	fp,100(sp)
  806ed8:	ddc01817 	ldw	r23,96(sp)
  806edc:	dd801717 	ldw	r22,92(sp)
  806ee0:	dd401617 	ldw	r21,88(sp)
  806ee4:	dd001517 	ldw	r20,84(sp)
  806ee8:	dcc01417 	ldw	r19,80(sp)
  806eec:	dc801317 	ldw	r18,76(sp)
  806ef0:	dc401217 	ldw	r17,72(sp)
  806ef4:	dc001117 	ldw	r16,68(sp)
  806ef8:	dec01b04 	addi	sp,sp,108
  806efc:	f800283a 	ret

00806f00 <__vfprintf_internal>:
  806f00:	00802074 	movhi	r2,129
  806f04:	10aadc04 	addi	r2,r2,-21648
  806f08:	300f883a 	mov	r7,r6
  806f0c:	280d883a 	mov	r6,r5
  806f10:	200b883a 	mov	r5,r4
  806f14:	11000017 	ldw	r4,0(r2)
  806f18:	08069dc1 	jmpi	8069dc <___vfprintf_internal_r>

00806f1c <_vsprintf_r>:
  806f1c:	defff804 	addi	sp,sp,-32
  806f20:	00808204 	movi	r2,520
  806f24:	d880000d 	sth	r2,0(sp)
  806f28:	00a00034 	movhi	r2,32768
  806f2c:	10bfffc4 	addi	r2,r2,-1
  806f30:	d8800515 	stw	r2,20(sp)
  806f34:	d8800315 	stw	r2,12(sp)
  806f38:	00bfffc4 	movi	r2,-1
  806f3c:	d880008d 	sth	r2,2(sp)
  806f40:	00802034 	movhi	r2,128
  806f44:	d9400415 	stw	r5,16(sp)
  806f48:	d9400215 	stw	r5,8(sp)
  806f4c:	109c1304 	addi	r2,r2,28748
  806f50:	d80b883a 	mov	r5,sp
  806f54:	dfc00715 	stw	ra,28(sp)
  806f58:	d8800115 	stw	r2,4(sp)
  806f5c:	d8000615 	stw	zero,24(sp)
  806f60:	08071c00 	call	8071c0 <___svfprintf_internal_r>
  806f64:	d8c00417 	ldw	r3,16(sp)
  806f68:	18000005 	stb	zero,0(r3)
  806f6c:	dfc00717 	ldw	ra,28(sp)
  806f70:	dec00804 	addi	sp,sp,32
  806f74:	f800283a 	ret

00806f78 <vsprintf>:
  806f78:	00802074 	movhi	r2,129
  806f7c:	10aadc04 	addi	r2,r2,-21648
  806f80:	300f883a 	mov	r7,r6
  806f84:	280d883a 	mov	r6,r5
  806f88:	200b883a 	mov	r5,r4
  806f8c:	11000017 	ldw	r4,0(r2)
  806f90:	0806f1c1 	jmpi	806f1c <_vsprintf_r>

00806f94 <__sfvwrite_small_dev>:
  806f94:	2880000b 	ldhu	r2,0(r5)
  806f98:	1080020c 	andi	r2,r2,8
  806f9c:	10002126 	beq	r2,zero,807024 <__sfvwrite_small_dev+0x90>
  806fa0:	2880008f 	ldh	r2,2(r5)
  806fa4:	defffa04 	addi	sp,sp,-24
  806fa8:	dc000015 	stw	r16,0(sp)
  806fac:	dfc00515 	stw	ra,20(sp)
  806fb0:	dd000415 	stw	r20,16(sp)
  806fb4:	dcc00315 	stw	r19,12(sp)
  806fb8:	dc800215 	stw	r18,8(sp)
  806fbc:	dc400115 	stw	r17,4(sp)
  806fc0:	2821883a 	mov	r16,r5
  806fc4:	10001216 	blt	r2,zero,807010 <__sfvwrite_small_dev+0x7c>
  806fc8:	2027883a 	mov	r19,r4
  806fcc:	3025883a 	mov	r18,r6
  806fd0:	3823883a 	mov	r17,r7
  806fd4:	05010004 	movi	r20,1024
  806fd8:	04400b0e 	bge	zero,r17,807008 <__sfvwrite_small_dev+0x74>
  806fdc:	880f883a 	mov	r7,r17
  806fe0:	a440010e 	bge	r20,r17,806fe8 <__sfvwrite_small_dev+0x54>
  806fe4:	01c10004 	movi	r7,1024
  806fe8:	8140008f 	ldh	r5,2(r16)
  806fec:	900d883a 	mov	r6,r18
  806ff0:	9809883a 	mov	r4,r19
  806ff4:	08077000 	call	807700 <_write_r>
  806ff8:	0080050e 	bge	zero,r2,807010 <__sfvwrite_small_dev+0x7c>
  806ffc:	88a3c83a 	sub	r17,r17,r2
  807000:	90a5883a 	add	r18,r18,r2
  807004:	003ff406 	br	806fd8 <__alt_mem_onchip_memory2_0+0xff786fd8>
  807008:	0005883a 	mov	r2,zero
  80700c:	00000706 	br	80702c <__sfvwrite_small_dev+0x98>
  807010:	8080000b 	ldhu	r2,0(r16)
  807014:	10801014 	ori	r2,r2,64
  807018:	8080000d 	sth	r2,0(r16)
  80701c:	00bfffc4 	movi	r2,-1
  807020:	00000206 	br	80702c <__sfvwrite_small_dev+0x98>
  807024:	00bfffc4 	movi	r2,-1
  807028:	f800283a 	ret
  80702c:	dfc00517 	ldw	ra,20(sp)
  807030:	dd000417 	ldw	r20,16(sp)
  807034:	dcc00317 	ldw	r19,12(sp)
  807038:	dc800217 	ldw	r18,8(sp)
  80703c:	dc400117 	ldw	r17,4(sp)
  807040:	dc000017 	ldw	r16,0(sp)
  807044:	dec00604 	addi	sp,sp,24
  807048:	f800283a 	ret

0080704c <__sfvwrite_small_str>:
  80704c:	2880000b 	ldhu	r2,0(r5)
  807050:	10c0020c 	andi	r3,r2,8
  807054:	18002026 	beq	r3,zero,8070d8 <__sfvwrite_small_str+0x8c>
  807058:	28c0008f 	ldh	r3,2(r5)
  80705c:	defffd04 	addi	sp,sp,-12
  807060:	dc000015 	stw	r16,0(sp)
  807064:	dfc00215 	stw	ra,8(sp)
  807068:	dc400115 	stw	r17,4(sp)
  80706c:	2821883a 	mov	r16,r5
  807070:	1800150e 	bge	r3,zero,8070c8 <__sfvwrite_small_str+0x7c>
  807074:	10c0800c 	andi	r3,r2,512
  807078:	18001326 	beq	r3,zero,8070c8 <__sfvwrite_small_str+0x7c>
  80707c:	2c400517 	ldw	r17,20(r5)
  807080:	89c0030e 	bge	r17,r7,807090 <__sfvwrite_small_str+0x44>
  807084:	10c0200c 	andi	r3,r2,128
  807088:	18000326 	beq	r3,zero,807098 <__sfvwrite_small_str+0x4c>
  80708c:	00000e06 	br	8070c8 <__sfvwrite_small_str+0x7c>
  807090:	3c40010e 	bge	r7,r17,807098 <__sfvwrite_small_str+0x4c>
  807094:	3823883a 	mov	r17,r7
  807098:	81000417 	ldw	r4,16(r16)
  80709c:	300b883a 	mov	r5,r6
  8070a0:	880d883a 	mov	r6,r17
  8070a4:	08070f40 	call	8070f4 <memmove>
  8070a8:	80800517 	ldw	r2,20(r16)
  8070ac:	1445c83a 	sub	r2,r2,r17
  8070b0:	80800515 	stw	r2,20(r16)
  8070b4:	80800417 	ldw	r2,16(r16)
  8070b8:	1463883a 	add	r17,r2,r17
  8070bc:	84400415 	stw	r17,16(r16)
  8070c0:	0005883a 	mov	r2,zero
  8070c4:	00000606 	br	8070e0 <__sfvwrite_small_str+0x94>
  8070c8:	10801014 	ori	r2,r2,64
  8070cc:	8080000d 	sth	r2,0(r16)
  8070d0:	00bfffc4 	movi	r2,-1
  8070d4:	00000206 	br	8070e0 <__sfvwrite_small_str+0x94>
  8070d8:	00bfffc4 	movi	r2,-1
  8070dc:	f800283a 	ret
  8070e0:	dfc00217 	ldw	ra,8(sp)
  8070e4:	dc400117 	ldw	r17,4(sp)
  8070e8:	dc000017 	ldw	r16,0(sp)
  8070ec:	dec00304 	addi	sp,sp,12
  8070f0:	f800283a 	ret

008070f4 <memmove>:
  8070f4:	2005883a 	mov	r2,r4
  8070f8:	218f883a 	add	r7,r4,r6
  8070fc:	29000236 	bltu	r5,r4,807108 <memmove+0x14>
  807100:	1007883a 	mov	r3,r2
  807104:	00000c06 	br	807138 <memmove+0x44>
  807108:	2987883a 	add	r3,r5,r6
  80710c:	20fffc2e 	bgeu	r4,r3,807100 <__alt_mem_onchip_memory2_0+0xff787100>
  807110:	380b883a 	mov	r5,r7
  807114:	30cdc83a 	sub	r6,r6,r3
  807118:	1989883a 	add	r4,r3,r6
  80711c:	20000526 	beq	r4,zero,807134 <memmove+0x40>
  807120:	18ffffc4 	addi	r3,r3,-1
  807124:	19000003 	ldbu	r4,0(r3)
  807128:	297fffc4 	addi	r5,r5,-1
  80712c:	29000005 	stb	r4,0(r5)
  807130:	003ff906 	br	807118 <__alt_mem_onchip_memory2_0+0xff787118>
  807134:	f800283a 	ret
  807138:	19c00526 	beq	r3,r7,807150 <memmove+0x5c>
  80713c:	29000003 	ldbu	r4,0(r5)
  807140:	18c00044 	addi	r3,r3,1
  807144:	29400044 	addi	r5,r5,1
  807148:	193fffc5 	stb	r4,-1(r3)
  80714c:	003ffa06 	br	807138 <__alt_mem_onchip_memory2_0+0xff787138>
  807150:	f800283a 	ret

00807154 <print_repeat>:
  807154:	defffb04 	addi	sp,sp,-20
  807158:	dc800315 	stw	r18,12(sp)
  80715c:	dc400215 	stw	r17,8(sp)
  807160:	dc000115 	stw	r16,4(sp)
  807164:	dfc00415 	stw	ra,16(sp)
  807168:	2025883a 	mov	r18,r4
  80716c:	2823883a 	mov	r17,r5
  807170:	d9800005 	stb	r6,0(sp)
  807174:	3821883a 	mov	r16,r7
  807178:	04000a0e 	bge	zero,r16,8071a4 <print_repeat+0x50>
  80717c:	88800117 	ldw	r2,4(r17)
  807180:	01c00044 	movi	r7,1
  807184:	d80d883a 	mov	r6,sp
  807188:	880b883a 	mov	r5,r17
  80718c:	9009883a 	mov	r4,r18
  807190:	103ee83a 	callr	r2
  807194:	843fffc4 	addi	r16,r16,-1
  807198:	103ff726 	beq	r2,zero,807178 <__alt_mem_onchip_memory2_0+0xff787178>
  80719c:	00bfffc4 	movi	r2,-1
  8071a0:	00000106 	br	8071a8 <print_repeat+0x54>
  8071a4:	0005883a 	mov	r2,zero
  8071a8:	dfc00417 	ldw	ra,16(sp)
  8071ac:	dc800317 	ldw	r18,12(sp)
  8071b0:	dc400217 	ldw	r17,8(sp)
  8071b4:	dc000117 	ldw	r16,4(sp)
  8071b8:	dec00504 	addi	sp,sp,20
  8071bc:	f800283a 	ret

008071c0 <___svfprintf_internal_r>:
  8071c0:	deffe504 	addi	sp,sp,-108
  8071c4:	d8c00804 	addi	r3,sp,32
  8071c8:	df001915 	stw	fp,100(sp)
  8071cc:	ddc01815 	stw	r23,96(sp)
  8071d0:	dd801715 	stw	r22,92(sp)
  8071d4:	dd401615 	stw	r21,88(sp)
  8071d8:	dd001515 	stw	r20,84(sp)
  8071dc:	dcc01415 	stw	r19,80(sp)
  8071e0:	dc801315 	stw	r18,76(sp)
  8071e4:	dc401215 	stw	r17,72(sp)
  8071e8:	dc001115 	stw	r16,68(sp)
  8071ec:	dfc01a15 	stw	ra,104(sp)
  8071f0:	2027883a 	mov	r19,r4
  8071f4:	2839883a 	mov	fp,r5
  8071f8:	382d883a 	mov	r22,r7
  8071fc:	d9800f15 	stw	r6,60(sp)
  807200:	0021883a 	mov	r16,zero
  807204:	d8000e15 	stw	zero,56(sp)
  807208:	002f883a 	mov	r23,zero
  80720c:	002b883a 	mov	r21,zero
  807210:	0025883a 	mov	r18,zero
  807214:	0023883a 	mov	r17,zero
  807218:	d8000c15 	stw	zero,48(sp)
  80721c:	d8000b15 	stw	zero,44(sp)
  807220:	0029883a 	mov	r20,zero
  807224:	d8c00915 	stw	r3,36(sp)
  807228:	d8c00f17 	ldw	r3,60(sp)
  80722c:	19000003 	ldbu	r4,0(r3)
  807230:	20803fcc 	andi	r2,r4,255
  807234:	1080201c 	xori	r2,r2,128
  807238:	10bfe004 	addi	r2,r2,-128
  80723c:	10011c26 	beq	r2,zero,8076b0 <___svfprintf_internal_r+0x4f0>
  807240:	00c00044 	movi	r3,1
  807244:	a0c01426 	beq	r20,r3,807298 <___svfprintf_internal_r+0xd8>
  807248:	1d000216 	blt	r3,r20,807254 <___svfprintf_internal_r+0x94>
  80724c:	a0000626 	beq	r20,zero,807268 <___svfprintf_internal_r+0xa8>
  807250:	00011306 	br	8076a0 <___svfprintf_internal_r+0x4e0>
  807254:	01400084 	movi	r5,2
  807258:	a1401d26 	beq	r20,r5,8072d0 <___svfprintf_internal_r+0x110>
  80725c:	014000c4 	movi	r5,3
  807260:	a1402926 	beq	r20,r5,807308 <___svfprintf_internal_r+0x148>
  807264:	00010e06 	br	8076a0 <___svfprintf_internal_r+0x4e0>
  807268:	01400944 	movi	r5,37
  80726c:	1140fb26 	beq	r2,r5,80765c <___svfprintf_internal_r+0x49c>
  807270:	e0800117 	ldw	r2,4(fp)
  807274:	d9000005 	stb	r4,0(sp)
  807278:	01c00044 	movi	r7,1
  80727c:	d80d883a 	mov	r6,sp
  807280:	e00b883a 	mov	r5,fp
  807284:	9809883a 	mov	r4,r19
  807288:	103ee83a 	callr	r2
  80728c:	1000d61e 	bne	r2,zero,8075e8 <___svfprintf_internal_r+0x428>
  807290:	84000044 	addi	r16,r16,1
  807294:	00010206 	br	8076a0 <___svfprintf_internal_r+0x4e0>
  807298:	01400c04 	movi	r5,48
  80729c:	1140f826 	beq	r2,r5,807680 <___svfprintf_internal_r+0x4c0>
  8072a0:	01400944 	movi	r5,37
  8072a4:	11400a1e 	bne	r2,r5,8072d0 <___svfprintf_internal_r+0x110>
  8072a8:	d8800005 	stb	r2,0(sp)
  8072ac:	e0800117 	ldw	r2,4(fp)
  8072b0:	a00f883a 	mov	r7,r20
  8072b4:	d80d883a 	mov	r6,sp
  8072b8:	e00b883a 	mov	r5,fp
  8072bc:	9809883a 	mov	r4,r19
  8072c0:	103ee83a 	callr	r2
  8072c4:	1000c81e 	bne	r2,zero,8075e8 <___svfprintf_internal_r+0x428>
  8072c8:	84000044 	addi	r16,r16,1
  8072cc:	0000f306 	br	80769c <___svfprintf_internal_r+0x4dc>
  8072d0:	217ff404 	addi	r5,r4,-48
  8072d4:	29403fcc 	andi	r5,r5,255
  8072d8:	00c00244 	movi	r3,9
  8072dc:	19400736 	bltu	r3,r5,8072fc <___svfprintf_internal_r+0x13c>
  8072e0:	00bfffc4 	movi	r2,-1
  8072e4:	88800226 	beq	r17,r2,8072f0 <___svfprintf_internal_r+0x130>
  8072e8:	8c4002a4 	muli	r17,r17,10
  8072ec:	00000106 	br	8072f4 <___svfprintf_internal_r+0x134>
  8072f0:	0023883a 	mov	r17,zero
  8072f4:	2c63883a 	add	r17,r5,r17
  8072f8:	0000e206 	br	807684 <___svfprintf_internal_r+0x4c4>
  8072fc:	01400b84 	movi	r5,46
  807300:	1140e426 	beq	r2,r5,807694 <___svfprintf_internal_r+0x4d4>
  807304:	05000084 	movi	r20,2
  807308:	213ff404 	addi	r4,r4,-48
  80730c:	21003fcc 	andi	r4,r4,255
  807310:	00c00244 	movi	r3,9
  807314:	19000736 	bltu	r3,r4,807334 <___svfprintf_internal_r+0x174>
  807318:	00bfffc4 	movi	r2,-1
  80731c:	90800226 	beq	r18,r2,807328 <___svfprintf_internal_r+0x168>
  807320:	948002a4 	muli	r18,r18,10
  807324:	00000106 	br	80732c <___svfprintf_internal_r+0x16c>
  807328:	0025883a 	mov	r18,zero
  80732c:	24a5883a 	add	r18,r4,r18
  807330:	0000db06 	br	8076a0 <___svfprintf_internal_r+0x4e0>
  807334:	00c01b04 	movi	r3,108
  807338:	10c0d426 	beq	r2,r3,80768c <___svfprintf_internal_r+0x4cc>
  80733c:	013fffc4 	movi	r4,-1
  807340:	91000226 	beq	r18,r4,80734c <___svfprintf_internal_r+0x18c>
  807344:	d8000b15 	stw	zero,44(sp)
  807348:	00000106 	br	807350 <___svfprintf_internal_r+0x190>
  80734c:	04800044 	movi	r18,1
  807350:	01001a44 	movi	r4,105
  807354:	11001626 	beq	r2,r4,8073b0 <___svfprintf_internal_r+0x1f0>
  807358:	20800916 	blt	r4,r2,807380 <___svfprintf_internal_r+0x1c0>
  80735c:	010018c4 	movi	r4,99
  807360:	11008a26 	beq	r2,r4,80758c <___svfprintf_internal_r+0x3cc>
  807364:	01001904 	movi	r4,100
  807368:	11001126 	beq	r2,r4,8073b0 <___svfprintf_internal_r+0x1f0>
  80736c:	01001604 	movi	r4,88
  807370:	1100ca1e 	bne	r2,r4,80769c <___svfprintf_internal_r+0x4dc>
  807374:	00c00044 	movi	r3,1
  807378:	d8c00e15 	stw	r3,56(sp)
  80737c:	00001406 	br	8073d0 <___svfprintf_internal_r+0x210>
  807380:	01001cc4 	movi	r4,115
  807384:	11009a26 	beq	r2,r4,8075f0 <___svfprintf_internal_r+0x430>
  807388:	20800416 	blt	r4,r2,80739c <___svfprintf_internal_r+0x1dc>
  80738c:	01001bc4 	movi	r4,111
  807390:	1100c21e 	bne	r2,r4,80769c <___svfprintf_internal_r+0x4dc>
  807394:	05400204 	movi	r21,8
  807398:	00000e06 	br	8073d4 <___svfprintf_internal_r+0x214>
  80739c:	01001d44 	movi	r4,117
  8073a0:	11000c26 	beq	r2,r4,8073d4 <___svfprintf_internal_r+0x214>
  8073a4:	01001e04 	movi	r4,120
  8073a8:	11000926 	beq	r2,r4,8073d0 <___svfprintf_internal_r+0x210>
  8073ac:	0000bb06 	br	80769c <___svfprintf_internal_r+0x4dc>
  8073b0:	b5000104 	addi	r20,r22,4
  8073b4:	b8000726 	beq	r23,zero,8073d4 <___svfprintf_internal_r+0x214>
  8073b8:	dd000d15 	stw	r20,52(sp)
  8073bc:	b5800017 	ldw	r22,0(r22)
  8073c0:	b000080e 	bge	r22,zero,8073e4 <___svfprintf_internal_r+0x224>
  8073c4:	05adc83a 	sub	r22,zero,r22
  8073c8:	02800044 	movi	r10,1
  8073cc:	00000606 	br	8073e8 <___svfprintf_internal_r+0x228>
  8073d0:	05400404 	movi	r21,16
  8073d4:	b0c00104 	addi	r3,r22,4
  8073d8:	d8c00d15 	stw	r3,52(sp)
  8073dc:	b5800017 	ldw	r22,0(r22)
  8073e0:	002f883a 	mov	r23,zero
  8073e4:	0015883a 	mov	r10,zero
  8073e8:	d829883a 	mov	r20,sp
  8073ec:	b0001426 	beq	r22,zero,807440 <___svfprintf_internal_r+0x280>
  8073f0:	b009883a 	mov	r4,r22
  8073f4:	a80b883a 	mov	r5,r21
  8073f8:	da801015 	stw	r10,64(sp)
  8073fc:	08078500 	call	807850 <__udivsi3>
  807400:	1549383a 	mul	r4,r2,r21
  807404:	00c00244 	movi	r3,9
  807408:	da801017 	ldw	r10,64(sp)
  80740c:	b12dc83a 	sub	r22,r22,r4
  807410:	1d800216 	blt	r3,r22,80741c <___svfprintf_internal_r+0x25c>
  807414:	b5800c04 	addi	r22,r22,48
  807418:	00000506 	br	807430 <___svfprintf_internal_r+0x270>
  80741c:	d8c00e17 	ldw	r3,56(sp)
  807420:	18000226 	beq	r3,zero,80742c <___svfprintf_internal_r+0x26c>
  807424:	b5800dc4 	addi	r22,r22,55
  807428:	00000106 	br	807430 <___svfprintf_internal_r+0x270>
  80742c:	b58015c4 	addi	r22,r22,87
  807430:	a5800005 	stb	r22,0(r20)
  807434:	a5000044 	addi	r20,r20,1
  807438:	102d883a 	mov	r22,r2
  80743c:	003feb06 	br	8073ec <__alt_mem_onchip_memory2_0+0xff7873ec>
  807440:	a6c7c83a 	sub	r3,r20,sp
  807444:	d8c00a15 	stw	r3,40(sp)
  807448:	90c5c83a 	sub	r2,r18,r3
  80744c:	00800a0e 	bge	zero,r2,807478 <___svfprintf_internal_r+0x2b8>
  807450:	a085883a 	add	r2,r20,r2
  807454:	01400c04 	movi	r5,48
  807458:	d8c00917 	ldw	r3,36(sp)
  80745c:	a009883a 	mov	r4,r20
  807460:	a0c0032e 	bgeu	r20,r3,807470 <___svfprintf_internal_r+0x2b0>
  807464:	a5000044 	addi	r20,r20,1
  807468:	21400005 	stb	r5,0(r4)
  80746c:	a0bffa1e 	bne	r20,r2,807458 <__alt_mem_onchip_memory2_0+0xff787458>
  807470:	a6c7c83a 	sub	r3,r20,sp
  807474:	d8c00a15 	stw	r3,40(sp)
  807478:	d8c00a17 	ldw	r3,40(sp)
  80747c:	50d3883a 	add	r9,r10,r3
  807480:	d8c00b17 	ldw	r3,44(sp)
  807484:	8a6dc83a 	sub	r22,r17,r9
  807488:	18001726 	beq	r3,zero,8074e8 <___svfprintf_internal_r+0x328>
  80748c:	50000a26 	beq	r10,zero,8074b8 <___svfprintf_internal_r+0x2f8>
  807490:	00800b44 	movi	r2,45
  807494:	d8800805 	stb	r2,32(sp)
  807498:	e0800117 	ldw	r2,4(fp)
  80749c:	01c00044 	movi	r7,1
  8074a0:	d9800804 	addi	r6,sp,32
  8074a4:	e00b883a 	mov	r5,fp
  8074a8:	9809883a 	mov	r4,r19
  8074ac:	103ee83a 	callr	r2
  8074b0:	10004d1e 	bne	r2,zero,8075e8 <___svfprintf_internal_r+0x428>
  8074b4:	84000044 	addi	r16,r16,1
  8074b8:	0580070e 	bge	zero,r22,8074d8 <___svfprintf_internal_r+0x318>
  8074bc:	b00f883a 	mov	r7,r22
  8074c0:	01800c04 	movi	r6,48
  8074c4:	e00b883a 	mov	r5,fp
  8074c8:	9809883a 	mov	r4,r19
  8074cc:	08071540 	call	807154 <print_repeat>
  8074d0:	1000451e 	bne	r2,zero,8075e8 <___svfprintf_internal_r+0x428>
  8074d4:	85a1883a 	add	r16,r16,r22
  8074d8:	d8c00a17 	ldw	r3,40(sp)
  8074dc:	a013883a 	mov	r9,r20
  8074e0:	1d2dc83a 	sub	r22,r3,r20
  8074e4:	00002206 	br	807570 <___svfprintf_internal_r+0x3b0>
  8074e8:	0580090e 	bge	zero,r22,807510 <___svfprintf_internal_r+0x350>
  8074ec:	b00f883a 	mov	r7,r22
  8074f0:	01800804 	movi	r6,32
  8074f4:	e00b883a 	mov	r5,fp
  8074f8:	9809883a 	mov	r4,r19
  8074fc:	da801015 	stw	r10,64(sp)
  807500:	08071540 	call	807154 <print_repeat>
  807504:	da801017 	ldw	r10,64(sp)
  807508:	1000371e 	bne	r2,zero,8075e8 <___svfprintf_internal_r+0x428>
  80750c:	85a1883a 	add	r16,r16,r22
  807510:	503ff126 	beq	r10,zero,8074d8 <__alt_mem_onchip_memory2_0+0xff7874d8>
  807514:	00800b44 	movi	r2,45
  807518:	d8800805 	stb	r2,32(sp)
  80751c:	e0800117 	ldw	r2,4(fp)
  807520:	01c00044 	movi	r7,1
  807524:	d9800804 	addi	r6,sp,32
  807528:	e00b883a 	mov	r5,fp
  80752c:	9809883a 	mov	r4,r19
  807530:	103ee83a 	callr	r2
  807534:	10002c1e 	bne	r2,zero,8075e8 <___svfprintf_internal_r+0x428>
  807538:	84000044 	addi	r16,r16,1
  80753c:	003fe606 	br	8074d8 <__alt_mem_onchip_memory2_0+0xff7874d8>
  807540:	4a7fffc4 	addi	r9,r9,-1
  807544:	48800003 	ldbu	r2,0(r9)
  807548:	01c00044 	movi	r7,1
  80754c:	d9800804 	addi	r6,sp,32
  807550:	d8800805 	stb	r2,32(sp)
  807554:	e0800117 	ldw	r2,4(fp)
  807558:	e00b883a 	mov	r5,fp
  80755c:	da401015 	stw	r9,64(sp)
  807560:	9809883a 	mov	r4,r19
  807564:	103ee83a 	callr	r2
  807568:	da401017 	ldw	r9,64(sp)
  80756c:	10001e1e 	bne	r2,zero,8075e8 <___svfprintf_internal_r+0x428>
  807570:	8245c83a 	sub	r2,r16,r9
  807574:	4d89883a 	add	r4,r9,r22
  807578:	a085883a 	add	r2,r20,r2
  80757c:	013ff016 	blt	zero,r4,807540 <__alt_mem_onchip_memory2_0+0xff787540>
  807580:	1021883a 	mov	r16,r2
  807584:	dd800d17 	ldw	r22,52(sp)
  807588:	00004406 	br	80769c <___svfprintf_internal_r+0x4dc>
  80758c:	00800044 	movi	r2,1
  807590:	1440080e 	bge	r2,r17,8075b4 <___svfprintf_internal_r+0x3f4>
  807594:	8d3fffc4 	addi	r20,r17,-1
  807598:	a00f883a 	mov	r7,r20
  80759c:	01800804 	movi	r6,32
  8075a0:	e00b883a 	mov	r5,fp
  8075a4:	9809883a 	mov	r4,r19
  8075a8:	08071540 	call	807154 <print_repeat>
  8075ac:	10000e1e 	bne	r2,zero,8075e8 <___svfprintf_internal_r+0x428>
  8075b0:	8521883a 	add	r16,r16,r20
  8075b4:	b0800017 	ldw	r2,0(r22)
  8075b8:	01c00044 	movi	r7,1
  8075bc:	d80d883a 	mov	r6,sp
  8075c0:	d8800005 	stb	r2,0(sp)
  8075c4:	e0800117 	ldw	r2,4(fp)
  8075c8:	e00b883a 	mov	r5,fp
  8075cc:	9809883a 	mov	r4,r19
  8075d0:	b5000104 	addi	r20,r22,4
  8075d4:	103ee83a 	callr	r2
  8075d8:	1000031e 	bne	r2,zero,8075e8 <___svfprintf_internal_r+0x428>
  8075dc:	84000044 	addi	r16,r16,1
  8075e0:	a02d883a 	mov	r22,r20
  8075e4:	00002d06 	br	80769c <___svfprintf_internal_r+0x4dc>
  8075e8:	00bfffc4 	movi	r2,-1
  8075ec:	00003106 	br	8076b4 <___svfprintf_internal_r+0x4f4>
  8075f0:	b5000017 	ldw	r20,0(r22)
  8075f4:	b0c00104 	addi	r3,r22,4
  8075f8:	d8c00a15 	stw	r3,40(sp)
  8075fc:	a009883a 	mov	r4,r20
  807600:	08068540 	call	806854 <strlen>
  807604:	8893c83a 	sub	r9,r17,r2
  807608:	102d883a 	mov	r22,r2
  80760c:	0240090e 	bge	zero,r9,807634 <___svfprintf_internal_r+0x474>
  807610:	480f883a 	mov	r7,r9
  807614:	01800804 	movi	r6,32
  807618:	e00b883a 	mov	r5,fp
  80761c:	9809883a 	mov	r4,r19
  807620:	da401015 	stw	r9,64(sp)
  807624:	08071540 	call	807154 <print_repeat>
  807628:	da401017 	ldw	r9,64(sp)
  80762c:	103fee1e 	bne	r2,zero,8075e8 <__alt_mem_onchip_memory2_0+0xff7875e8>
  807630:	8261883a 	add	r16,r16,r9
  807634:	e0800117 	ldw	r2,4(fp)
  807638:	b00f883a 	mov	r7,r22
  80763c:	a00d883a 	mov	r6,r20
  807640:	e00b883a 	mov	r5,fp
  807644:	9809883a 	mov	r4,r19
  807648:	103ee83a 	callr	r2
  80764c:	103fe61e 	bne	r2,zero,8075e8 <__alt_mem_onchip_memory2_0+0xff7875e8>
  807650:	85a1883a 	add	r16,r16,r22
  807654:	dd800a17 	ldw	r22,40(sp)
  807658:	00001006 	br	80769c <___svfprintf_internal_r+0x4dc>
  80765c:	05c00044 	movi	r23,1
  807660:	04bfffc4 	movi	r18,-1
  807664:	d8000e15 	stw	zero,56(sp)
  807668:	05400284 	movi	r21,10
  80766c:	9023883a 	mov	r17,r18
  807670:	d8000c15 	stw	zero,48(sp)
  807674:	d8000b15 	stw	zero,44(sp)
  807678:	b829883a 	mov	r20,r23
  80767c:	00000806 	br	8076a0 <___svfprintf_internal_r+0x4e0>
  807680:	dd000b15 	stw	r20,44(sp)
  807684:	05000084 	movi	r20,2
  807688:	00000506 	br	8076a0 <___svfprintf_internal_r+0x4e0>
  80768c:	00c00044 	movi	r3,1
  807690:	d8c00c15 	stw	r3,48(sp)
  807694:	050000c4 	movi	r20,3
  807698:	00000106 	br	8076a0 <___svfprintf_internal_r+0x4e0>
  80769c:	0029883a 	mov	r20,zero
  8076a0:	d8c00f17 	ldw	r3,60(sp)
  8076a4:	18c00044 	addi	r3,r3,1
  8076a8:	d8c00f15 	stw	r3,60(sp)
  8076ac:	003ede06 	br	807228 <__alt_mem_onchip_memory2_0+0xff787228>
  8076b0:	8005883a 	mov	r2,r16
  8076b4:	dfc01a17 	ldw	ra,104(sp)
  8076b8:	df001917 	ldw	fp,100(sp)
  8076bc:	ddc01817 	ldw	r23,96(sp)
  8076c0:	dd801717 	ldw	r22,92(sp)
  8076c4:	dd401617 	ldw	r21,88(sp)
  8076c8:	dd001517 	ldw	r20,84(sp)
  8076cc:	dcc01417 	ldw	r19,80(sp)
  8076d0:	dc801317 	ldw	r18,76(sp)
  8076d4:	dc401217 	ldw	r17,72(sp)
  8076d8:	dc001117 	ldw	r16,68(sp)
  8076dc:	dec01b04 	addi	sp,sp,108
  8076e0:	f800283a 	ret

008076e4 <__vfprintf_internal_unused>:
  8076e4:	00802074 	movhi	r2,129
  8076e8:	10aadc04 	addi	r2,r2,-21648
  8076ec:	300f883a 	mov	r7,r6
  8076f0:	280d883a 	mov	r6,r5
  8076f4:	200b883a 	mov	r5,r4
  8076f8:	11000017 	ldw	r4,0(r2)
  8076fc:	08071c01 	jmpi	8071c0 <___svfprintf_internal_r>

00807700 <_write_r>:
  807700:	defffd04 	addi	sp,sp,-12
  807704:	dc000015 	stw	r16,0(sp)
  807708:	04002074 	movhi	r16,129
  80770c:	dc400115 	stw	r17,4(sp)
  807710:	842ff304 	addi	r16,r16,-16436
  807714:	2023883a 	mov	r17,r4
  807718:	2809883a 	mov	r4,r5
  80771c:	300b883a 	mov	r5,r6
  807720:	380d883a 	mov	r6,r7
  807724:	dfc00215 	stw	ra,8(sp)
  807728:	80000015 	stw	zero,0(r16)
  80772c:	0807af80 	call	807af8 <write>
  807730:	00ffffc4 	movi	r3,-1
  807734:	10c0031e 	bne	r2,r3,807744 <_write_r+0x44>
  807738:	80c00017 	ldw	r3,0(r16)
  80773c:	18000126 	beq	r3,zero,807744 <_write_r+0x44>
  807740:	88c00015 	stw	r3,0(r17)
  807744:	dfc00217 	ldw	ra,8(sp)
  807748:	dc400117 	ldw	r17,4(sp)
  80774c:	dc000017 	ldw	r16,0(sp)
  807750:	dec00304 	addi	sp,sp,12
  807754:	f800283a 	ret

00807758 <__divsi3>:
  807758:	20001b16 	blt	r4,zero,8077c8 <__divsi3+0x70>
  80775c:	000f883a 	mov	r7,zero
  807760:	28001616 	blt	r5,zero,8077bc <__divsi3+0x64>
  807764:	200d883a 	mov	r6,r4
  807768:	29001a2e 	bgeu	r5,r4,8077d4 <__divsi3+0x7c>
  80776c:	00800804 	movi	r2,32
  807770:	00c00044 	movi	r3,1
  807774:	00000106 	br	80777c <__divsi3+0x24>
  807778:	10000d26 	beq	r2,zero,8077b0 <__divsi3+0x58>
  80777c:	294b883a 	add	r5,r5,r5
  807780:	10bfffc4 	addi	r2,r2,-1
  807784:	18c7883a 	add	r3,r3,r3
  807788:	293ffb36 	bltu	r5,r4,807778 <__alt_mem_onchip_memory2_0+0xff787778>
  80778c:	0005883a 	mov	r2,zero
  807790:	18000726 	beq	r3,zero,8077b0 <__divsi3+0x58>
  807794:	0005883a 	mov	r2,zero
  807798:	31400236 	bltu	r6,r5,8077a4 <__divsi3+0x4c>
  80779c:	314dc83a 	sub	r6,r6,r5
  8077a0:	10c4b03a 	or	r2,r2,r3
  8077a4:	1806d07a 	srli	r3,r3,1
  8077a8:	280ad07a 	srli	r5,r5,1
  8077ac:	183ffa1e 	bne	r3,zero,807798 <__alt_mem_onchip_memory2_0+0xff787798>
  8077b0:	38000126 	beq	r7,zero,8077b8 <__divsi3+0x60>
  8077b4:	0085c83a 	sub	r2,zero,r2
  8077b8:	f800283a 	ret
  8077bc:	014bc83a 	sub	r5,zero,r5
  8077c0:	39c0005c 	xori	r7,r7,1
  8077c4:	003fe706 	br	807764 <__alt_mem_onchip_memory2_0+0xff787764>
  8077c8:	0109c83a 	sub	r4,zero,r4
  8077cc:	01c00044 	movi	r7,1
  8077d0:	003fe306 	br	807760 <__alt_mem_onchip_memory2_0+0xff787760>
  8077d4:	00c00044 	movi	r3,1
  8077d8:	003fee06 	br	807794 <__alt_mem_onchip_memory2_0+0xff787794>

008077dc <__modsi3>:
  8077dc:	20001716 	blt	r4,zero,80783c <__modsi3+0x60>
  8077e0:	000f883a 	mov	r7,zero
  8077e4:	2005883a 	mov	r2,r4
  8077e8:	28001216 	blt	r5,zero,807834 <__modsi3+0x58>
  8077ec:	2900162e 	bgeu	r5,r4,807848 <__modsi3+0x6c>
  8077f0:	01800804 	movi	r6,32
  8077f4:	00c00044 	movi	r3,1
  8077f8:	00000106 	br	807800 <__modsi3+0x24>
  8077fc:	30000a26 	beq	r6,zero,807828 <__modsi3+0x4c>
  807800:	294b883a 	add	r5,r5,r5
  807804:	31bfffc4 	addi	r6,r6,-1
  807808:	18c7883a 	add	r3,r3,r3
  80780c:	293ffb36 	bltu	r5,r4,8077fc <__alt_mem_onchip_memory2_0+0xff7877fc>
  807810:	18000526 	beq	r3,zero,807828 <__modsi3+0x4c>
  807814:	1806d07a 	srli	r3,r3,1
  807818:	11400136 	bltu	r2,r5,807820 <__modsi3+0x44>
  80781c:	1145c83a 	sub	r2,r2,r5
  807820:	280ad07a 	srli	r5,r5,1
  807824:	183ffb1e 	bne	r3,zero,807814 <__alt_mem_onchip_memory2_0+0xff787814>
  807828:	38000126 	beq	r7,zero,807830 <__modsi3+0x54>
  80782c:	0085c83a 	sub	r2,zero,r2
  807830:	f800283a 	ret
  807834:	014bc83a 	sub	r5,zero,r5
  807838:	003fec06 	br	8077ec <__alt_mem_onchip_memory2_0+0xff7877ec>
  80783c:	0109c83a 	sub	r4,zero,r4
  807840:	01c00044 	movi	r7,1
  807844:	003fe706 	br	8077e4 <__alt_mem_onchip_memory2_0+0xff7877e4>
  807848:	00c00044 	movi	r3,1
  80784c:	003ff106 	br	807814 <__alt_mem_onchip_memory2_0+0xff787814>

00807850 <__udivsi3>:
  807850:	200d883a 	mov	r6,r4
  807854:	2900152e 	bgeu	r5,r4,8078ac <__udivsi3+0x5c>
  807858:	28001416 	blt	r5,zero,8078ac <__udivsi3+0x5c>
  80785c:	00800804 	movi	r2,32
  807860:	00c00044 	movi	r3,1
  807864:	00000206 	br	807870 <__udivsi3+0x20>
  807868:	10000e26 	beq	r2,zero,8078a4 <__udivsi3+0x54>
  80786c:	28000516 	blt	r5,zero,807884 <__udivsi3+0x34>
  807870:	294b883a 	add	r5,r5,r5
  807874:	10bfffc4 	addi	r2,r2,-1
  807878:	18c7883a 	add	r3,r3,r3
  80787c:	293ffa36 	bltu	r5,r4,807868 <__alt_mem_onchip_memory2_0+0xff787868>
  807880:	18000826 	beq	r3,zero,8078a4 <__udivsi3+0x54>
  807884:	0005883a 	mov	r2,zero
  807888:	31400236 	bltu	r6,r5,807894 <__udivsi3+0x44>
  80788c:	314dc83a 	sub	r6,r6,r5
  807890:	10c4b03a 	or	r2,r2,r3
  807894:	1806d07a 	srli	r3,r3,1
  807898:	280ad07a 	srli	r5,r5,1
  80789c:	183ffa1e 	bne	r3,zero,807888 <__alt_mem_onchip_memory2_0+0xff787888>
  8078a0:	f800283a 	ret
  8078a4:	0005883a 	mov	r2,zero
  8078a8:	f800283a 	ret
  8078ac:	00c00044 	movi	r3,1
  8078b0:	003ff406 	br	807884 <__alt_mem_onchip_memory2_0+0xff787884>

008078b4 <__umodsi3>:
  8078b4:	2005883a 	mov	r2,r4
  8078b8:	2900122e 	bgeu	r5,r4,807904 <__umodsi3+0x50>
  8078bc:	28001116 	blt	r5,zero,807904 <__umodsi3+0x50>
  8078c0:	01800804 	movi	r6,32
  8078c4:	00c00044 	movi	r3,1
  8078c8:	00000206 	br	8078d4 <__umodsi3+0x20>
  8078cc:	30000c26 	beq	r6,zero,807900 <__umodsi3+0x4c>
  8078d0:	28000516 	blt	r5,zero,8078e8 <__umodsi3+0x34>
  8078d4:	294b883a 	add	r5,r5,r5
  8078d8:	31bfffc4 	addi	r6,r6,-1
  8078dc:	18c7883a 	add	r3,r3,r3
  8078e0:	293ffa36 	bltu	r5,r4,8078cc <__alt_mem_onchip_memory2_0+0xff7878cc>
  8078e4:	18000626 	beq	r3,zero,807900 <__umodsi3+0x4c>
  8078e8:	1806d07a 	srli	r3,r3,1
  8078ec:	11400136 	bltu	r2,r5,8078f4 <__umodsi3+0x40>
  8078f0:	1145c83a 	sub	r2,r2,r5
  8078f4:	280ad07a 	srli	r5,r5,1
  8078f8:	183ffb1e 	bne	r3,zero,8078e8 <__alt_mem_onchip_memory2_0+0xff7878e8>
  8078fc:	f800283a 	ret
  807900:	f800283a 	ret
  807904:	00c00044 	movi	r3,1
  807908:	003ff706 	br	8078e8 <__alt_mem_onchip_memory2_0+0xff7878e8>

0080790c <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  80790c:	defffc04 	addi	sp,sp,-16
  807910:	df000315 	stw	fp,12(sp)
  807914:	df000304 	addi	fp,sp,12
  807918:	e13ffd15 	stw	r4,-12(fp)
  80791c:	e17ffe15 	stw	r5,-8(fp)
  807920:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
  807924:	e0fffe17 	ldw	r3,-8(fp)
  807928:	e0bffd17 	ldw	r2,-12(fp)
  80792c:	18800c26 	beq	r3,r2,807960 <alt_load_section+0x54>
  {
    while( to != end )
  807930:	00000806 	br	807954 <alt_load_section+0x48>
    {
      *to++ = *from++;
  807934:	e0bffe17 	ldw	r2,-8(fp)
  807938:	10c00104 	addi	r3,r2,4
  80793c:	e0fffe15 	stw	r3,-8(fp)
  807940:	e0fffd17 	ldw	r3,-12(fp)
  807944:	19000104 	addi	r4,r3,4
  807948:	e13ffd15 	stw	r4,-12(fp)
  80794c:	18c00017 	ldw	r3,0(r3)
  807950:	10c00015 	stw	r3,0(r2)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
  807954:	e0fffe17 	ldw	r3,-8(fp)
  807958:	e0bfff17 	ldw	r2,-4(fp)
  80795c:	18bff51e 	bne	r3,r2,807934 <__alt_mem_onchip_memory2_0+0xff787934>
    {
      *to++ = *from++;
    }
  }
}
  807960:	0001883a 	nop
  807964:	e037883a 	mov	sp,fp
  807968:	df000017 	ldw	fp,0(sp)
  80796c:	dec00104 	addi	sp,sp,4
  807970:	f800283a 	ret

00807974 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
  807974:	defffe04 	addi	sp,sp,-8
  807978:	dfc00115 	stw	ra,4(sp)
  80797c:	df000015 	stw	fp,0(sp)
  807980:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
  807984:	01802074 	movhi	r6,129
  807988:	31aae604 	addi	r6,r6,-21608
  80798c:	01402074 	movhi	r5,129
  807990:	2965ee04 	addi	r5,r5,-26696
  807994:	01002074 	movhi	r4,129
  807998:	212ae604 	addi	r4,r4,-21608
  80799c:	080790c0 	call	80790c <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
  8079a0:	01802034 	movhi	r6,128
  8079a4:	31809504 	addi	r6,r6,596
  8079a8:	01402034 	movhi	r5,128
  8079ac:	29400804 	addi	r5,r5,32
  8079b0:	01002034 	movhi	r4,128
  8079b4:	21000804 	addi	r4,r4,32
  8079b8:	080790c0 	call	80790c <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
  8079bc:	01802074 	movhi	r6,129
  8079c0:	31a5ee04 	addi	r6,r6,-26696
  8079c4:	01402074 	movhi	r5,129
  8079c8:	29659304 	addi	r5,r5,-27060
  8079cc:	01002074 	movhi	r4,129
  8079d0:	21259304 	addi	r4,r4,-27060
  8079d4:	080790c0 	call	80790c <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  8079d8:	080897c0 	call	80897c <alt_dcache_flush_all>
  alt_icache_flush_all();
  8079dc:	0808ae40 	call	808ae4 <alt_icache_flush_all>
}
  8079e0:	0001883a 	nop
  8079e4:	e037883a 	mov	sp,fp
  8079e8:	dfc00117 	ldw	ra,4(sp)
  8079ec:	df000017 	ldw	fp,0(sp)
  8079f0:	dec00204 	addi	sp,sp,8
  8079f4:	f800283a 	ret

008079f8 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
  8079f8:	defffd04 	addi	sp,sp,-12
  8079fc:	dfc00215 	stw	ra,8(sp)
  807a00:	df000115 	stw	fp,4(sp)
  807a04:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
  807a08:	0009883a 	mov	r4,zero
  807a0c:	0807c280 	call	807c28 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
  807a10:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
  807a14:	0807c600 	call	807c60 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
  807a18:	01802074 	movhi	r6,129
  807a1c:	31a5e104 	addi	r6,r6,-26748
  807a20:	01402074 	movhi	r5,129
  807a24:	2965e104 	addi	r5,r5,-26748
  807a28:	01002074 	movhi	r4,129
  807a2c:	2125e104 	addi	r4,r4,-26748
  807a30:	0808bdc0 	call	808bdc <alt_io_redirect>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
  807a34:	d0a51a17 	ldw	r2,-27544(gp)
  807a38:	d0e51b17 	ldw	r3,-27540(gp)
  807a3c:	d1251c17 	ldw	r4,-27536(gp)
  807a40:	200d883a 	mov	r6,r4
  807a44:	180b883a 	mov	r5,r3
  807a48:	1009883a 	mov	r4,r2
  807a4c:	08065540 	call	806554 <main>
  807a50:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
  807a54:	01000044 	movi	r4,1
  807a58:	08088ac0 	call	8088ac <close>
  exit (result);
  807a5c:	e13fff17 	ldw	r4,-4(fp)
  807a60:	08093e00 	call	8093e0 <exit>

00807a64 <alt_putstr>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided fputs() routine.
 */
int 
alt_putstr(const char* str)
{
  807a64:	defffd04 	addi	sp,sp,-12
  807a68:	dfc00215 	stw	ra,8(sp)
  807a6c:	df000115 	stw	fp,4(sp)
  807a70:	df000104 	addi	fp,sp,4
  807a74:	e13fff15 	stw	r4,-4(fp)
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, str, strlen(str), 0);
#else
    return fputs(str, stdout);
  807a78:	00802074 	movhi	r2,129
  807a7c:	10aadc04 	addi	r2,r2,-21648
  807a80:	10800017 	ldw	r2,0(r2)
  807a84:	10800217 	ldw	r2,8(r2)
  807a88:	100b883a 	mov	r5,r2
  807a8c:	e13fff17 	ldw	r4,-4(fp)
  807a90:	08094000 	call	809400 <fputs>
#endif
#endif
}
  807a94:	e037883a 	mov	sp,fp
  807a98:	dfc00117 	ldw	ra,4(sp)
  807a9c:	df000017 	ldw	fp,0(sp)
  807aa0:	dec00204 	addi	sp,sp,8
  807aa4:	f800283a 	ret

00807aa8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  807aa8:	defffe04 	addi	sp,sp,-8
  807aac:	dfc00115 	stw	ra,4(sp)
  807ab0:	df000015 	stw	fp,0(sp)
  807ab4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  807ab8:	00802074 	movhi	r2,129
  807abc:	10aae304 	addi	r2,r2,-21620
  807ac0:	10800017 	ldw	r2,0(r2)
  807ac4:	10000526 	beq	r2,zero,807adc <alt_get_errno+0x34>
  807ac8:	00802074 	movhi	r2,129
  807acc:	10aae304 	addi	r2,r2,-21620
  807ad0:	10800017 	ldw	r2,0(r2)
  807ad4:	103ee83a 	callr	r2
  807ad8:	00000206 	br	807ae4 <alt_get_errno+0x3c>
  807adc:	00802074 	movhi	r2,129
  807ae0:	10aff304 	addi	r2,r2,-16436
}
  807ae4:	e037883a 	mov	sp,fp
  807ae8:	dfc00117 	ldw	ra,4(sp)
  807aec:	df000017 	ldw	fp,0(sp)
  807af0:	dec00204 	addi	sp,sp,8
  807af4:	f800283a 	ret

00807af8 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
  807af8:	defff904 	addi	sp,sp,-28
  807afc:	dfc00615 	stw	ra,24(sp)
  807b00:	df000515 	stw	fp,20(sp)
  807b04:	df000504 	addi	fp,sp,20
  807b08:	e13ffd15 	stw	r4,-12(fp)
  807b0c:	e17ffe15 	stw	r5,-8(fp)
  807b10:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
  807b14:	e0bffd17 	ldw	r2,-12(fp)
  807b18:	10000616 	blt	r2,zero,807b34 <write+0x3c>
  807b1c:	e0bffd17 	ldw	r2,-12(fp)
  807b20:	10c00324 	muli	r3,r2,12
  807b24:	00802074 	movhi	r2,129
  807b28:	10aa7b04 	addi	r2,r2,-22036
  807b2c:	1885883a 	add	r2,r3,r2
  807b30:	00000106 	br	807b38 <write+0x40>
  807b34:	0005883a 	mov	r2,zero
  807b38:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
  807b3c:	e0bffb17 	ldw	r2,-20(fp)
  807b40:	10002126 	beq	r2,zero,807bc8 <write+0xd0>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
  807b44:	e0bffb17 	ldw	r2,-20(fp)
  807b48:	10800217 	ldw	r2,8(r2)
  807b4c:	108000cc 	andi	r2,r2,3
  807b50:	10001826 	beq	r2,zero,807bb4 <write+0xbc>
  807b54:	e0bffb17 	ldw	r2,-20(fp)
  807b58:	10800017 	ldw	r2,0(r2)
  807b5c:	10800617 	ldw	r2,24(r2)
  807b60:	10001426 	beq	r2,zero,807bb4 <write+0xbc>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
  807b64:	e0bffb17 	ldw	r2,-20(fp)
  807b68:	10800017 	ldw	r2,0(r2)
  807b6c:	10800617 	ldw	r2,24(r2)
  807b70:	e0ffff17 	ldw	r3,-4(fp)
  807b74:	180d883a 	mov	r6,r3
  807b78:	e17ffe17 	ldw	r5,-8(fp)
  807b7c:	e13ffb17 	ldw	r4,-20(fp)
  807b80:	103ee83a 	callr	r2
  807b84:	e0bffc15 	stw	r2,-16(fp)
  807b88:	e0bffc17 	ldw	r2,-16(fp)
  807b8c:	1000070e 	bge	r2,zero,807bac <write+0xb4>
      {
        ALT_ERRNO = -rval;
  807b90:	0807aa80 	call	807aa8 <alt_get_errno>
  807b94:	1007883a 	mov	r3,r2
  807b98:	e0bffc17 	ldw	r2,-16(fp)
  807b9c:	0085c83a 	sub	r2,zero,r2
  807ba0:	18800015 	stw	r2,0(r3)
        return -1;
  807ba4:	00bfffc4 	movi	r2,-1
  807ba8:	00000c06 	br	807bdc <write+0xe4>
      }
      return rval;
  807bac:	e0bffc17 	ldw	r2,-16(fp)
  807bb0:	00000a06 	br	807bdc <write+0xe4>
    }
    else
    {
      ALT_ERRNO = EACCES;
  807bb4:	0807aa80 	call	807aa8 <alt_get_errno>
  807bb8:	1007883a 	mov	r3,r2
  807bbc:	00800344 	movi	r2,13
  807bc0:	18800015 	stw	r2,0(r3)
  807bc4:	00000406 	br	807bd8 <write+0xe0>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
  807bc8:	0807aa80 	call	807aa8 <alt_get_errno>
  807bcc:	1007883a 	mov	r3,r2
  807bd0:	00801444 	movi	r2,81
  807bd4:	18800015 	stw	r2,0(r3)
  }
  return -1;
  807bd8:	00bfffc4 	movi	r2,-1
}
  807bdc:	e037883a 	mov	sp,fp
  807be0:	dfc00117 	ldw	ra,4(sp)
  807be4:	df000017 	ldw	fp,0(sp)
  807be8:	dec00204 	addi	sp,sp,8
  807bec:	f800283a 	ret

00807bf0 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
  807bf0:	defffd04 	addi	sp,sp,-12
  807bf4:	dfc00215 	stw	ra,8(sp)
  807bf8:	df000115 	stw	fp,4(sp)
  807bfc:	df000104 	addi	fp,sp,4
  807c00:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
  807c04:	01402074 	movhi	r5,129
  807c08:	296ae004 	addi	r5,r5,-21632
  807c0c:	e13fff17 	ldw	r4,-4(fp)
  807c10:	0808a400 	call	808a40 <alt_dev_llist_insert>
}
  807c14:	e037883a 	mov	sp,fp
  807c18:	dfc00117 	ldw	ra,4(sp)
  807c1c:	df000017 	ldw	fp,0(sp)
  807c20:	dec00204 	addi	sp,sp,8
  807c24:	f800283a 	ret

00807c28 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
  807c28:	defffd04 	addi	sp,sp,-12
  807c2c:	dfc00215 	stw	ra,8(sp)
  807c30:	df000115 	stw	fp,4(sp)
  807c34:	df000104 	addi	fp,sp,4
  807c38:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
  807c3c:	08090d40 	call	8090d4 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
  807c40:	00800044 	movi	r2,1
  807c44:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
  807c48:	0001883a 	nop
  807c4c:	e037883a 	mov	sp,fp
  807c50:	dfc00117 	ldw	ra,4(sp)
  807c54:	df000017 	ldw	fp,0(sp)
  807c58:	dec00204 	addi	sp,sp,8
  807c5c:	f800283a 	ret

00807c60 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
  807c60:	defffe04 	addi	sp,sp,-8
  807c64:	dfc00115 	stw	ra,4(sp)
  807c68:	df000015 	stw	fp,0(sp)
  807c6c:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
  807c70:	000d883a 	mov	r6,zero
  807c74:	000b883a 	mov	r5,zero
  807c78:	01002074 	movhi	r4,129
  807c7c:	21266304 	addi	r4,r4,-26228
  807c80:	0807e100 	call	807e10 <altera_avalon_jtag_uart_init>
  807c84:	01002074 	movhi	r4,129
  807c88:	21265904 	addi	r4,r4,-26268
  807c8c:	0807bf00 	call	807bf0 <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS_0, sysid_qsys_0);
  807c90:	0001883a 	nop
}
  807c94:	0001883a 	nop
  807c98:	e037883a 	mov	sp,fp
  807c9c:	dfc00117 	ldw	ra,4(sp)
  807ca0:	df000017 	ldw	fp,0(sp)
  807ca4:	dec00204 	addi	sp,sp,8
  807ca8:	f800283a 	ret

00807cac <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
  807cac:	defffa04 	addi	sp,sp,-24
  807cb0:	dfc00515 	stw	ra,20(sp)
  807cb4:	df000415 	stw	fp,16(sp)
  807cb8:	df000404 	addi	fp,sp,16
  807cbc:	e13ffd15 	stw	r4,-12(fp)
  807cc0:	e17ffe15 	stw	r5,-8(fp)
  807cc4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  807cc8:	e0bffd17 	ldw	r2,-12(fp)
  807ccc:	10800017 	ldw	r2,0(r2)
  807cd0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
  807cd4:	e0bffc17 	ldw	r2,-16(fp)
  807cd8:	10c00a04 	addi	r3,r2,40
  807cdc:	e0bffd17 	ldw	r2,-12(fp)
  807ce0:	10800217 	ldw	r2,8(r2)
  807ce4:	100f883a 	mov	r7,r2
  807ce8:	e1bfff17 	ldw	r6,-4(fp)
  807cec:	e17ffe17 	ldw	r5,-8(fp)
  807cf0:	1809883a 	mov	r4,r3
  807cf4:	08082dc0 	call	8082dc <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
  807cf8:	e037883a 	mov	sp,fp
  807cfc:	dfc00117 	ldw	ra,4(sp)
  807d00:	df000017 	ldw	fp,0(sp)
  807d04:	dec00204 	addi	sp,sp,8
  807d08:	f800283a 	ret

00807d0c <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
  807d0c:	defffa04 	addi	sp,sp,-24
  807d10:	dfc00515 	stw	ra,20(sp)
  807d14:	df000415 	stw	fp,16(sp)
  807d18:	df000404 	addi	fp,sp,16
  807d1c:	e13ffd15 	stw	r4,-12(fp)
  807d20:	e17ffe15 	stw	r5,-8(fp)
  807d24:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  807d28:	e0bffd17 	ldw	r2,-12(fp)
  807d2c:	10800017 	ldw	r2,0(r2)
  807d30:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
  807d34:	e0bffc17 	ldw	r2,-16(fp)
  807d38:	10c00a04 	addi	r3,r2,40
  807d3c:	e0bffd17 	ldw	r2,-12(fp)
  807d40:	10800217 	ldw	r2,8(r2)
  807d44:	100f883a 	mov	r7,r2
  807d48:	e1bfff17 	ldw	r6,-4(fp)
  807d4c:	e17ffe17 	ldw	r5,-8(fp)
  807d50:	1809883a 	mov	r4,r3
  807d54:	08084f80 	call	8084f8 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
  807d58:	e037883a 	mov	sp,fp
  807d5c:	dfc00117 	ldw	ra,4(sp)
  807d60:	df000017 	ldw	fp,0(sp)
  807d64:	dec00204 	addi	sp,sp,8
  807d68:	f800283a 	ret

00807d6c <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
  807d6c:	defffc04 	addi	sp,sp,-16
  807d70:	dfc00315 	stw	ra,12(sp)
  807d74:	df000215 	stw	fp,8(sp)
  807d78:	df000204 	addi	fp,sp,8
  807d7c:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  807d80:	e0bfff17 	ldw	r2,-4(fp)
  807d84:	10800017 	ldw	r2,0(r2)
  807d88:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
  807d8c:	e0bffe17 	ldw	r2,-8(fp)
  807d90:	10c00a04 	addi	r3,r2,40
  807d94:	e0bfff17 	ldw	r2,-4(fp)
  807d98:	10800217 	ldw	r2,8(r2)
  807d9c:	100b883a 	mov	r5,r2
  807da0:	1809883a 	mov	r4,r3
  807da4:	08081840 	call	808184 <altera_avalon_jtag_uart_close>
}
  807da8:	e037883a 	mov	sp,fp
  807dac:	dfc00117 	ldw	ra,4(sp)
  807db0:	df000017 	ldw	fp,0(sp)
  807db4:	dec00204 	addi	sp,sp,8
  807db8:	f800283a 	ret

00807dbc <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
  807dbc:	defffa04 	addi	sp,sp,-24
  807dc0:	dfc00515 	stw	ra,20(sp)
  807dc4:	df000415 	stw	fp,16(sp)
  807dc8:	df000404 	addi	fp,sp,16
  807dcc:	e13ffd15 	stw	r4,-12(fp)
  807dd0:	e17ffe15 	stw	r5,-8(fp)
  807dd4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
  807dd8:	e0bffd17 	ldw	r2,-12(fp)
  807ddc:	10800017 	ldw	r2,0(r2)
  807de0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
  807de4:	e0bffc17 	ldw	r2,-16(fp)
  807de8:	10800a04 	addi	r2,r2,40
  807dec:	e1bfff17 	ldw	r6,-4(fp)
  807df0:	e17ffe17 	ldw	r5,-8(fp)
  807df4:	1009883a 	mov	r4,r2
  807df8:	08081ec0 	call	8081ec <altera_avalon_jtag_uart_ioctl>
}
  807dfc:	e037883a 	mov	sp,fp
  807e00:	dfc00117 	ldw	ra,4(sp)
  807e04:	df000017 	ldw	fp,0(sp)
  807e08:	dec00204 	addi	sp,sp,8
  807e0c:	f800283a 	ret

00807e10 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
  807e10:	defffb04 	addi	sp,sp,-20
  807e14:	dfc00415 	stw	ra,16(sp)
  807e18:	df000315 	stw	fp,12(sp)
  807e1c:	df000304 	addi	fp,sp,12
  807e20:	e13ffd15 	stw	r4,-12(fp)
  807e24:	e17ffe15 	stw	r5,-8(fp)
  807e28:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  807e2c:	e0bffd17 	ldw	r2,-12(fp)
  807e30:	00c00044 	movi	r3,1
  807e34:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
  807e38:	e0bffd17 	ldw	r2,-12(fp)
  807e3c:	10800017 	ldw	r2,0(r2)
  807e40:	10800104 	addi	r2,r2,4
  807e44:	1007883a 	mov	r3,r2
  807e48:	e0bffd17 	ldw	r2,-12(fp)
  807e4c:	10800817 	ldw	r2,32(r2)
  807e50:	18800035 	stwio	r2,0(r3)
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
                      sp, NULL);
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
  807e54:	e0bfff17 	ldw	r2,-4(fp)
  807e58:	01802034 	movhi	r6,128
  807e5c:	319fb304 	addi	r6,r6,32460
  807e60:	e17ffd17 	ldw	r5,-12(fp)
  807e64:	1009883a 	mov	r4,r2
  807e68:	0800e7c0 	call	800e7c <alt_irq_register>
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
  807e6c:	e0bffd17 	ldw	r2,-12(fp)
  807e70:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
  807e74:	e0bffd17 	ldw	r2,-12(fp)
  807e78:	10c00204 	addi	r3,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
  807e7c:	00802074 	movhi	r2,129
  807e80:	10aff804 	addi	r2,r2,-16416
  807e84:	10800017 	ldw	r2,0(r2)
  807e88:	e1fffd17 	ldw	r7,-12(fp)
  807e8c:	01802074 	movhi	r6,129
  807e90:	31a03704 	addi	r6,r6,-32548
  807e94:	100b883a 	mov	r5,r2
  807e98:	1809883a 	mov	r4,r3
  807e9c:	080871c0 	call	80871c <alt_alarm_start>
  807ea0:	1000040e 	bge	r2,zero,807eb4 <altera_avalon_jtag_uart_init+0xa4>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
  807ea4:	e0fffd17 	ldw	r3,-12(fp)
  807ea8:	00a00034 	movhi	r2,32768
  807eac:	10bfffc4 	addi	r2,r2,-1
  807eb0:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
  807eb4:	0001883a 	nop
  807eb8:	e037883a 	mov	sp,fp
  807ebc:	dfc00117 	ldw	ra,4(sp)
  807ec0:	df000017 	ldw	fp,0(sp)
  807ec4:	dec00204 	addi	sp,sp,8
  807ec8:	f800283a 	ret

00807ecc <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
  807ecc:	defff704 	addi	sp,sp,-36
  807ed0:	df000815 	stw	fp,32(sp)
  807ed4:	df000804 	addi	fp,sp,32
  807ed8:	e13ffe15 	stw	r4,-8(fp)
  807edc:	e17fff15 	stw	r5,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
  807ee0:	e0bffe17 	ldw	r2,-8(fp)
  807ee4:	e0bffa15 	stw	r2,-24(fp)
  unsigned int base = sp->base;
  807ee8:	e0bffa17 	ldw	r2,-24(fp)
  807eec:	10800017 	ldw	r2,0(r2)
  807ef0:	e0bffb15 	stw	r2,-20(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  807ef4:	e0bffb17 	ldw	r2,-20(fp)
  807ef8:	10800104 	addi	r2,r2,4
  807efc:	10800037 	ldwio	r2,0(r2)
  807f00:	e0bffc15 	stw	r2,-16(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
  807f04:	e0bffc17 	ldw	r2,-16(fp)
  807f08:	1080c00c 	andi	r2,r2,768
  807f0c:	10006d26 	beq	r2,zero,8080c4 <altera_avalon_jtag_uart_irq+0x1f8>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
  807f10:	e0bffc17 	ldw	r2,-16(fp)
  807f14:	1080400c 	andi	r2,r2,256
  807f18:	10003526 	beq	r2,zero,807ff0 <altera_avalon_jtag_uart_irq+0x124>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
  807f1c:	00800074 	movhi	r2,1
  807f20:	e0bff815 	stw	r2,-32(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  807f24:	e0bffa17 	ldw	r2,-24(fp)
  807f28:	10800a17 	ldw	r2,40(r2)
  807f2c:	10800044 	addi	r2,r2,1
  807f30:	1081ffcc 	andi	r2,r2,2047
  807f34:	e0bffd15 	stw	r2,-12(fp)
        if (next == sp->rx_out)
  807f38:	e0bffa17 	ldw	r2,-24(fp)
  807f3c:	10c00b17 	ldw	r3,44(r2)
  807f40:	e0bffd17 	ldw	r2,-12(fp)
  807f44:	18801526 	beq	r3,r2,807f9c <altera_avalon_jtag_uart_irq+0xd0>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
  807f48:	e0bffb17 	ldw	r2,-20(fp)
  807f4c:	10800037 	ldwio	r2,0(r2)
  807f50:	e0bff815 	stw	r2,-32(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
  807f54:	e0bff817 	ldw	r2,-32(fp)
  807f58:	10a0000c 	andi	r2,r2,32768
  807f5c:	10001126 	beq	r2,zero,807fa4 <altera_avalon_jtag_uart_irq+0xd8>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
  807f60:	e0bffa17 	ldw	r2,-24(fp)
  807f64:	10800a17 	ldw	r2,40(r2)
  807f68:	e0fff817 	ldw	r3,-32(fp)
  807f6c:	1809883a 	mov	r4,r3
  807f70:	e0fffa17 	ldw	r3,-24(fp)
  807f74:	1885883a 	add	r2,r3,r2
  807f78:	10800e04 	addi	r2,r2,56
  807f7c:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  807f80:	e0bffa17 	ldw	r2,-24(fp)
  807f84:	10800a17 	ldw	r2,40(r2)
  807f88:	10800044 	addi	r2,r2,1
  807f8c:	10c1ffcc 	andi	r3,r2,2047
  807f90:	e0bffa17 	ldw	r2,-24(fp)
  807f94:	10c00a15 	stw	r3,40(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
  807f98:	003fe206 	br	807f24 <__alt_mem_onchip_memory2_0+0xff787f24>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
  807f9c:	0001883a 	nop
  807fa0:	00000106 	br	807fa8 <altera_avalon_jtag_uart_irq+0xdc>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
  807fa4:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
  807fa8:	e0bff817 	ldw	r2,-32(fp)
  807fac:	10bfffec 	andhi	r2,r2,65535
  807fb0:	10000f26 	beq	r2,zero,807ff0 <altera_avalon_jtag_uart_irq+0x124>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  807fb4:	e0bffa17 	ldw	r2,-24(fp)
  807fb8:	10c00817 	ldw	r3,32(r2)
  807fbc:	00bfff84 	movi	r2,-2
  807fc0:	1886703a 	and	r3,r3,r2
  807fc4:	e0bffa17 	ldw	r2,-24(fp)
  807fc8:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
  807fcc:	e0bffb17 	ldw	r2,-20(fp)
  807fd0:	10800104 	addi	r2,r2,4
  807fd4:	1007883a 	mov	r3,r2
  807fd8:	e0bffa17 	ldw	r2,-24(fp)
  807fdc:	10800817 	ldw	r2,32(r2)
  807fe0:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  807fe4:	e0bffb17 	ldw	r2,-20(fp)
  807fe8:	10800104 	addi	r2,r2,4
  807fec:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
  807ff0:	e0bffc17 	ldw	r2,-16(fp)
  807ff4:	1080800c 	andi	r2,r2,512
  807ff8:	103fbe26 	beq	r2,zero,807ef4 <__alt_mem_onchip_memory2_0+0xff787ef4>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
  807ffc:	e0bffc17 	ldw	r2,-16(fp)
  808000:	1004d43a 	srli	r2,r2,16
  808004:	e0bff915 	stw	r2,-28(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
  808008:	00001406 	br	80805c <altera_avalon_jtag_uart_irq+0x190>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
  80800c:	e0bffb17 	ldw	r2,-20(fp)
  808010:	e0fffa17 	ldw	r3,-24(fp)
  808014:	18c00d17 	ldw	r3,52(r3)
  808018:	e13ffa17 	ldw	r4,-24(fp)
  80801c:	20c7883a 	add	r3,r4,r3
  808020:	18c20e04 	addi	r3,r3,2104
  808024:	18c00003 	ldbu	r3,0(r3)
  808028:	18c03fcc 	andi	r3,r3,255
  80802c:	18c0201c 	xori	r3,r3,128
  808030:	18ffe004 	addi	r3,r3,-128
  808034:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  808038:	e0bffa17 	ldw	r2,-24(fp)
  80803c:	10800d17 	ldw	r2,52(r2)
  808040:	10800044 	addi	r2,r2,1
  808044:	10c1ffcc 	andi	r3,r2,2047
  808048:	e0bffa17 	ldw	r2,-24(fp)
  80804c:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
  808050:	e0bff917 	ldw	r2,-28(fp)
  808054:	10bfffc4 	addi	r2,r2,-1
  808058:	e0bff915 	stw	r2,-28(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
  80805c:	e0bff917 	ldw	r2,-28(fp)
  808060:	10000526 	beq	r2,zero,808078 <altera_avalon_jtag_uart_irq+0x1ac>
  808064:	e0bffa17 	ldw	r2,-24(fp)
  808068:	10c00d17 	ldw	r3,52(r2)
  80806c:	e0bffa17 	ldw	r2,-24(fp)
  808070:	10800c17 	ldw	r2,48(r2)
  808074:	18bfe51e 	bne	r3,r2,80800c <__alt_mem_onchip_memory2_0+0xff78800c>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
  808078:	e0bff917 	ldw	r2,-28(fp)
  80807c:	103f9d26 	beq	r2,zero,807ef4 <__alt_mem_onchip_memory2_0+0xff787ef4>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
  808080:	e0bffa17 	ldw	r2,-24(fp)
  808084:	10c00817 	ldw	r3,32(r2)
  808088:	00bfff44 	movi	r2,-3
  80808c:	1886703a 	and	r3,r3,r2
  808090:	e0bffa17 	ldw	r2,-24(fp)
  808094:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  808098:	e0bffa17 	ldw	r2,-24(fp)
  80809c:	10800017 	ldw	r2,0(r2)
  8080a0:	10800104 	addi	r2,r2,4
  8080a4:	1007883a 	mov	r3,r2
  8080a8:	e0bffa17 	ldw	r2,-24(fp)
  8080ac:	10800817 	ldw	r2,32(r2)
  8080b0:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  8080b4:	e0bffb17 	ldw	r2,-20(fp)
  8080b8:	10800104 	addi	r2,r2,4
  8080bc:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
  8080c0:	003f8c06 	br	807ef4 <__alt_mem_onchip_memory2_0+0xff787ef4>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
  8080c4:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
  8080c8:	0001883a 	nop
  8080cc:	e037883a 	mov	sp,fp
  8080d0:	df000017 	ldw	fp,0(sp)
  8080d4:	dec00104 	addi	sp,sp,4
  8080d8:	f800283a 	ret

008080dc <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
  8080dc:	defff804 	addi	sp,sp,-32
  8080e0:	df000715 	stw	fp,28(sp)
  8080e4:	df000704 	addi	fp,sp,28
  8080e8:	e13ffb15 	stw	r4,-20(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
  8080ec:	e0bffb17 	ldw	r2,-20(fp)
  8080f0:	e0bff915 	stw	r2,-28(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
  8080f4:	e0bff917 	ldw	r2,-28(fp)
  8080f8:	10800017 	ldw	r2,0(r2)
  8080fc:	10800104 	addi	r2,r2,4
  808100:	10800037 	ldwio	r2,0(r2)
  808104:	e0bffa15 	stw	r2,-24(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
  808108:	e0bffa17 	ldw	r2,-24(fp)
  80810c:	1081000c 	andi	r2,r2,1024
  808110:	10000b26 	beq	r2,zero,808140 <altera_avalon_jtag_uart_timeout+0x64>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
  808114:	e0bff917 	ldw	r2,-28(fp)
  808118:	10800017 	ldw	r2,0(r2)
  80811c:	10800104 	addi	r2,r2,4
  808120:	1007883a 	mov	r3,r2
  808124:	e0bff917 	ldw	r2,-28(fp)
  808128:	10800817 	ldw	r2,32(r2)
  80812c:	10810014 	ori	r2,r2,1024
  808130:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
  808134:	e0bff917 	ldw	r2,-28(fp)
  808138:	10000915 	stw	zero,36(r2)
  80813c:	00000a06 	br	808168 <altera_avalon_jtag_uart_timeout+0x8c>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
  808140:	e0bff917 	ldw	r2,-28(fp)
  808144:	10c00917 	ldw	r3,36(r2)
  808148:	00a00034 	movhi	r2,32768
  80814c:	10bfff04 	addi	r2,r2,-4
  808150:	10c00536 	bltu	r2,r3,808168 <altera_avalon_jtag_uart_timeout+0x8c>
    sp->host_inactive++;
  808154:	e0bff917 	ldw	r2,-28(fp)
  808158:	10800917 	ldw	r2,36(r2)
  80815c:	10c00044 	addi	r3,r2,1
  808160:	e0bff917 	ldw	r2,-28(fp)
  808164:	10c00915 	stw	r3,36(r2)
  808168:	00802074 	movhi	r2,129
  80816c:	10aff804 	addi	r2,r2,-16416
  808170:	10800017 	ldw	r2,0(r2)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
  808174:	e037883a 	mov	sp,fp
  808178:	df000017 	ldw	fp,0(sp)
  80817c:	dec00104 	addi	sp,sp,4
  808180:	f800283a 	ret

00808184 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
  808184:	defffd04 	addi	sp,sp,-12
  808188:	df000215 	stw	fp,8(sp)
  80818c:	df000204 	addi	fp,sp,8
  808190:	e13ffe15 	stw	r4,-8(fp)
  808194:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
  808198:	00000506 	br	8081b0 <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
  80819c:	e0bfff17 	ldw	r2,-4(fp)
  8081a0:	1090000c 	andi	r2,r2,16384
  8081a4:	10000226 	beq	r2,zero,8081b0 <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
  8081a8:	00bffd44 	movi	r2,-11
  8081ac:	00000b06 	br	8081dc <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
  8081b0:	e0bffe17 	ldw	r2,-8(fp)
  8081b4:	10c00d17 	ldw	r3,52(r2)
  8081b8:	e0bffe17 	ldw	r2,-8(fp)
  8081bc:	10800c17 	ldw	r2,48(r2)
  8081c0:	18800526 	beq	r3,r2,8081d8 <altera_avalon_jtag_uart_close+0x54>
  8081c4:	e0bffe17 	ldw	r2,-8(fp)
  8081c8:	10c00917 	ldw	r3,36(r2)
  8081cc:	e0bffe17 	ldw	r2,-8(fp)
  8081d0:	10800117 	ldw	r2,4(r2)
  8081d4:	18bff136 	bltu	r3,r2,80819c <__alt_mem_onchip_memory2_0+0xff78819c>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
  8081d8:	0005883a 	mov	r2,zero
}
  8081dc:	e037883a 	mov	sp,fp
  8081e0:	df000017 	ldw	fp,0(sp)
  8081e4:	dec00104 	addi	sp,sp,4
  8081e8:	f800283a 	ret

008081ec <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
  8081ec:	defffa04 	addi	sp,sp,-24
  8081f0:	df000515 	stw	fp,20(sp)
  8081f4:	df000504 	addi	fp,sp,20
  8081f8:	e13ffd15 	stw	r4,-12(fp)
  8081fc:	e17ffe15 	stw	r5,-8(fp)
  808200:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
  808204:	00bff9c4 	movi	r2,-25
  808208:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
  80820c:	e0bffe17 	ldw	r2,-8(fp)
  808210:	10da8060 	cmpeqi	r3,r2,27137
  808214:	1800031e 	bne	r3,zero,808224 <altera_avalon_jtag_uart_ioctl+0x38>
  808218:	109a80a0 	cmpeqi	r2,r2,27138
  80821c:	1000181e 	bne	r2,zero,808280 <altera_avalon_jtag_uart_ioctl+0x94>
      rc = 0;
    }
    break;

  default:
    break;
  808220:	00002906 	br	8082c8 <altera_avalon_jtag_uart_ioctl+0xdc>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
  808224:	e0bffd17 	ldw	r2,-12(fp)
  808228:	10c00117 	ldw	r3,4(r2)
  80822c:	00a00034 	movhi	r2,32768
  808230:	10bfffc4 	addi	r2,r2,-1
  808234:	18802126 	beq	r3,r2,8082bc <altera_avalon_jtag_uart_ioctl+0xd0>
    {
      int timeout = *((int *)arg);
  808238:	e0bfff17 	ldw	r2,-4(fp)
  80823c:	10800017 	ldw	r2,0(r2)
  808240:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
  808244:	e0bffc17 	ldw	r2,-16(fp)
  808248:	10800090 	cmplti	r2,r2,2
  80824c:	1000061e 	bne	r2,zero,808268 <altera_avalon_jtag_uart_ioctl+0x7c>
  808250:	e0fffc17 	ldw	r3,-16(fp)
  808254:	00a00034 	movhi	r2,32768
  808258:	10bfffc4 	addi	r2,r2,-1
  80825c:	18800226 	beq	r3,r2,808268 <altera_avalon_jtag_uart_ioctl+0x7c>
  808260:	e0bffc17 	ldw	r2,-16(fp)
  808264:	00000206 	br	808270 <altera_avalon_jtag_uart_ioctl+0x84>
  808268:	00a00034 	movhi	r2,32768
  80826c:	10bfff84 	addi	r2,r2,-2
  808270:	e0fffd17 	ldw	r3,-12(fp)
  808274:	18800115 	stw	r2,4(r3)
      rc = 0;
  808278:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
  80827c:	00000f06 	br	8082bc <altera_avalon_jtag_uart_ioctl+0xd0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
  808280:	e0bffd17 	ldw	r2,-12(fp)
  808284:	10c00117 	ldw	r3,4(r2)
  808288:	00a00034 	movhi	r2,32768
  80828c:	10bfffc4 	addi	r2,r2,-1
  808290:	18800c26 	beq	r3,r2,8082c4 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
  808294:	e0bffd17 	ldw	r2,-12(fp)
  808298:	10c00917 	ldw	r3,36(r2)
  80829c:	e0bffd17 	ldw	r2,-12(fp)
  8082a0:	10800117 	ldw	r2,4(r2)
  8082a4:	1885803a 	cmpltu	r2,r3,r2
  8082a8:	10c03fcc 	andi	r3,r2,255
  8082ac:	e0bfff17 	ldw	r2,-4(fp)
  8082b0:	10c00015 	stw	r3,0(r2)
      rc = 0;
  8082b4:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
  8082b8:	00000206 	br	8082c4 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
  8082bc:	0001883a 	nop
  8082c0:	00000106 	br	8082c8 <altera_avalon_jtag_uart_ioctl+0xdc>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
  8082c4:	0001883a 	nop

  default:
    break;
  }

  return rc;
  8082c8:	e0bffb17 	ldw	r2,-20(fp)
}
  8082cc:	e037883a 	mov	sp,fp
  8082d0:	df000017 	ldw	fp,0(sp)
  8082d4:	dec00104 	addi	sp,sp,4
  8082d8:	f800283a 	ret

008082dc <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
  8082dc:	defff304 	addi	sp,sp,-52
  8082e0:	dfc00c15 	stw	ra,48(sp)
  8082e4:	df000b15 	stw	fp,44(sp)
  8082e8:	df000b04 	addi	fp,sp,44
  8082ec:	e13ffc15 	stw	r4,-16(fp)
  8082f0:	e17ffd15 	stw	r5,-12(fp)
  8082f4:	e1bffe15 	stw	r6,-8(fp)
  8082f8:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
  8082fc:	e0bffd17 	ldw	r2,-12(fp)
  808300:	e0bff515 	stw	r2,-44(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
  808304:	00004706 	br	808424 <altera_avalon_jtag_uart_read+0x148>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
  808308:	e0bffc17 	ldw	r2,-16(fp)
  80830c:	10800a17 	ldw	r2,40(r2)
  808310:	e0bff715 	stw	r2,-36(fp)
      out = sp->rx_out;
  808314:	e0bffc17 	ldw	r2,-16(fp)
  808318:	10800b17 	ldw	r2,44(r2)
  80831c:	e0bff815 	stw	r2,-32(fp)

      if (in >= out)
  808320:	e0fff717 	ldw	r3,-36(fp)
  808324:	e0bff817 	ldw	r2,-32(fp)
  808328:	18800536 	bltu	r3,r2,808340 <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
  80832c:	e0fff717 	ldw	r3,-36(fp)
  808330:	e0bff817 	ldw	r2,-32(fp)
  808334:	1885c83a 	sub	r2,r3,r2
  808338:	e0bff615 	stw	r2,-40(fp)
  80833c:	00000406 	br	808350 <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
  808340:	00c20004 	movi	r3,2048
  808344:	e0bff817 	ldw	r2,-32(fp)
  808348:	1885c83a 	sub	r2,r3,r2
  80834c:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
  808350:	e0bff617 	ldw	r2,-40(fp)
  808354:	10001e26 	beq	r2,zero,8083d0 <altera_avalon_jtag_uart_read+0xf4>
        break; /* No more data available */

      if (n > space)
  808358:	e0fffe17 	ldw	r3,-8(fp)
  80835c:	e0bff617 	ldw	r2,-40(fp)
  808360:	1880022e 	bgeu	r3,r2,80836c <altera_avalon_jtag_uart_read+0x90>
        n = space;
  808364:	e0bffe17 	ldw	r2,-8(fp)
  808368:	e0bff615 	stw	r2,-40(fp)

      memcpy(ptr, sp->rx_buf + out, n);
  80836c:	e0bffc17 	ldw	r2,-16(fp)
  808370:	10c00e04 	addi	r3,r2,56
  808374:	e0bff817 	ldw	r2,-32(fp)
  808378:	1885883a 	add	r2,r3,r2
  80837c:	e1bff617 	ldw	r6,-40(fp)
  808380:	100b883a 	mov	r5,r2
  808384:	e13ff517 	ldw	r4,-44(fp)
  808388:	08066f00 	call	8066f0 <memcpy>
      ptr   += n;
  80838c:	e0fff517 	ldw	r3,-44(fp)
  808390:	e0bff617 	ldw	r2,-40(fp)
  808394:	1885883a 	add	r2,r3,r2
  808398:	e0bff515 	stw	r2,-44(fp)
      space -= n;
  80839c:	e0fffe17 	ldw	r3,-8(fp)
  8083a0:	e0bff617 	ldw	r2,-40(fp)
  8083a4:	1885c83a 	sub	r2,r3,r2
  8083a8:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  8083ac:	e0fff817 	ldw	r3,-32(fp)
  8083b0:	e0bff617 	ldw	r2,-40(fp)
  8083b4:	1885883a 	add	r2,r3,r2
  8083b8:	10c1ffcc 	andi	r3,r2,2047
  8083bc:	e0bffc17 	ldw	r2,-16(fp)
  8083c0:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
  8083c4:	e0bffe17 	ldw	r2,-8(fp)
  8083c8:	00bfcf16 	blt	zero,r2,808308 <__alt_mem_onchip_memory2_0+0xff788308>
  8083cc:	00000106 	br	8083d4 <altera_avalon_jtag_uart_read+0xf8>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
  8083d0:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
  8083d4:	e0fff517 	ldw	r3,-44(fp)
  8083d8:	e0bffd17 	ldw	r2,-12(fp)
  8083dc:	1880141e 	bne	r3,r2,808430 <altera_avalon_jtag_uart_read+0x154>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
  8083e0:	e0bfff17 	ldw	r2,-4(fp)
  8083e4:	1090000c 	andi	r2,r2,16384
  8083e8:	1000131e 	bne	r2,zero,808438 <altera_avalon_jtag_uart_read+0x15c>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
  8083ec:	0001883a 	nop
  8083f0:	e0bffc17 	ldw	r2,-16(fp)
  8083f4:	10c00a17 	ldw	r3,40(r2)
  8083f8:	e0bff717 	ldw	r2,-36(fp)
  8083fc:	1880051e 	bne	r3,r2,808414 <altera_avalon_jtag_uart_read+0x138>
  808400:	e0bffc17 	ldw	r2,-16(fp)
  808404:	10c00917 	ldw	r3,36(r2)
  808408:	e0bffc17 	ldw	r2,-16(fp)
  80840c:	10800117 	ldw	r2,4(r2)
  808410:	18bff736 	bltu	r3,r2,8083f0 <__alt_mem_onchip_memory2_0+0xff7883f0>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
  808414:	e0bffc17 	ldw	r2,-16(fp)
  808418:	10c00a17 	ldw	r3,40(r2)
  80841c:	e0bff717 	ldw	r2,-36(fp)
  808420:	18800726 	beq	r3,r2,808440 <altera_avalon_jtag_uart_read+0x164>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
  808424:	e0bffe17 	ldw	r2,-8(fp)
  808428:	00bfb716 	blt	zero,r2,808308 <__alt_mem_onchip_memory2_0+0xff788308>
  80842c:	00000506 	br	808444 <altera_avalon_jtag_uart_read+0x168>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
  808430:	0001883a 	nop
  808434:	00000306 	br	808444 <altera_avalon_jtag_uart_read+0x168>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
  808438:	0001883a 	nop
  80843c:	00000106 	br	808444 <altera_avalon_jtag_uart_read+0x168>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
  808440:	0001883a 	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
  808444:	e0fff517 	ldw	r3,-44(fp)
  808448:	e0bffd17 	ldw	r2,-12(fp)
  80844c:	18801826 	beq	r3,r2,8084b0 <altera_avalon_jtag_uart_read+0x1d4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  808450:	0005303a 	rdctl	r2,status
  808454:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  808458:	e0fffb17 	ldw	r3,-20(fp)
  80845c:	00bfff84 	movi	r2,-2
  808460:	1884703a 	and	r2,r3,r2
  808464:	1001703a 	wrctl	status,r2
  
  return context;
  808468:	e0bffb17 	ldw	r2,-20(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
  80846c:	e0bffa15 	stw	r2,-24(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  808470:	e0bffc17 	ldw	r2,-16(fp)
  808474:	10800817 	ldw	r2,32(r2)
  808478:	10c00054 	ori	r3,r2,1
  80847c:	e0bffc17 	ldw	r2,-16(fp)
  808480:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  808484:	e0bffc17 	ldw	r2,-16(fp)
  808488:	10800017 	ldw	r2,0(r2)
  80848c:	10800104 	addi	r2,r2,4
  808490:	1007883a 	mov	r3,r2
  808494:	e0bffc17 	ldw	r2,-16(fp)
  808498:	10800817 	ldw	r2,32(r2)
  80849c:	18800035 	stwio	r2,0(r3)
  8084a0:	e0bffa17 	ldw	r2,-24(fp)
  8084a4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  8084a8:	e0bff917 	ldw	r2,-28(fp)
  8084ac:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
  8084b0:	e0fff517 	ldw	r3,-44(fp)
  8084b4:	e0bffd17 	ldw	r2,-12(fp)
  8084b8:	18800426 	beq	r3,r2,8084cc <altera_avalon_jtag_uart_read+0x1f0>
    return ptr - buffer;
  8084bc:	e0fff517 	ldw	r3,-44(fp)
  8084c0:	e0bffd17 	ldw	r2,-12(fp)
  8084c4:	1885c83a 	sub	r2,r3,r2
  8084c8:	00000606 	br	8084e4 <altera_avalon_jtag_uart_read+0x208>
  else if (flags & O_NONBLOCK)
  8084cc:	e0bfff17 	ldw	r2,-4(fp)
  8084d0:	1090000c 	andi	r2,r2,16384
  8084d4:	10000226 	beq	r2,zero,8084e0 <altera_avalon_jtag_uart_read+0x204>
    return -EWOULDBLOCK;
  8084d8:	00bffd44 	movi	r2,-11
  8084dc:	00000106 	br	8084e4 <altera_avalon_jtag_uart_read+0x208>
  else
    return -EIO;
  8084e0:	00bffec4 	movi	r2,-5
}
  8084e4:	e037883a 	mov	sp,fp
  8084e8:	dfc00117 	ldw	ra,4(sp)
  8084ec:	df000017 	ldw	fp,0(sp)
  8084f0:	dec00204 	addi	sp,sp,8
  8084f4:	f800283a 	ret

008084f8 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  8084f8:	defff304 	addi	sp,sp,-52
  8084fc:	dfc00c15 	stw	ra,48(sp)
  808500:	df000b15 	stw	fp,44(sp)
  808504:	df000b04 	addi	fp,sp,44
  808508:	e13ffc15 	stw	r4,-16(fp)
  80850c:	e17ffd15 	stw	r5,-12(fp)
  808510:	e1bffe15 	stw	r6,-8(fp)
  808514:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
  808518:	e03ff515 	stw	zero,-44(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
  80851c:	e0bffd17 	ldw	r2,-12(fp)
  808520:	e0bff715 	stw	r2,-36(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
  808524:	00003706 	br	808604 <altera_avalon_jtag_uart_write+0x10c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
  808528:	e0bffc17 	ldw	r2,-16(fp)
  80852c:	10800c17 	ldw	r2,48(r2)
  808530:	e0bff915 	stw	r2,-28(fp)
      out = sp->tx_out;
  808534:	e0bffc17 	ldw	r2,-16(fp)
  808538:	10800d17 	ldw	r2,52(r2)
  80853c:	e0bff515 	stw	r2,-44(fp)

      if (in < out)
  808540:	e0fff917 	ldw	r3,-28(fp)
  808544:	e0bff517 	ldw	r2,-44(fp)
  808548:	1880062e 	bgeu	r3,r2,808564 <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
  80854c:	e0fff517 	ldw	r3,-44(fp)
  808550:	e0bff917 	ldw	r2,-28(fp)
  808554:	1885c83a 	sub	r2,r3,r2
  808558:	10bfffc4 	addi	r2,r2,-1
  80855c:	e0bff615 	stw	r2,-40(fp)
  808560:	00000b06 	br	808590 <altera_avalon_jtag_uart_write+0x98>
      else if (out > 0)
  808564:	e0bff517 	ldw	r2,-44(fp)
  808568:	10000526 	beq	r2,zero,808580 <altera_avalon_jtag_uart_write+0x88>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
  80856c:	00c20004 	movi	r3,2048
  808570:	e0bff917 	ldw	r2,-28(fp)
  808574:	1885c83a 	sub	r2,r3,r2
  808578:	e0bff615 	stw	r2,-40(fp)
  80857c:	00000406 	br	808590 <altera_avalon_jtag_uart_write+0x98>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
  808580:	00c1ffc4 	movi	r3,2047
  808584:	e0bff917 	ldw	r2,-28(fp)
  808588:	1885c83a 	sub	r2,r3,r2
  80858c:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
  808590:	e0bff617 	ldw	r2,-40(fp)
  808594:	10001e26 	beq	r2,zero,808610 <altera_avalon_jtag_uart_write+0x118>
        break;

      if (n > count)
  808598:	e0fffe17 	ldw	r3,-8(fp)
  80859c:	e0bff617 	ldw	r2,-40(fp)
  8085a0:	1880022e 	bgeu	r3,r2,8085ac <altera_avalon_jtag_uart_write+0xb4>
        n = count;
  8085a4:	e0bffe17 	ldw	r2,-8(fp)
  8085a8:	e0bff615 	stw	r2,-40(fp)

      memcpy(sp->tx_buf + in, ptr, n);
  8085ac:	e0bffc17 	ldw	r2,-16(fp)
  8085b0:	10c20e04 	addi	r3,r2,2104
  8085b4:	e0bff917 	ldw	r2,-28(fp)
  8085b8:	1885883a 	add	r2,r3,r2
  8085bc:	e1bff617 	ldw	r6,-40(fp)
  8085c0:	e17ffd17 	ldw	r5,-12(fp)
  8085c4:	1009883a 	mov	r4,r2
  8085c8:	08066f00 	call	8066f0 <memcpy>
      ptr   += n;
  8085cc:	e0fffd17 	ldw	r3,-12(fp)
  8085d0:	e0bff617 	ldw	r2,-40(fp)
  8085d4:	1885883a 	add	r2,r3,r2
  8085d8:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
  8085dc:	e0fffe17 	ldw	r3,-8(fp)
  8085e0:	e0bff617 	ldw	r2,-40(fp)
  8085e4:	1885c83a 	sub	r2,r3,r2
  8085e8:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  8085ec:	e0fff917 	ldw	r3,-28(fp)
  8085f0:	e0bff617 	ldw	r2,-40(fp)
  8085f4:	1885883a 	add	r2,r3,r2
  8085f8:	10c1ffcc 	andi	r3,r2,2047
  8085fc:	e0bffc17 	ldw	r2,-16(fp)
  808600:	10c00c15 	stw	r3,48(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
  808604:	e0bffe17 	ldw	r2,-8(fp)
  808608:	00bfc716 	blt	zero,r2,808528 <__alt_mem_onchip_memory2_0+0xff788528>
  80860c:	00000106 	br	808614 <altera_avalon_jtag_uart_write+0x11c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
  808610:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  808614:	0005303a 	rdctl	r2,status
  808618:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  80861c:	e0fffb17 	ldw	r3,-20(fp)
  808620:	00bfff84 	movi	r2,-2
  808624:	1884703a 	and	r2,r3,r2
  808628:	1001703a 	wrctl	status,r2
  
  return context;
  80862c:	e0bffb17 	ldw	r2,-20(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
  808630:	e0bffa15 	stw	r2,-24(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
  808634:	e0bffc17 	ldw	r2,-16(fp)
  808638:	10800817 	ldw	r2,32(r2)
  80863c:	10c00094 	ori	r3,r2,2
  808640:	e0bffc17 	ldw	r2,-16(fp)
  808644:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  808648:	e0bffc17 	ldw	r2,-16(fp)
  80864c:	10800017 	ldw	r2,0(r2)
  808650:	10800104 	addi	r2,r2,4
  808654:	1007883a 	mov	r3,r2
  808658:	e0bffc17 	ldw	r2,-16(fp)
  80865c:	10800817 	ldw	r2,32(r2)
  808660:	18800035 	stwio	r2,0(r3)
  808664:	e0bffa17 	ldw	r2,-24(fp)
  808668:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  80866c:	e0bff817 	ldw	r2,-32(fp)
  808670:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
  808674:	e0bffe17 	ldw	r2,-8(fp)
  808678:	0080100e 	bge	zero,r2,8086bc <altera_avalon_jtag_uart_write+0x1c4>
    {
      if (flags & O_NONBLOCK)
  80867c:	e0bfff17 	ldw	r2,-4(fp)
  808680:	1090000c 	andi	r2,r2,16384
  808684:	1000101e 	bne	r2,zero,8086c8 <altera_avalon_jtag_uart_write+0x1d0>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
  808688:	0001883a 	nop
  80868c:	e0bffc17 	ldw	r2,-16(fp)
  808690:	10c00d17 	ldw	r3,52(r2)
  808694:	e0bff517 	ldw	r2,-44(fp)
  808698:	1880051e 	bne	r3,r2,8086b0 <altera_avalon_jtag_uart_write+0x1b8>
  80869c:	e0bffc17 	ldw	r2,-16(fp)
  8086a0:	10c00917 	ldw	r3,36(r2)
  8086a4:	e0bffc17 	ldw	r2,-16(fp)
  8086a8:	10800117 	ldw	r2,4(r2)
  8086ac:	18bff736 	bltu	r3,r2,80868c <__alt_mem_onchip_memory2_0+0xff78868c>
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
  8086b0:	e0bffc17 	ldw	r2,-16(fp)
  8086b4:	10800917 	ldw	r2,36(r2)
  8086b8:	1000051e 	bne	r2,zero,8086d0 <altera_avalon_jtag_uart_write+0x1d8>
         break;
    }
  }
  while (count > 0);
  8086bc:	e0bffe17 	ldw	r2,-8(fp)
  8086c0:	00bfd016 	blt	zero,r2,808604 <__alt_mem_onchip_memory2_0+0xff788604>
  8086c4:	00000306 	br	8086d4 <altera_avalon_jtag_uart_write+0x1dc>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
  8086c8:	0001883a 	nop
  8086cc:	00000106 	br	8086d4 <altera_avalon_jtag_uart_write+0x1dc>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
  8086d0:	0001883a 	nop
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
  8086d4:	e0fffd17 	ldw	r3,-12(fp)
  8086d8:	e0bff717 	ldw	r2,-36(fp)
  8086dc:	18800426 	beq	r3,r2,8086f0 <altera_avalon_jtag_uart_write+0x1f8>
    return ptr - start;
  8086e0:	e0fffd17 	ldw	r3,-12(fp)
  8086e4:	e0bff717 	ldw	r2,-36(fp)
  8086e8:	1885c83a 	sub	r2,r3,r2
  8086ec:	00000606 	br	808708 <altera_avalon_jtag_uart_write+0x210>
  else if (flags & O_NONBLOCK)
  8086f0:	e0bfff17 	ldw	r2,-4(fp)
  8086f4:	1090000c 	andi	r2,r2,16384
  8086f8:	10000226 	beq	r2,zero,808704 <altera_avalon_jtag_uart_write+0x20c>
    return -EWOULDBLOCK;
  8086fc:	00bffd44 	movi	r2,-11
  808700:	00000106 	br	808708 <altera_avalon_jtag_uart_write+0x210>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
  808704:	00bffec4 	movi	r2,-5
}
  808708:	e037883a 	mov	sp,fp
  80870c:	dfc00117 	ldw	ra,4(sp)
  808710:	df000017 	ldw	fp,0(sp)
  808714:	dec00204 	addi	sp,sp,8
  808718:	f800283a 	ret

0080871c <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
  80871c:	defff504 	addi	sp,sp,-44
  808720:	df000a15 	stw	fp,40(sp)
  808724:	df000a04 	addi	fp,sp,40
  808728:	e13ffc15 	stw	r4,-16(fp)
  80872c:	e17ffd15 	stw	r5,-12(fp)
  808730:	e1bffe15 	stw	r6,-8(fp)
  808734:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
  808738:	e03ff615 	stw	zero,-40(fp)
  80873c:	00802074 	movhi	r2,129
  808740:	10aff804 	addi	r2,r2,-16416
  808744:	10800017 	ldw	r2,0(r2)
  
  if (alt_ticks_per_second ())
  808748:	10003f26 	beq	r2,zero,808848 <alt_alarm_start+0x12c>
  {
    if (alarm)
  80874c:	e0bffc17 	ldw	r2,-16(fp)
  808750:	10003b26 	beq	r2,zero,808840 <alt_alarm_start+0x124>
    {
      alarm->callback = callback;
  808754:	e0bffc17 	ldw	r2,-16(fp)
  808758:	e0fffe17 	ldw	r3,-8(fp)
  80875c:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
  808760:	e0bffc17 	ldw	r2,-16(fp)
  808764:	e0ffff17 	ldw	r3,-4(fp)
  808768:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  80876c:	0005303a 	rdctl	r2,status
  808770:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  808774:	e0fff917 	ldw	r3,-28(fp)
  808778:	00bfff84 	movi	r2,-2
  80877c:	1884703a 	and	r2,r3,r2
  808780:	1001703a 	wrctl	status,r2
  
  return context;
  808784:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
  808788:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
  80878c:	00802074 	movhi	r2,129
  808790:	10aff904 	addi	r2,r2,-16412
  808794:	10800017 	ldw	r2,0(r2)
      
      current_nticks = alt_nticks();
  808798:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
  80879c:	e0fffd17 	ldw	r3,-12(fp)
  8087a0:	e0bff617 	ldw	r2,-40(fp)
  8087a4:	1885883a 	add	r2,r3,r2
  8087a8:	10c00044 	addi	r3,r2,1
  8087ac:	e0bffc17 	ldw	r2,-16(fp)
  8087b0:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
  8087b4:	e0bffc17 	ldw	r2,-16(fp)
  8087b8:	10c00217 	ldw	r3,8(r2)
  8087bc:	e0bff617 	ldw	r2,-40(fp)
  8087c0:	1880042e 	bgeu	r3,r2,8087d4 <alt_alarm_start+0xb8>
      {
        alarm->rollover = 1;
  8087c4:	e0bffc17 	ldw	r2,-16(fp)
  8087c8:	00c00044 	movi	r3,1
  8087cc:	10c00405 	stb	r3,16(r2)
  8087d0:	00000206 	br	8087dc <alt_alarm_start+0xc0>
      }
      else
      {
        alarm->rollover = 0;
  8087d4:	e0bffc17 	ldw	r2,-16(fp)
  8087d8:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
  8087dc:	e0fffc17 	ldw	r3,-16(fp)
  8087e0:	00802074 	movhi	r2,129
  8087e4:	10aae404 	addi	r2,r2,-21616
  8087e8:	e0bffa15 	stw	r2,-24(fp)
  8087ec:	e0fffb15 	stw	r3,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  8087f0:	e0bffb17 	ldw	r2,-20(fp)
  8087f4:	e0fffa17 	ldw	r3,-24(fp)
  8087f8:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
  8087fc:	e0bffa17 	ldw	r2,-24(fp)
  808800:	10c00017 	ldw	r3,0(r2)
  808804:	e0bffb17 	ldw	r2,-20(fp)
  808808:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
  80880c:	e0bffa17 	ldw	r2,-24(fp)
  808810:	10800017 	ldw	r2,0(r2)
  808814:	e0fffb17 	ldw	r3,-20(fp)
  808818:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
  80881c:	e0bffa17 	ldw	r2,-24(fp)
  808820:	e0fffb17 	ldw	r3,-20(fp)
  808824:	10c00015 	stw	r3,0(r2)
  808828:	e0bff817 	ldw	r2,-32(fp)
  80882c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  808830:	e0bff717 	ldw	r2,-36(fp)
  808834:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
  808838:	0005883a 	mov	r2,zero
  80883c:	00000306 	br	80884c <alt_alarm_start+0x130>
    }
    else
    {
      return -EINVAL;
  808840:	00bffa84 	movi	r2,-22
  808844:	00000106 	br	80884c <alt_alarm_start+0x130>
    }
  }
  else
  {
    return -ENOTSUP;
  808848:	00bfde84 	movi	r2,-134
  }
}
  80884c:	e037883a 	mov	sp,fp
  808850:	df000017 	ldw	fp,0(sp)
  808854:	dec00104 	addi	sp,sp,4
  808858:	f800283a 	ret

0080885c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  80885c:	defffe04 	addi	sp,sp,-8
  808860:	dfc00115 	stw	ra,4(sp)
  808864:	df000015 	stw	fp,0(sp)
  808868:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  80886c:	00802074 	movhi	r2,129
  808870:	10aae304 	addi	r2,r2,-21620
  808874:	10800017 	ldw	r2,0(r2)
  808878:	10000526 	beq	r2,zero,808890 <alt_get_errno+0x34>
  80887c:	00802074 	movhi	r2,129
  808880:	10aae304 	addi	r2,r2,-21620
  808884:	10800017 	ldw	r2,0(r2)
  808888:	103ee83a 	callr	r2
  80888c:	00000206 	br	808898 <alt_get_errno+0x3c>
  808890:	00802074 	movhi	r2,129
  808894:	10aff304 	addi	r2,r2,-16436
}
  808898:	e037883a 	mov	sp,fp
  80889c:	dfc00117 	ldw	ra,4(sp)
  8088a0:	df000017 	ldw	fp,0(sp)
  8088a4:	dec00204 	addi	sp,sp,8
  8088a8:	f800283a 	ret

008088ac <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
  8088ac:	defffb04 	addi	sp,sp,-20
  8088b0:	dfc00415 	stw	ra,16(sp)
  8088b4:	df000315 	stw	fp,12(sp)
  8088b8:	df000304 	addi	fp,sp,12
  8088bc:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
  8088c0:	e0bfff17 	ldw	r2,-4(fp)
  8088c4:	10000616 	blt	r2,zero,8088e0 <close+0x34>
  8088c8:	e0bfff17 	ldw	r2,-4(fp)
  8088cc:	10c00324 	muli	r3,r2,12
  8088d0:	00802074 	movhi	r2,129
  8088d4:	10aa7b04 	addi	r2,r2,-22036
  8088d8:	1885883a 	add	r2,r3,r2
  8088dc:	00000106 	br	8088e4 <close+0x38>
  8088e0:	0005883a 	mov	r2,zero
  8088e4:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
  8088e8:	e0bffd17 	ldw	r2,-12(fp)
  8088ec:	10001926 	beq	r2,zero,808954 <close+0xa8>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
  8088f0:	e0bffd17 	ldw	r2,-12(fp)
  8088f4:	10800017 	ldw	r2,0(r2)
  8088f8:	10800417 	ldw	r2,16(r2)
  8088fc:	10000626 	beq	r2,zero,808918 <close+0x6c>
  808900:	e0bffd17 	ldw	r2,-12(fp)
  808904:	10800017 	ldw	r2,0(r2)
  808908:	10800417 	ldw	r2,16(r2)
  80890c:	e13ffd17 	ldw	r4,-12(fp)
  808910:	103ee83a 	callr	r2
  808914:	00000106 	br	80891c <close+0x70>
  808918:	0005883a 	mov	r2,zero
  80891c:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
  808920:	e13fff17 	ldw	r4,-4(fp)
  808924:	0808ecc0 	call	808ecc <alt_release_fd>
    if (rval < 0)
  808928:	e0bffe17 	ldw	r2,-8(fp)
  80892c:	1000070e 	bge	r2,zero,80894c <close+0xa0>
    {
      ALT_ERRNO = -rval;
  808930:	080885c0 	call	80885c <alt_get_errno>
  808934:	1007883a 	mov	r3,r2
  808938:	e0bffe17 	ldw	r2,-8(fp)
  80893c:	0085c83a 	sub	r2,zero,r2
  808940:	18800015 	stw	r2,0(r3)
      return -1;
  808944:	00bfffc4 	movi	r2,-1
  808948:	00000706 	br	808968 <close+0xbc>
    }
    return 0;
  80894c:	0005883a 	mov	r2,zero
  808950:	00000506 	br	808968 <close+0xbc>
  }
  else
  {
    ALT_ERRNO = EBADFD;
  808954:	080885c0 	call	80885c <alt_get_errno>
  808958:	1007883a 	mov	r3,r2
  80895c:	00801444 	movi	r2,81
  808960:	18800015 	stw	r2,0(r3)
    return -1;
  808964:	00bfffc4 	movi	r2,-1
  }
}
  808968:	e037883a 	mov	sp,fp
  80896c:	dfc00117 	ldw	ra,4(sp)
  808970:	df000017 	ldw	fp,0(sp)
  808974:	dec00204 	addi	sp,sp,8
  808978:	f800283a 	ret

0080897c <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
  80897c:	defffe04 	addi	sp,sp,-8
  808980:	df000115 	stw	fp,4(sp)
  808984:	df000104 	addi	fp,sp,4
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  808988:	e03fff15 	stw	zero,-4(fp)
  80898c:	00000506 	br	8089a4 <alt_dcache_flush_all+0x28>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  808990:	e0bfff17 	ldw	r2,-4(fp)
  808994:	1000003b 	flushd	0(r2)
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  808998:	e0bfff17 	ldw	r2,-4(fp)
  80899c:	10800804 	addi	r2,r2,32
  8089a0:	e0bfff15 	stw	r2,-4(fp)
  8089a4:	e0bfff17 	ldw	r2,-4(fp)
  8089a8:	10820030 	cmpltui	r2,r2,2048
  8089ac:	103ff81e 	bne	r2,zero,808990 <__alt_mem_onchip_memory2_0+0xff788990>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
  8089b0:	0001883a 	nop
  8089b4:	e037883a 	mov	sp,fp
  8089b8:	df000017 	ldw	fp,0(sp)
  8089bc:	dec00104 	addi	sp,sp,4
  8089c0:	f800283a 	ret

008089c4 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
  8089c4:	defffc04 	addi	sp,sp,-16
  8089c8:	df000315 	stw	fp,12(sp)
  8089cc:	df000304 	addi	fp,sp,12
  8089d0:	e13ffd15 	stw	r4,-12(fp)
  8089d4:	e17ffe15 	stw	r5,-8(fp)
  8089d8:	e1bfff15 	stw	r6,-4(fp)
  return len;
  8089dc:	e0bfff17 	ldw	r2,-4(fp)
}
  8089e0:	e037883a 	mov	sp,fp
  8089e4:	df000017 	ldw	fp,0(sp)
  8089e8:	dec00104 	addi	sp,sp,4
  8089ec:	f800283a 	ret

008089f0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  8089f0:	defffe04 	addi	sp,sp,-8
  8089f4:	dfc00115 	stw	ra,4(sp)
  8089f8:	df000015 	stw	fp,0(sp)
  8089fc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  808a00:	00802074 	movhi	r2,129
  808a04:	10aae304 	addi	r2,r2,-21620
  808a08:	10800017 	ldw	r2,0(r2)
  808a0c:	10000526 	beq	r2,zero,808a24 <alt_get_errno+0x34>
  808a10:	00802074 	movhi	r2,129
  808a14:	10aae304 	addi	r2,r2,-21620
  808a18:	10800017 	ldw	r2,0(r2)
  808a1c:	103ee83a 	callr	r2
  808a20:	00000206 	br	808a2c <alt_get_errno+0x3c>
  808a24:	00802074 	movhi	r2,129
  808a28:	10aff304 	addi	r2,r2,-16436
}
  808a2c:	e037883a 	mov	sp,fp
  808a30:	dfc00117 	ldw	ra,4(sp)
  808a34:	df000017 	ldw	fp,0(sp)
  808a38:	dec00204 	addi	sp,sp,8
  808a3c:	f800283a 	ret

00808a40 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
  808a40:	defffa04 	addi	sp,sp,-24
  808a44:	dfc00515 	stw	ra,20(sp)
  808a48:	df000415 	stw	fp,16(sp)
  808a4c:	df000404 	addi	fp,sp,16
  808a50:	e13ffe15 	stw	r4,-8(fp)
  808a54:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  808a58:	e0bffe17 	ldw	r2,-8(fp)
  808a5c:	10000326 	beq	r2,zero,808a6c <alt_dev_llist_insert+0x2c>
  808a60:	e0bffe17 	ldw	r2,-8(fp)
  808a64:	10800217 	ldw	r2,8(r2)
  808a68:	1000061e 	bne	r2,zero,808a84 <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
  808a6c:	08089f00 	call	8089f0 <alt_get_errno>
  808a70:	1007883a 	mov	r3,r2
  808a74:	00800584 	movi	r2,22
  808a78:	18800015 	stw	r2,0(r3)
    return -EINVAL;
  808a7c:	00bffa84 	movi	r2,-22
  808a80:	00001306 	br	808ad0 <alt_dev_llist_insert+0x90>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
  808a84:	e0bffe17 	ldw	r2,-8(fp)
  808a88:	e0ffff17 	ldw	r3,-4(fp)
  808a8c:	e0fffc15 	stw	r3,-16(fp)
  808a90:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  808a94:	e0bffd17 	ldw	r2,-12(fp)
  808a98:	e0fffc17 	ldw	r3,-16(fp)
  808a9c:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
  808aa0:	e0bffc17 	ldw	r2,-16(fp)
  808aa4:	10c00017 	ldw	r3,0(r2)
  808aa8:	e0bffd17 	ldw	r2,-12(fp)
  808aac:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
  808ab0:	e0bffc17 	ldw	r2,-16(fp)
  808ab4:	10800017 	ldw	r2,0(r2)
  808ab8:	e0fffd17 	ldw	r3,-12(fp)
  808abc:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
  808ac0:	e0bffc17 	ldw	r2,-16(fp)
  808ac4:	e0fffd17 	ldw	r3,-12(fp)
  808ac8:	10c00015 	stw	r3,0(r2)

  return 0;  
  808acc:	0005883a 	mov	r2,zero
}
  808ad0:	e037883a 	mov	sp,fp
  808ad4:	dfc00117 	ldw	ra,4(sp)
  808ad8:	df000017 	ldw	fp,0(sp)
  808adc:	dec00204 	addi	sp,sp,8
  808ae0:	f800283a 	ret

00808ae4 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
  808ae4:	defffe04 	addi	sp,sp,-8
  808ae8:	dfc00115 	stw	ra,4(sp)
  808aec:	df000015 	stw	fp,0(sp)
  808af0:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
  808af4:	01440004 	movi	r5,4096
  808af8:	0009883a 	mov	r4,zero
  808afc:	08093500 	call	809350 <alt_icache_flush>
#endif
}
  808b00:	0001883a 	nop
  808b04:	e037883a 	mov	sp,fp
  808b08:	dfc00117 	ldw	ra,4(sp)
  808b0c:	df000017 	ldw	fp,0(sp)
  808b10:	dec00204 	addi	sp,sp,8
  808b14:	f800283a 	ret

00808b18 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
  808b18:	defff904 	addi	sp,sp,-28
  808b1c:	dfc00615 	stw	ra,24(sp)
  808b20:	df000515 	stw	fp,20(sp)
  808b24:	df000504 	addi	fp,sp,20
  808b28:	e13ffc15 	stw	r4,-16(fp)
  808b2c:	e17ffd15 	stw	r5,-12(fp)
  808b30:	e1bffe15 	stw	r6,-8(fp)
  808b34:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
  808b38:	e1bfff17 	ldw	r6,-4(fp)
  808b3c:	e17ffe17 	ldw	r5,-8(fp)
  808b40:	e13ffd17 	ldw	r4,-12(fp)
  808b44:	0808d740 	call	808d74 <open>
  808b48:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
  808b4c:	e0bffb17 	ldw	r2,-20(fp)
  808b50:	10001c16 	blt	r2,zero,808bc4 <alt_open_fd+0xac>
  {
    fd->dev      = alt_fd_list[old].dev;
  808b54:	00802074 	movhi	r2,129
  808b58:	10aa7b04 	addi	r2,r2,-22036
  808b5c:	e0fffb17 	ldw	r3,-20(fp)
  808b60:	18c00324 	muli	r3,r3,12
  808b64:	10c5883a 	add	r2,r2,r3
  808b68:	10c00017 	ldw	r3,0(r2)
  808b6c:	e0bffc17 	ldw	r2,-16(fp)
  808b70:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
  808b74:	00802074 	movhi	r2,129
  808b78:	10aa7b04 	addi	r2,r2,-22036
  808b7c:	e0fffb17 	ldw	r3,-20(fp)
  808b80:	18c00324 	muli	r3,r3,12
  808b84:	10c5883a 	add	r2,r2,r3
  808b88:	10800104 	addi	r2,r2,4
  808b8c:	10c00017 	ldw	r3,0(r2)
  808b90:	e0bffc17 	ldw	r2,-16(fp)
  808b94:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
  808b98:	00802074 	movhi	r2,129
  808b9c:	10aa7b04 	addi	r2,r2,-22036
  808ba0:	e0fffb17 	ldw	r3,-20(fp)
  808ba4:	18c00324 	muli	r3,r3,12
  808ba8:	10c5883a 	add	r2,r2,r3
  808bac:	10800204 	addi	r2,r2,8
  808bb0:	10c00017 	ldw	r3,0(r2)
  808bb4:	e0bffc17 	ldw	r2,-16(fp)
  808bb8:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
  808bbc:	e13ffb17 	ldw	r4,-20(fp)
  808bc0:	0808ecc0 	call	808ecc <alt_release_fd>
  }
} 
  808bc4:	0001883a 	nop
  808bc8:	e037883a 	mov	sp,fp
  808bcc:	dfc00117 	ldw	ra,4(sp)
  808bd0:	df000017 	ldw	fp,0(sp)
  808bd4:	dec00204 	addi	sp,sp,8
  808bd8:	f800283a 	ret

00808bdc <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
  808bdc:	defffb04 	addi	sp,sp,-20
  808be0:	dfc00415 	stw	ra,16(sp)
  808be4:	df000315 	stw	fp,12(sp)
  808be8:	df000304 	addi	fp,sp,12
  808bec:	e13ffd15 	stw	r4,-12(fp)
  808bf0:	e17ffe15 	stw	r5,-8(fp)
  808bf4:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
  808bf8:	01c07fc4 	movi	r7,511
  808bfc:	01800044 	movi	r6,1
  808c00:	e17ffd17 	ldw	r5,-12(fp)
  808c04:	01002074 	movhi	r4,129
  808c08:	212a7e04 	addi	r4,r4,-22024
  808c0c:	0808b180 	call	808b18 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
  808c10:	01c07fc4 	movi	r7,511
  808c14:	000d883a 	mov	r6,zero
  808c18:	e17ffe17 	ldw	r5,-8(fp)
  808c1c:	01002074 	movhi	r4,129
  808c20:	212a7b04 	addi	r4,r4,-22036
  808c24:	0808b180 	call	808b18 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
  808c28:	01c07fc4 	movi	r7,511
  808c2c:	01800044 	movi	r6,1
  808c30:	e17fff17 	ldw	r5,-4(fp)
  808c34:	01002074 	movhi	r4,129
  808c38:	212a8104 	addi	r4,r4,-22012
  808c3c:	0808b180 	call	808b18 <alt_open_fd>
}  
  808c40:	0001883a 	nop
  808c44:	e037883a 	mov	sp,fp
  808c48:	dfc00117 	ldw	ra,4(sp)
  808c4c:	df000017 	ldw	fp,0(sp)
  808c50:	dec00204 	addi	sp,sp,8
  808c54:	f800283a 	ret

00808c58 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  808c58:	defffe04 	addi	sp,sp,-8
  808c5c:	dfc00115 	stw	ra,4(sp)
  808c60:	df000015 	stw	fp,0(sp)
  808c64:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  808c68:	00802074 	movhi	r2,129
  808c6c:	10aae304 	addi	r2,r2,-21620
  808c70:	10800017 	ldw	r2,0(r2)
  808c74:	10000526 	beq	r2,zero,808c8c <alt_get_errno+0x34>
  808c78:	00802074 	movhi	r2,129
  808c7c:	10aae304 	addi	r2,r2,-21620
  808c80:	10800017 	ldw	r2,0(r2)
  808c84:	103ee83a 	callr	r2
  808c88:	00000206 	br	808c94 <alt_get_errno+0x3c>
  808c8c:	00802074 	movhi	r2,129
  808c90:	10aff304 	addi	r2,r2,-16436
}
  808c94:	e037883a 	mov	sp,fp
  808c98:	dfc00117 	ldw	ra,4(sp)
  808c9c:	df000017 	ldw	fp,0(sp)
  808ca0:	dec00204 	addi	sp,sp,8
  808ca4:	f800283a 	ret

00808ca8 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
  808ca8:	defffd04 	addi	sp,sp,-12
  808cac:	df000215 	stw	fp,8(sp)
  808cb0:	df000204 	addi	fp,sp,8
  808cb4:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
  808cb8:	e0bfff17 	ldw	r2,-4(fp)
  808cbc:	10800217 	ldw	r2,8(r2)
  808cc0:	10d00034 	orhi	r3,r2,16384
  808cc4:	e0bfff17 	ldw	r2,-4(fp)
  808cc8:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  808ccc:	e03ffe15 	stw	zero,-8(fp)
  808cd0:	00001d06 	br	808d48 <alt_file_locked+0xa0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
  808cd4:	00802074 	movhi	r2,129
  808cd8:	10aa7b04 	addi	r2,r2,-22036
  808cdc:	e0fffe17 	ldw	r3,-8(fp)
  808ce0:	18c00324 	muli	r3,r3,12
  808ce4:	10c5883a 	add	r2,r2,r3
  808ce8:	10c00017 	ldw	r3,0(r2)
  808cec:	e0bfff17 	ldw	r2,-4(fp)
  808cf0:	10800017 	ldw	r2,0(r2)
  808cf4:	1880111e 	bne	r3,r2,808d3c <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
  808cf8:	00802074 	movhi	r2,129
  808cfc:	10aa7b04 	addi	r2,r2,-22036
  808d00:	e0fffe17 	ldw	r3,-8(fp)
  808d04:	18c00324 	muli	r3,r3,12
  808d08:	10c5883a 	add	r2,r2,r3
  808d0c:	10800204 	addi	r2,r2,8
  808d10:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
  808d14:	1000090e 	bge	r2,zero,808d3c <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
  808d18:	e0bffe17 	ldw	r2,-8(fp)
  808d1c:	10c00324 	muli	r3,r2,12
  808d20:	00802074 	movhi	r2,129
  808d24:	10aa7b04 	addi	r2,r2,-22036
  808d28:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
  808d2c:	e0bfff17 	ldw	r2,-4(fp)
  808d30:	18800226 	beq	r3,r2,808d3c <alt_file_locked+0x94>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
  808d34:	00bffcc4 	movi	r2,-13
  808d38:	00000a06 	br	808d64 <alt_file_locked+0xbc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  808d3c:	e0bffe17 	ldw	r2,-8(fp)
  808d40:	10800044 	addi	r2,r2,1
  808d44:	e0bffe15 	stw	r2,-8(fp)
  808d48:	00802074 	movhi	r2,129
  808d4c:	10aae204 	addi	r2,r2,-21624
  808d50:	10800017 	ldw	r2,0(r2)
  808d54:	1007883a 	mov	r3,r2
  808d58:	e0bffe17 	ldw	r2,-8(fp)
  808d5c:	18bfdd2e 	bgeu	r3,r2,808cd4 <__alt_mem_onchip_memory2_0+0xff788cd4>
    }
  }
  
  /* The device is not locked */
 
  return 0;
  808d60:	0005883a 	mov	r2,zero
}
  808d64:	e037883a 	mov	sp,fp
  808d68:	df000017 	ldw	fp,0(sp)
  808d6c:	dec00104 	addi	sp,sp,4
  808d70:	f800283a 	ret

00808d74 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
  808d74:	defff604 	addi	sp,sp,-40
  808d78:	dfc00915 	stw	ra,36(sp)
  808d7c:	df000815 	stw	fp,32(sp)
  808d80:	df000804 	addi	fp,sp,32
  808d84:	e13ffd15 	stw	r4,-12(fp)
  808d88:	e17ffe15 	stw	r5,-8(fp)
  808d8c:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
  808d90:	00bfffc4 	movi	r2,-1
  808d94:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
  808d98:	00bffb44 	movi	r2,-19
  808d9c:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
  808da0:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
  808da4:	01402074 	movhi	r5,129
  808da8:	296ae004 	addi	r5,r5,-21632
  808dac:	e13ffd17 	ldw	r4,-12(fp)
  808db0:	08090f80 	call	8090f8 <alt_find_dev>
  808db4:	e0bff815 	stw	r2,-32(fp)
  808db8:	e0bff817 	ldw	r2,-32(fp)
  808dbc:	1000051e 	bne	r2,zero,808dd4 <open+0x60>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
  808dc0:	e13ffd17 	ldw	r4,-12(fp)
  808dc4:	08091880 	call	809188 <alt_find_file>
  808dc8:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
  808dcc:	00800044 	movi	r2,1
  808dd0:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
  808dd4:	e0bff817 	ldw	r2,-32(fp)
  808dd8:	10002926 	beq	r2,zero,808e80 <open+0x10c>
  {
    if ((index = alt_get_fd (dev)) < 0)
  808ddc:	e13ff817 	ldw	r4,-32(fp)
  808de0:	080929c0 	call	80929c <alt_get_fd>
  808de4:	e0bff915 	stw	r2,-28(fp)
  808de8:	e0bff917 	ldw	r2,-28(fp)
  808dec:	1000030e 	bge	r2,zero,808dfc <open+0x88>
    {
      status = index;
  808df0:	e0bff917 	ldw	r2,-28(fp)
  808df4:	e0bffa15 	stw	r2,-24(fp)
  808df8:	00002306 	br	808e88 <open+0x114>
    }
    else
    {
      fd = &alt_fd_list[index];
  808dfc:	e0bff917 	ldw	r2,-28(fp)
  808e00:	10c00324 	muli	r3,r2,12
  808e04:	00802074 	movhi	r2,129
  808e08:	10aa7b04 	addi	r2,r2,-22036
  808e0c:	1885883a 	add	r2,r3,r2
  808e10:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
  808e14:	e0fffe17 	ldw	r3,-8(fp)
  808e18:	00900034 	movhi	r2,16384
  808e1c:	10bfffc4 	addi	r2,r2,-1
  808e20:	1886703a 	and	r3,r3,r2
  808e24:	e0bffc17 	ldw	r2,-16(fp)
  808e28:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
  808e2c:	e0bffb17 	ldw	r2,-20(fp)
  808e30:	1000051e 	bne	r2,zero,808e48 <open+0xd4>
  808e34:	e13ffc17 	ldw	r4,-16(fp)
  808e38:	0808ca80 	call	808ca8 <alt_file_locked>
  808e3c:	e0bffa15 	stw	r2,-24(fp)
  808e40:	e0bffa17 	ldw	r2,-24(fp)
  808e44:	10001016 	blt	r2,zero,808e88 <open+0x114>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
  808e48:	e0bff817 	ldw	r2,-32(fp)
  808e4c:	10800317 	ldw	r2,12(r2)
  808e50:	10000826 	beq	r2,zero,808e74 <open+0x100>
  808e54:	e0bff817 	ldw	r2,-32(fp)
  808e58:	10800317 	ldw	r2,12(r2)
  808e5c:	e1ffff17 	ldw	r7,-4(fp)
  808e60:	e1bffe17 	ldw	r6,-8(fp)
  808e64:	e17ffd17 	ldw	r5,-12(fp)
  808e68:	e13ffc17 	ldw	r4,-16(fp)
  808e6c:	103ee83a 	callr	r2
  808e70:	00000106 	br	808e78 <open+0x104>
  808e74:	0005883a 	mov	r2,zero
  808e78:	e0bffa15 	stw	r2,-24(fp)
  808e7c:	00000206 	br	808e88 <open+0x114>
      }
    }
  }
  else
  {
    status = -ENODEV;
  808e80:	00bffb44 	movi	r2,-19
  808e84:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
  808e88:	e0bffa17 	ldw	r2,-24(fp)
  808e8c:	1000090e 	bge	r2,zero,808eb4 <open+0x140>
  {
    alt_release_fd (index);  
  808e90:	e13ff917 	ldw	r4,-28(fp)
  808e94:	0808ecc0 	call	808ecc <alt_release_fd>
    ALT_ERRNO = -status;
  808e98:	0808c580 	call	808c58 <alt_get_errno>
  808e9c:	1007883a 	mov	r3,r2
  808ea0:	e0bffa17 	ldw	r2,-24(fp)
  808ea4:	0085c83a 	sub	r2,zero,r2
  808ea8:	18800015 	stw	r2,0(r3)
    return -1;
  808eac:	00bfffc4 	movi	r2,-1
  808eb0:	00000106 	br	808eb8 <open+0x144>
  }
  
  /* return the reference upon success */

  return index;
  808eb4:	e0bff917 	ldw	r2,-28(fp)
}
  808eb8:	e037883a 	mov	sp,fp
  808ebc:	dfc00117 	ldw	ra,4(sp)
  808ec0:	df000017 	ldw	fp,0(sp)
  808ec4:	dec00204 	addi	sp,sp,8
  808ec8:	f800283a 	ret

00808ecc <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
  808ecc:	defffe04 	addi	sp,sp,-8
  808ed0:	df000115 	stw	fp,4(sp)
  808ed4:	df000104 	addi	fp,sp,4
  808ed8:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
  808edc:	e0bfff17 	ldw	r2,-4(fp)
  808ee0:	108000d0 	cmplti	r2,r2,3
  808ee4:	10000d1e 	bne	r2,zero,808f1c <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
  808ee8:	00802074 	movhi	r2,129
  808eec:	10aa7b04 	addi	r2,r2,-22036
  808ef0:	e0ffff17 	ldw	r3,-4(fp)
  808ef4:	18c00324 	muli	r3,r3,12
  808ef8:	10c5883a 	add	r2,r2,r3
  808efc:	10800204 	addi	r2,r2,8
  808f00:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
  808f04:	00802074 	movhi	r2,129
  808f08:	10aa7b04 	addi	r2,r2,-22036
  808f0c:	e0ffff17 	ldw	r3,-4(fp)
  808f10:	18c00324 	muli	r3,r3,12
  808f14:	10c5883a 	add	r2,r2,r3
  808f18:	10000015 	stw	zero,0(r2)
  }
}
  808f1c:	0001883a 	nop
  808f20:	e037883a 	mov	sp,fp
  808f24:	df000017 	ldw	fp,0(sp)
  808f28:	dec00104 	addi	sp,sp,4
  808f2c:	f800283a 	ret

00808f30 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
  808f30:	defffa04 	addi	sp,sp,-24
  808f34:	df000515 	stw	fp,20(sp)
  808f38:	df000504 	addi	fp,sp,20
  808f3c:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  808f40:	0005303a 	rdctl	r2,status
  808f44:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  808f48:	e0fffc17 	ldw	r3,-16(fp)
  808f4c:	00bfff84 	movi	r2,-2
  808f50:	1884703a 	and	r2,r3,r2
  808f54:	1001703a 	wrctl	status,r2
  
  return context;
  808f58:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
  808f5c:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
  808f60:	e0bfff17 	ldw	r2,-4(fp)
  808f64:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
  808f68:	e0bffd17 	ldw	r2,-12(fp)
  808f6c:	10800017 	ldw	r2,0(r2)
  808f70:	e0fffd17 	ldw	r3,-12(fp)
  808f74:	18c00117 	ldw	r3,4(r3)
  808f78:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
  808f7c:	e0bffd17 	ldw	r2,-12(fp)
  808f80:	10800117 	ldw	r2,4(r2)
  808f84:	e0fffd17 	ldw	r3,-12(fp)
  808f88:	18c00017 	ldw	r3,0(r3)
  808f8c:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
  808f90:	e0bffd17 	ldw	r2,-12(fp)
  808f94:	e0fffd17 	ldw	r3,-12(fp)
  808f98:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
  808f9c:	e0bffd17 	ldw	r2,-12(fp)
  808fa0:	e0fffd17 	ldw	r3,-12(fp)
  808fa4:	10c00015 	stw	r3,0(r2)
  808fa8:	e0bffb17 	ldw	r2,-20(fp)
  808fac:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  808fb0:	e0bffe17 	ldw	r2,-8(fp)
  808fb4:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
  808fb8:	0001883a 	nop
  808fbc:	e037883a 	mov	sp,fp
  808fc0:	df000017 	ldw	fp,0(sp)
  808fc4:	dec00104 	addi	sp,sp,4
  808fc8:	f800283a 	ret

00808fcc <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
  808fcc:	defffb04 	addi	sp,sp,-20
  808fd0:	dfc00415 	stw	ra,16(sp)
  808fd4:	df000315 	stw	fp,12(sp)
  808fd8:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
  808fdc:	d0a00917 	ldw	r2,-32732(gp)
  808fe0:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
  808fe4:	d0a51e17 	ldw	r2,-27528(gp)
  808fe8:	10800044 	addi	r2,r2,1
  808fec:	d0a51e15 	stw	r2,-27528(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  808ff0:	00002e06 	br	8090ac <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
  808ff4:	e0bffd17 	ldw	r2,-12(fp)
  808ff8:	10800017 	ldw	r2,0(r2)
  808ffc:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
  809000:	e0bffd17 	ldw	r2,-12(fp)
  809004:	10800403 	ldbu	r2,16(r2)
  809008:	10803fcc 	andi	r2,r2,255
  80900c:	10000426 	beq	r2,zero,809020 <alt_tick+0x54>
  809010:	d0a51e17 	ldw	r2,-27528(gp)
  809014:	1000021e 	bne	r2,zero,809020 <alt_tick+0x54>
    {
      alarm->rollover = 0;
  809018:	e0bffd17 	ldw	r2,-12(fp)
  80901c:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
  809020:	e0bffd17 	ldw	r2,-12(fp)
  809024:	10800217 	ldw	r2,8(r2)
  809028:	d0e51e17 	ldw	r3,-27528(gp)
  80902c:	18801d36 	bltu	r3,r2,8090a4 <alt_tick+0xd8>
  809030:	e0bffd17 	ldw	r2,-12(fp)
  809034:	10800403 	ldbu	r2,16(r2)
  809038:	10803fcc 	andi	r2,r2,255
  80903c:	1000191e 	bne	r2,zero,8090a4 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
  809040:	e0bffd17 	ldw	r2,-12(fp)
  809044:	10800317 	ldw	r2,12(r2)
  809048:	e0fffd17 	ldw	r3,-12(fp)
  80904c:	18c00517 	ldw	r3,20(r3)
  809050:	1809883a 	mov	r4,r3
  809054:	103ee83a 	callr	r2
  809058:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
  80905c:	e0bfff17 	ldw	r2,-4(fp)
  809060:	1000031e 	bne	r2,zero,809070 <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
  809064:	e13ffd17 	ldw	r4,-12(fp)
  809068:	0808f300 	call	808f30 <alt_alarm_stop>
  80906c:	00000d06 	br	8090a4 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
  809070:	e0bffd17 	ldw	r2,-12(fp)
  809074:	10c00217 	ldw	r3,8(r2)
  809078:	e0bfff17 	ldw	r2,-4(fp)
  80907c:	1887883a 	add	r3,r3,r2
  809080:	e0bffd17 	ldw	r2,-12(fp)
  809084:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
  809088:	e0bffd17 	ldw	r2,-12(fp)
  80908c:	10c00217 	ldw	r3,8(r2)
  809090:	d0a51e17 	ldw	r2,-27528(gp)
  809094:	1880032e 	bgeu	r3,r2,8090a4 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
  809098:	e0bffd17 	ldw	r2,-12(fp)
  80909c:	00c00044 	movi	r3,1
  8090a0:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
  8090a4:	e0bffe17 	ldw	r2,-8(fp)
  8090a8:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  8090ac:	e0fffd17 	ldw	r3,-12(fp)
  8090b0:	d0a00904 	addi	r2,gp,-32732
  8090b4:	18bfcf1e 	bne	r3,r2,808ff4 <__alt_mem_onchip_memory2_0+0xff788ff4>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
  8090b8:	0001883a 	nop
}
  8090bc:	0001883a 	nop
  8090c0:	e037883a 	mov	sp,fp
  8090c4:	dfc00117 	ldw	ra,4(sp)
  8090c8:	df000017 	ldw	fp,0(sp)
  8090cc:	dec00204 	addi	sp,sp,8
  8090d0:	f800283a 	ret

008090d4 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
  8090d4:	deffff04 	addi	sp,sp,-4
  8090d8:	df000015 	stw	fp,0(sp)
  8090dc:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
  8090e0:	000170fa 	wrctl	ienable,zero
}
  8090e4:	0001883a 	nop
  8090e8:	e037883a 	mov	sp,fp
  8090ec:	df000017 	ldw	fp,0(sp)
  8090f0:	dec00104 	addi	sp,sp,4
  8090f4:	f800283a 	ret

008090f8 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
  8090f8:	defffa04 	addi	sp,sp,-24
  8090fc:	dfc00515 	stw	ra,20(sp)
  809100:	df000415 	stw	fp,16(sp)
  809104:	df000404 	addi	fp,sp,16
  809108:	e13ffe15 	stw	r4,-8(fp)
  80910c:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
  809110:	e0bfff17 	ldw	r2,-4(fp)
  809114:	10800017 	ldw	r2,0(r2)
  809118:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
  80911c:	e13ffe17 	ldw	r4,-8(fp)
  809120:	08068540 	call	806854 <strlen>
  809124:	10800044 	addi	r2,r2,1
  809128:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  80912c:	00000d06 	br	809164 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
  809130:	e0bffc17 	ldw	r2,-16(fp)
  809134:	10800217 	ldw	r2,8(r2)
  809138:	e0fffd17 	ldw	r3,-12(fp)
  80913c:	180d883a 	mov	r6,r3
  809140:	e17ffe17 	ldw	r5,-8(fp)
  809144:	1009883a 	mov	r4,r2
  809148:	08094580 	call	809458 <memcmp>
  80914c:	1000021e 	bne	r2,zero,809158 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
  809150:	e0bffc17 	ldw	r2,-16(fp)
  809154:	00000706 	br	809174 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
  809158:	e0bffc17 	ldw	r2,-16(fp)
  80915c:	10800017 	ldw	r2,0(r2)
  809160:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  809164:	e0fffc17 	ldw	r3,-16(fp)
  809168:	e0bfff17 	ldw	r2,-4(fp)
  80916c:	18bff01e 	bne	r3,r2,809130 <__alt_mem_onchip_memory2_0+0xff789130>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
  809170:	0005883a 	mov	r2,zero
}
  809174:	e037883a 	mov	sp,fp
  809178:	dfc00117 	ldw	ra,4(sp)
  80917c:	df000017 	ldw	fp,0(sp)
  809180:	dec00204 	addi	sp,sp,8
  809184:	f800283a 	ret

00809188 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
  809188:	defffb04 	addi	sp,sp,-20
  80918c:	dfc00415 	stw	ra,16(sp)
  809190:	df000315 	stw	fp,12(sp)
  809194:	df000304 	addi	fp,sp,12
  809198:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
  80919c:	00802074 	movhi	r2,129
  8091a0:	10aade04 	addi	r2,r2,-21640
  8091a4:	10800017 	ldw	r2,0(r2)
  8091a8:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
  8091ac:	00003106 	br	809274 <alt_find_file+0xec>
  {
    len = strlen(next->name);
  8091b0:	e0bffd17 	ldw	r2,-12(fp)
  8091b4:	10800217 	ldw	r2,8(r2)
  8091b8:	1009883a 	mov	r4,r2
  8091bc:	08068540 	call	806854 <strlen>
  8091c0:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
  8091c4:	e0bffd17 	ldw	r2,-12(fp)
  8091c8:	10c00217 	ldw	r3,8(r2)
  8091cc:	e0bffe17 	ldw	r2,-8(fp)
  8091d0:	10bfffc4 	addi	r2,r2,-1
  8091d4:	1885883a 	add	r2,r3,r2
  8091d8:	10800003 	ldbu	r2,0(r2)
  8091dc:	10803fcc 	andi	r2,r2,255
  8091e0:	1080201c 	xori	r2,r2,128
  8091e4:	10bfe004 	addi	r2,r2,-128
  8091e8:	10800bd8 	cmpnei	r2,r2,47
  8091ec:	1000031e 	bne	r2,zero,8091fc <alt_find_file+0x74>
    {
      len -= 1;
  8091f0:	e0bffe17 	ldw	r2,-8(fp)
  8091f4:	10bfffc4 	addi	r2,r2,-1
  8091f8:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
  8091fc:	e0bffe17 	ldw	r2,-8(fp)
  809200:	e0ffff17 	ldw	r3,-4(fp)
  809204:	1885883a 	add	r2,r3,r2
  809208:	10800003 	ldbu	r2,0(r2)
  80920c:	10803fcc 	andi	r2,r2,255
  809210:	1080201c 	xori	r2,r2,128
  809214:	10bfe004 	addi	r2,r2,-128
  809218:	10800be0 	cmpeqi	r2,r2,47
  80921c:	1000081e 	bne	r2,zero,809240 <alt_find_file+0xb8>
  809220:	e0bffe17 	ldw	r2,-8(fp)
  809224:	e0ffff17 	ldw	r3,-4(fp)
  809228:	1885883a 	add	r2,r3,r2
  80922c:	10800003 	ldbu	r2,0(r2)
  809230:	10803fcc 	andi	r2,r2,255
  809234:	1080201c 	xori	r2,r2,128
  809238:	10bfe004 	addi	r2,r2,-128
  80923c:	10000a1e 	bne	r2,zero,809268 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
  809240:	e0bffd17 	ldw	r2,-12(fp)
  809244:	10800217 	ldw	r2,8(r2)
  809248:	e0fffe17 	ldw	r3,-8(fp)
  80924c:	180d883a 	mov	r6,r3
  809250:	e17fff17 	ldw	r5,-4(fp)
  809254:	1009883a 	mov	r4,r2
  809258:	08094580 	call	809458 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
  80925c:	1000021e 	bne	r2,zero,809268 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
  809260:	e0bffd17 	ldw	r2,-12(fp)
  809264:	00000806 	br	809288 <alt_find_file+0x100>
    }
    next = (alt_dev*) next->llist.next;
  809268:	e0bffd17 	ldw	r2,-12(fp)
  80926c:	10800017 	ldw	r2,0(r2)
  809270:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
  809274:	e0fffd17 	ldw	r3,-12(fp)
  809278:	00802074 	movhi	r2,129
  80927c:	10aade04 	addi	r2,r2,-21640
  809280:	18bfcb1e 	bne	r3,r2,8091b0 <__alt_mem_onchip_memory2_0+0xff7891b0>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
  809284:	0005883a 	mov	r2,zero
}
  809288:	e037883a 	mov	sp,fp
  80928c:	dfc00117 	ldw	ra,4(sp)
  809290:	df000017 	ldw	fp,0(sp)
  809294:	dec00204 	addi	sp,sp,8
  809298:	f800283a 	ret

0080929c <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
  80929c:	defffc04 	addi	sp,sp,-16
  8092a0:	df000315 	stw	fp,12(sp)
  8092a4:	df000304 	addi	fp,sp,12
  8092a8:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
  8092ac:	00bffa04 	movi	r2,-24
  8092b0:	e0bffe15 	stw	r2,-8(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
  8092b4:	e03ffd15 	stw	zero,-12(fp)
  8092b8:	00001d06 	br	809330 <alt_get_fd+0x94>
  {
    if (!alt_fd_list[i].dev)
  8092bc:	00802074 	movhi	r2,129
  8092c0:	10aa7b04 	addi	r2,r2,-22036
  8092c4:	e0fffd17 	ldw	r3,-12(fp)
  8092c8:	18c00324 	muli	r3,r3,12
  8092cc:	10c5883a 	add	r2,r2,r3
  8092d0:	10800017 	ldw	r2,0(r2)
  8092d4:	1000131e 	bne	r2,zero,809324 <alt_get_fd+0x88>
    {
      alt_fd_list[i].dev = dev;
  8092d8:	00802074 	movhi	r2,129
  8092dc:	10aa7b04 	addi	r2,r2,-22036
  8092e0:	e0fffd17 	ldw	r3,-12(fp)
  8092e4:	18c00324 	muli	r3,r3,12
  8092e8:	10c5883a 	add	r2,r2,r3
  8092ec:	e0ffff17 	ldw	r3,-4(fp)
  8092f0:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
  8092f4:	00802074 	movhi	r2,129
  8092f8:	10aae204 	addi	r2,r2,-21624
  8092fc:	10c00017 	ldw	r3,0(r2)
  809300:	e0bffd17 	ldw	r2,-12(fp)
  809304:	1880040e 	bge	r3,r2,809318 <alt_get_fd+0x7c>
      {
        alt_max_fd = i;
  809308:	00802074 	movhi	r2,129
  80930c:	10aae204 	addi	r2,r2,-21624
  809310:	e0fffd17 	ldw	r3,-12(fp)
  809314:	10c00015 	stw	r3,0(r2)
      }
      rc = i;
  809318:	e0bffd17 	ldw	r2,-12(fp)
  80931c:	e0bffe15 	stw	r2,-8(fp)
      goto alt_get_fd_exit;
  809320:	00000606 	br	80933c <alt_get_fd+0xa0>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
  809324:	e0bffd17 	ldw	r2,-12(fp)
  809328:	10800044 	addi	r2,r2,1
  80932c:	e0bffd15 	stw	r2,-12(fp)
  809330:	e0bffd17 	ldw	r2,-12(fp)
  809334:	10800810 	cmplti	r2,r2,32
  809338:	103fe01e 	bne	r2,zero,8092bc <__alt_mem_onchip_memory2_0+0xff7892bc>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
  80933c:	e0bffe17 	ldw	r2,-8(fp)
}
  809340:	e037883a 	mov	sp,fp
  809344:	df000017 	ldw	fp,0(sp)
  809348:	dec00104 	addi	sp,sp,4
  80934c:	f800283a 	ret

00809350 <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
  809350:	defffb04 	addi	sp,sp,-20
  809354:	df000415 	stw	fp,16(sp)
  809358:	df000404 	addi	fp,sp,16
  80935c:	e13ffe15 	stw	r4,-8(fp)
  809360:	e17fff15 	stw	r5,-4(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
  809364:	e0bfff17 	ldw	r2,-4(fp)
  809368:	10840070 	cmpltui	r2,r2,4097
  80936c:	1000021e 	bne	r2,zero,809378 <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
  809370:	00840004 	movi	r2,4096
  809374:	e0bfff15 	stw	r2,-4(fp)
  }

  end = ((char*) start) + len;
  809378:	e0fffe17 	ldw	r3,-8(fp)
  80937c:	e0bfff17 	ldw	r2,-4(fp)
  809380:	1885883a 	add	r2,r3,r2
  809384:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
  809388:	e0bffe17 	ldw	r2,-8(fp)
  80938c:	e0bffc15 	stw	r2,-16(fp)
  809390:	00000506 	br	8093a8 <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
  809394:	e0bffc17 	ldw	r2,-16(fp)
  809398:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
  80939c:	e0bffc17 	ldw	r2,-16(fp)
  8093a0:	10800804 	addi	r2,r2,32
  8093a4:	e0bffc15 	stw	r2,-16(fp)
  8093a8:	e0fffc17 	ldw	r3,-16(fp)
  8093ac:	e0bffd17 	ldw	r2,-12(fp)
  8093b0:	18bff836 	bltu	r3,r2,809394 <__alt_mem_onchip_memory2_0+0xff789394>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
  8093b4:	e0bffe17 	ldw	r2,-8(fp)
  8093b8:	108007cc 	andi	r2,r2,31
  8093bc:	10000226 	beq	r2,zero,8093c8 <alt_icache_flush+0x78>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
  8093c0:	e0bffc17 	ldw	r2,-16(fp)
  8093c4:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
  8093c8:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
  8093cc:	0001883a 	nop
  8093d0:	e037883a 	mov	sp,fp
  8093d4:	df000017 	ldw	fp,0(sp)
  8093d8:	dec00104 	addi	sp,sp,4
  8093dc:	f800283a 	ret

008093e0 <exit>:
  8093e0:	defffe04 	addi	sp,sp,-8
  8093e4:	000b883a 	mov	r5,zero
  8093e8:	dc000015 	stw	r16,0(sp)
  8093ec:	dfc00115 	stw	ra,4(sp)
  8093f0:	2021883a 	mov	r16,r4
  8093f4:	08094880 	call	809488 <__call_exitprocs>
  8093f8:	8009883a 	mov	r4,r16
  8093fc:	08096180 	call	809618 <_exit>

00809400 <fputs>:
  809400:	defffd04 	addi	sp,sp,-12
  809404:	dfc00215 	stw	ra,8(sp)
  809408:	dc000115 	stw	r16,4(sp)
  80940c:	d9400015 	stw	r5,0(sp)
  809410:	2021883a 	mov	r16,r4
  809414:	08068540 	call	806854 <strlen>
  809418:	100f883a 	mov	r7,r2
  80941c:	00802074 	movhi	r2,129
  809420:	d9400017 	ldw	r5,0(sp)
  809424:	10aadc04 	addi	r2,r2,-21648
  809428:	11000017 	ldw	r4,0(r2)
  80942c:	00c02034 	movhi	r3,128
  809430:	18dbe504 	addi	r3,r3,28564
  809434:	28c00115 	stw	r3,4(r5)
  809438:	800d883a 	mov	r6,r16
  80943c:	0806f940 	call	806f94 <__sfvwrite_small_dev>
  809440:	10bfffe0 	cmpeqi	r2,r2,-1
  809444:	0085c83a 	sub	r2,zero,r2
  809448:	dfc00217 	ldw	ra,8(sp)
  80944c:	dc000117 	ldw	r16,4(sp)
  809450:	dec00304 	addi	sp,sp,12
  809454:	f800283a 	ret

00809458 <memcmp>:
  809458:	218d883a 	add	r6,r4,r6
  80945c:	21800826 	beq	r4,r6,809480 <memcmp+0x28>
  809460:	20800003 	ldbu	r2,0(r4)
  809464:	28c00003 	ldbu	r3,0(r5)
  809468:	10c00226 	beq	r2,r3,809474 <memcmp+0x1c>
  80946c:	10c5c83a 	sub	r2,r2,r3
  809470:	f800283a 	ret
  809474:	21000044 	addi	r4,r4,1
  809478:	29400044 	addi	r5,r5,1
  80947c:	003ff706 	br	80945c <__alt_mem_onchip_memory2_0+0xff78945c>
  809480:	0005883a 	mov	r2,zero
  809484:	f800283a 	ret

00809488 <__call_exitprocs>:
  809488:	defff504 	addi	sp,sp,-44
  80948c:	dd000515 	stw	r20,20(sp)
  809490:	05002074 	movhi	r20,129
  809494:	dc800315 	stw	r18,12(sp)
  809498:	dfc00a15 	stw	ra,40(sp)
  80949c:	df000915 	stw	fp,36(sp)
  8094a0:	ddc00815 	stw	r23,32(sp)
  8094a4:	dd800715 	stw	r22,28(sp)
  8094a8:	dd400615 	stw	r21,24(sp)
  8094ac:	dcc00415 	stw	r19,16(sp)
  8094b0:	dc400215 	stw	r17,8(sp)
  8094b4:	dc000115 	stw	r16,4(sp)
  8094b8:	d9000015 	stw	r4,0(sp)
  8094bc:	2825883a 	mov	r18,r5
  8094c0:	a52adb04 	addi	r20,r20,-21652
  8094c4:	a4400017 	ldw	r17,0(r20)
  8094c8:	8cc00c17 	ldw	r19,48(r17)
  8094cc:	8c400c04 	addi	r17,r17,48
  8094d0:	98004526 	beq	r19,zero,8095e8 <__call_exitprocs+0x160>
  8094d4:	9c000117 	ldw	r16,4(r19)
  8094d8:	00900034 	movhi	r2,16384
  8094dc:	10bfffc4 	addi	r2,r2,-1
  8094e0:	9d402217 	ldw	r21,136(r19)
  8094e4:	85bfffc4 	addi	r22,r16,-1
  8094e8:	80a1883a 	add	r16,r16,r2
  8094ec:	8421883a 	add	r16,r16,r16
  8094f0:	8421883a 	add	r16,r16,r16
  8094f4:	ac2f883a 	add	r23,r21,r16
  8094f8:	84000204 	addi	r16,r16,8
  8094fc:	9c21883a 	add	r16,r19,r16
  809500:	b0002716 	blt	r22,zero,8095a0 <__call_exitprocs+0x118>
  809504:	90000726 	beq	r18,zero,809524 <__call_exitprocs+0x9c>
  809508:	a800041e 	bne	r21,zero,80951c <__call_exitprocs+0x94>
  80950c:	b5bfffc4 	addi	r22,r22,-1
  809510:	bdffff04 	addi	r23,r23,-4
  809514:	843fff04 	addi	r16,r16,-4
  809518:	003ff906 	br	809500 <__alt_mem_onchip_memory2_0+0xff789500>
  80951c:	b9002017 	ldw	r4,128(r23)
  809520:	913ffa1e 	bne	r18,r4,80950c <__alt_mem_onchip_memory2_0+0xff78950c>
  809524:	99000117 	ldw	r4,4(r19)
  809528:	82000017 	ldw	r8,0(r16)
  80952c:	213fffc4 	addi	r4,r4,-1
  809530:	b100021e 	bne	r22,r4,80953c <__call_exitprocs+0xb4>
  809534:	9d800115 	stw	r22,4(r19)
  809538:	00000106 	br	809540 <__call_exitprocs+0xb8>
  80953c:	80000015 	stw	zero,0(r16)
  809540:	403ff226 	beq	r8,zero,80950c <__alt_mem_onchip_memory2_0+0xff78950c>
  809544:	9f000117 	ldw	fp,4(r19)
  809548:	a8000526 	beq	r21,zero,809560 <__call_exitprocs+0xd8>
  80954c:	00800044 	movi	r2,1
  809550:	1592983a 	sll	r9,r2,r22
  809554:	a9404017 	ldw	r5,256(r21)
  809558:	494a703a 	and	r5,r9,r5
  80955c:	2800021e 	bne	r5,zero,809568 <__call_exitprocs+0xe0>
  809560:	403ee83a 	callr	r8
  809564:	00000906 	br	80958c <__call_exitprocs+0x104>
  809568:	a9004117 	ldw	r4,260(r21)
  80956c:	4908703a 	and	r4,r9,r4
  809570:	2000041e 	bne	r4,zero,809584 <__call_exitprocs+0xfc>
  809574:	b9400017 	ldw	r5,0(r23)
  809578:	d9000017 	ldw	r4,0(sp)
  80957c:	403ee83a 	callr	r8
  809580:	00000206 	br	80958c <__call_exitprocs+0x104>
  809584:	b9000017 	ldw	r4,0(r23)
  809588:	403ee83a 	callr	r8
  80958c:	99000117 	ldw	r4,4(r19)
  809590:	e13fcc1e 	bne	fp,r4,8094c4 <__alt_mem_onchip_memory2_0+0xff7894c4>
  809594:	89000017 	ldw	r4,0(r17)
  809598:	993fdc26 	beq	r19,r4,80950c <__alt_mem_onchip_memory2_0+0xff78950c>
  80959c:	003fc906 	br	8094c4 <__alt_mem_onchip_memory2_0+0xff7894c4>
  8095a0:	00800034 	movhi	r2,0
  8095a4:	10800004 	addi	r2,r2,0
  8095a8:	10000f26 	beq	r2,zero,8095e8 <__call_exitprocs+0x160>
  8095ac:	99400117 	ldw	r5,4(r19)
  8095b0:	99000017 	ldw	r4,0(r19)
  8095b4:	2800091e 	bne	r5,zero,8095dc <__call_exitprocs+0x154>
  8095b8:	20000826 	beq	r4,zero,8095dc <__call_exitprocs+0x154>
  8095bc:	89000015 	stw	r4,0(r17)
  8095c0:	a8000226 	beq	r21,zero,8095cc <__call_exitprocs+0x144>
  8095c4:	a809883a 	mov	r4,r21
  8095c8:	00000000 	call	0 <__alt_mem_sdram-0x800000>
  8095cc:	9809883a 	mov	r4,r19
  8095d0:	00000000 	call	0 <__alt_mem_sdram-0x800000>
  8095d4:	8cc00017 	ldw	r19,0(r17)
  8095d8:	003fbd06 	br	8094d0 <__alt_mem_onchip_memory2_0+0xff7894d0>
  8095dc:	9823883a 	mov	r17,r19
  8095e0:	2027883a 	mov	r19,r4
  8095e4:	003fba06 	br	8094d0 <__alt_mem_onchip_memory2_0+0xff7894d0>
  8095e8:	dfc00a17 	ldw	ra,40(sp)
  8095ec:	df000917 	ldw	fp,36(sp)
  8095f0:	ddc00817 	ldw	r23,32(sp)
  8095f4:	dd800717 	ldw	r22,28(sp)
  8095f8:	dd400617 	ldw	r21,24(sp)
  8095fc:	dd000517 	ldw	r20,20(sp)
  809600:	dcc00417 	ldw	r19,16(sp)
  809604:	dc800317 	ldw	r18,12(sp)
  809608:	dc400217 	ldw	r17,8(sp)
  80960c:	dc000117 	ldw	r16,4(sp)
  809610:	dec00b04 	addi	sp,sp,44
  809614:	f800283a 	ret

00809618 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
  809618:	defffd04 	addi	sp,sp,-12
  80961c:	df000215 	stw	fp,8(sp)
  809620:	df000204 	addi	fp,sp,8
  809624:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
  809628:	0001883a 	nop
  80962c:	e0bfff17 	ldw	r2,-4(fp)
  809630:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
  809634:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
  809638:	10000226 	beq	r2,zero,809644 <_exit+0x2c>
    ALT_SIM_FAIL();
  80963c:	002af070 	cmpltui	zero,zero,43969
  809640:	00000106 	br	809648 <_exit+0x30>
  } else {
    ALT_SIM_PASS();
  809644:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
  809648:	003fff06 	br	809648 <__alt_mem_onchip_memory2_0+0xff789648>
